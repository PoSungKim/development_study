# 주요 개념
> Django 관련 주요 개념 정리

* Django가 사용되는 이유 및 성능 유지가 가능한 이유 등

<hr>
<br>

### [MVT]

#### 1. MVT - Model
* Django MVT 패턴은 전반적으로 Ruby on Rails MVC 패턴과 매우 흡사
* Ruby on Rails의 MVC 패턴에서 같은 M을 수행하는 패턴 
* DB를 사용할 수 있게 DBMS에 연동하거나 Table을 Define하는 작업들이 포함됌

### [각 App의 models.py - User App 예시]
```python
from django.db import models

# Create your models here.


class User(models.Model):
    username = models.CharField(max_length=64,
                                verbose_name='username')

    password = models.CharField(max_length=64,
                                verbose_name='password')

    register_date = models.DateTimeField(auto_now_add=True,
                                         verbose_name='register date')

    # Admin 페이지에서 class가 문자열로 변환됐을 때, 어떻게 표현이 될지 설정
    def __str__(self):
        return self.username

    class Meta:  # table명
        db_table = 'User'

```

### [Terminal]
```zsh
python3 manage.py makemigrations # 0001_initial.py 형상관리용 데이터 생성
python3 manage.py migrate        # 실제 DB에 Table 생성
sqlite3 db.sqlite3               # DBMS 접속
.tables
.schema [tableName]
```

#### 2. MVT - View
* View 패턴으로, Request에 맞는 올바른 html 페이지가 보이도록 연결
* Project - urls.py --> app - urls.py --> app - views.py --> template.html 순으로 연결
* csrf_token (Cross Site Request Forgery): Cross Domain 등 모든 Client 서버로부터의 request를 받는 것은 보안적으로 매우 취약하기 때문에, token이 있는 Client 서버의 Request만 받아야 함

### [project/urls.py]
```python
from django.contrib import admin
from django.urls import path, include

# /admin/* 이러한 형태의 주소는 모두 admin 페이지로 간다
urlpatterns = [
    path('admin/', admin.site.urls),
    path('user/', include('user.urls'))
]
```

### [app/views.py]
```python
from django.shortcuts import render

# Create your views here.


def register(request):
    return render(request, 'register.html')

```

### [app/urls.py]
```python
from django.urls import path
from . import views

urlpatterns = [
    path('register/', views.register)
]
```

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <h1>회원가입</h1>
    <form action="" method="POST" action=".">
        {% csrf_token %}
        <div>
            <label for="username">유저명</label>
            <input type="text" name="" id="username">
        </div>
        <br>
        <div>
            <label for="password">비밀번호</label>
            <input type="password" name="" id="password">
        </div>
        <br>
        <div>
            <label for="re-password">비밀번호 확인</label>
            <input type="password" name="" id="re-password">
        </div>
        <br>
        <button type="submit">등록</button>
    </form>
</body>

</html>
```

#### 3. MVT - Template
* Virtual DOM은 JavaScript 객체로서 Memory에 적재되기 때문에, 빠르게 구축될 수 있다는 장점이 존재

<br>
<hr>
<br>


### [REST API] - http://www.django-rest-framework.org 참고링크

#### 1. VPI
* REST(Representational State Transfer) API
    * REST는 어떠한 프로토콜과도 독립적
    * REST는 꼭 HTTP에 연결될 필요가 없기에, 꼭 HTTP 연결에 국한할 필요는 없지만, 대부분이 HTTP에 연결하는 방식으로 사용함
    * 통상적인 RESTful API Request 구성
        * URI (/리소스 중심)
        * HTTP (POST, GET, PUT, DELETE)
        * JSON (데이터 표현 방식)

### [HTTP]
```http
https://adventure-works.com/orders/1
```
### [JSON]
```JSON
{"orderId":1,"orderValue":99.90,"productId":1,"quantity":1}
```

* RESTful API 성숙도 (2008년 - Leonard Richardson) - 대다수의 Web API는 수준 2에 머물러 있다고 함
    * 수준 0: 한 URI를 정의합니다.
    * 수준 1: 개별 리소스에 대한 별도의 URI를 만듭니다.
    * 수준 2: HTTP 메서드를 사용하여 리소스에 대한 작업을 정의합니다.
    * 수준 3: 하이퍼미디어(HATEOAS, 아래에 설명)를 사용합니다. 

### [POST Request 예시]
```
POST https://adventure-works.com/orders HTTP/1.1
Content-Type: application/json; charset=utf-8
Content-Length: 57

{"Id":1,"Name":"Gizmo","Category":"Widgets","Price":1.99}
```

### [GET Request 예시]
```
GET https://adventure-works.com/orders/2 HTTP/1.1
Accept: application/json
```
* JSON 타입의 데이터를 반환받겠다는 뜻


#### 2. HTTP 상태코드 
* GET
    * 200 (정상 - 가져옴)
    * 404 (비정상 - 찾을 수 없음)
* POST
    * 201 (정상 - 만들어짐)
    * 200 (정상 - 반환 내용 O)
    * 204 (정상 - 반환 내용 X)
    * 400 (비정상 - 잘못된 요청)
* PUT
    * 201 (정상 - 만들어짐)
    * 200 (정상 - 반환 내용 O)
    * 204 (정상 - 반환 내용 X)
    * 400 (비정상 - 충돌)

* DELETE
    * 204 (정상 - 반환 X)
    * 404 (비정상 - 찾을 수 없음)


<br>
<hr>
<br>

### [작업 환경]

#### 1. Virtual Environment(가상 환경)에 Django 환경 셋업

### [Terminal]
```zsh
pip3 install virtualenv
virtualenv virtual_env
source virtual_env/bin/activate
pip3 install django
django-admin startproject Django_Backend // djangdjango-admin startproject [projectName] 
django-admin startapp     user           // django-admin startapp [appName]
```
* 하나의 PC에서 다수의 프로젝트를 진행할 때 같은 패키지들을 사용하면서도 다른 버전의 패키지들을 사용하게 되면 에러 상항이 많이 발생할 수 있기 때문에 하나의 프로젝트만을 위한 가상 환경을 구축하는 것이 Convention
 * 다만, 꼭 virtualenv를 사용할 필요는 
* 하나의 Project 안에 다수의 App 존재 (1:N 관계)


### [settings.py]
```python
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'user'
]
```
* Project의 setting.py에 생성한 app들을 등록하는 절차

#### 2. Superuser + Admin Page

### [Terminal]
```zsh
python3 manage.py createsuperuser
```

### [admin.py]
```python
from django.contrib import admin
from .models import User

# Register your models here.


class UserAdmin(admin.ModelAdmin):
    list_display = ('username', 'password')

# Admin Page에 모델 등록
admin.site.register(User, UserAdmin)
```
* Default 세팅으로 /admin/* Request는 Admin Page로 이동 (urls.py 참고)
* Admin Page에 어떠한 모델이 보일 것이고, 어떠한 내용들이 Display될지 설정

#### 3. RESTful API

### [Terminal]
```zsh
pip3 install djangorestframework
```

### [setting.py]
```python
...
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'rest_framework',
]
...
```

### [views.py]
```python
class UserListAPI(generics.GenericAPIView) :
    serializer_class = UserSerializer
    
    def get(self, request, *args, **kwargs) :
        self.queryset = User.objects.raw("SELECT * FROM User")
        dataJSON = serializers.serialize('json', self.queryset)
        return HttpResponse(dataJSON, content_type="text/json-comment-filtered")

class UserDetailAPI(generics.GenericAPIView) :
    serializer_class = UserSerializer

    def get(self, request, *args, **kwargs) :
        self.queryset = User.objects.raw("SELECT * FROM User WHERE id = %s", str(kwargs['pk']))
        dataJSON = serializers.serialize('json', self.queryset)
        return HttpResponse(dataJSON, content_type="text/json-comment-filtered")
```
* QuerySet 방식 : 일반 ORM 방식으로 [modelName].objects.all()과 같은 표현 방식을 취함
* RawQuerySet 방식 : SQL문을 직접 작성하는 ORM 방식으로, [modelName].objects.raw(raw_query, params=None, translations=None)과 같은 표현 방식을 취함

### [urls.py]
```python
urlpatterns = [
    ...,
    path('api/user/', UserListAPI.as_view()),
    path('api/user/<int:pk>', UserDetailAPI.as_view())
]

```

#### 4. MySQL (AWS RDS) 연동

### [Terminal]
```zsh
pip install mysqlclient      
```

### [settings.py]
```python

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': [database 이름]
        'USER': [유저명],
        'PASSWORD': [비밀번호],
        'HOST': [IP 주소],
        'PORT': '3306',
        'OPTIONS': {
            'init_command': "SET sql_mode='STRICT_TRANS_TABLES'",
        },
    }
}
```

```zsh
mysql -u admin -p  -h [IP Address]
create database [Database Name] # Database 생성까지 해줘서 접속 가능
...exit

python3 manage.py makemigrations 
python3 manage.py migrate
python3 manage.py runserver
```

#### 5. CORS 해결
```zsh
pip install django-cors-headers
```

### [settings.py]
```python
INSTALLED_APPS = [
...
	'corsheaders'
]

MIDDLEWARE = [
...
	'corsheaders.middleware.CorsMiddleware',

]
```


#### 프로젝트 시작

### [Terminal]
```zsh
python3 manage.py runserver
```
