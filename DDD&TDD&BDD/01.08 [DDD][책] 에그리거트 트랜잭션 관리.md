# 에그리거트 트랜잭션 관리
> 
* 

<hr>
<br>

## 애그리거트와 트랜젝션
#### 한 애그리거트를 두 사용자가 동시에 변경할 때 트랜잭션 필요

<br>

### DB 일관성 보존 필요
* ex) 운영자와 고객이 동일한 애그리거트를 사용하면 일관성이 깨진다
* 일관성 보존 방법
  * 운영자가 배송지 정보를 조회하고 상태를 변경하는 동안, 고객이 애그리거트를 수정하지 못하게 막는다
  * 운영자가 배송지 정보를 조회한 이후에 고객이 정보를 변경하면, 운영자가 애그리거트를 다시 조회한 뒤 수정하도록 한다
* DBMS에서 지원하는 트랜잭션 처리 방식 필요
  * 선점 잠금 (Pessimistic 잠금)
  * 비선점 잠금 (Optimistic 잠금)

<br>
<hr>
<br>

## 선점 잠금 (Pessimistic 잠금)
#### 먼저 애그리거트를 구한 스레드가 애그리거트 사용이 끝날 때까지 다른 스레드가 해당 애그리거트를 수정하지 못하게 막는 방식

<br>

### 선점한 쓰레드가 자원 사용을 블로킹
* 보통 DBMS가 제공하는 행단위 잠금을 사용해서 구현
* 오라클을 비롯한 다수의 DBMS가 for update와 같은 쿼리를 사용해서 특정 레코드에 한 커넥션만 접근할 수 있는 잠금장치 제공
* JPA EntityManager는 LockModeType을 인자로 받는 find() 메소드 제공
```java
Order order = entityManager.find( Order.class, orderNo, LockModeType.PESSIMISTIC_WRITE )
```
```java
public interface MemberRepository extends Repository<Member, MemberId> {
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query("select m from Member m where m.id = :id")
    Optional<Member> findByIdForUpdate(@Param("id") MemberId memberId);
}
```

<br>

### 선점 잠금과 교착 상태
* 유명한 예시
  * `거래1 (A-B)`, `거래2 (B-A)`
* 많은 쓰레드가 발생하면 교착 상태에 빠질 확률이 높아진다
* 힌트를 통한 최고 대기 시간 지정 필요
```java
Map<String, String> hints = new HashMap<>();
hints.put("javax.persistence.timeout", 2000);
Order order = entityManager.find( Order.class, orderNo, LockModeType.PESSIMISTIC_WRITE, hints );
```
```java
public interface MemberRepository extends Repository<Member, MemberId> {
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @QueryHints({
        @QueryHint( name = "javax.persistence.lock.timeout", value = "2000" )
    })
    @Query("select m from Member m where m.id = :id")
    Optional<Member> findByIdForUpdate(@Param("id") MemberId memberId);
}
```
* DBMS에 따라 교착 상태에 빠진 커넥션을 처리하는 방식이 다름
  * 쿼리별
  * 커넥션별
* 각 DBMS에 대해, JPA가 대기 시간을 어떻게 처리하는지 확인 필요

<br>
<hr>
<br>

## 비선점 잠금
#### 동시에 접근하는 것을 막는 대신 변경한 데이터를 실제 DBMS에 반영하는 시점에 변경 가능 여부를 확인하는 방식

<br>

### version이 동일하면 커밋 성공; 아니면, 커밋 실패
```java
@Entity
@Table(name = "purchase_order")
@Access(AccessType.FIELD)
public class Order {
    @EmbeddedId
    private OrderNo number;
    
    @Version
    private long version;
}
```
```sql
UPDATE purchase_order SET ...생략, version = version + 1
WHERE  number = ? and version = 10
```
```java
public class ChangeShippingService {
    
    @Transactional
    public void changeShipping(ChangeShippingRequest changeReq) {
        Order order = orderRepository.findById(new OrderNo( changeReq.getNumber()));
        checkNoOrder(order);
        order.changeShippingInfo(changeReq.getShippingInfo());
    }
    
}
```
```java
@Controller
public class OrderController {
    private ChangeShippingService changeShippingService;
    
    @PostMapping("/changeShipping")
    public String changeShipping(ChangeShippingRequest changeReq) {
        try {
            changeShippingService.changeShipping(changeReq);
            return "changeShippingSuccess";
        } catch( OptimisticLockingFailureException ex ) {
            // 트랜젝션 충돌 메세지
            return "changeShippingTxConflict";
        }
    }
}
```

<br>
<hr>
<br>
