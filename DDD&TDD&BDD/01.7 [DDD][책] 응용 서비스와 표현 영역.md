# 응용 서비스와 표현 영역
> 도메인이 제 기능을 하면 사용자와 도메인을 연결해 주는 매개체 필요
* 매개체의 역할을 응용 서비스와 표현 영역이 수행

<hr>
<br>

## 표현 영역과 응용 영역
#### 두 영역의 분리된 역할로 사용자의 요청에 올바른 기능 수행 및 결과값 리턴

<br>

### 표현 영역 
* URL, 요청 파라미터, 쿠키, 헤더 등 사용자가 원하는 기능을 판별
* 웹 브라우저를 사용하는지, REST API를 사용하는지, TCP 소캣을 사용하는지 등에 따라 다양한 형태의 요청 처리
  * HTML 혹은 JSON 리턴

<br>

### 응용 영역
* 사용자의 요청에을 위한 기능을 제공하는 주체


<br>
<hr>
<br>

## 응용 서비스의 역할
#### 사용자의 요청을 처리하기 위해 리포지터리에서 도메인 객체를 가져와 사용

<br>

### 응용서비스의 로직은 간단해야 한다
* 복잡하면 도메인의 기능을 수행하고 있을 수도 있다

<br>

### Repository 및 Domain 기능 실행 예시
```java
public Result doSomeFunc(SomeReq req) {
    // 1. Repository에서 Aggregate를 구한다
    SomeAgg agg = someAggRepository.findById(req.getId());
    checkNull(agg);
    
    // 2. Aggregate의 Domain 기능 실행
    agg.doFunc(req.getValue());
    
    // 3. 결과를 리턴한다
    return createSuccessResult(agg);
}
```

<br>

### Validate 및 새로운 Aggregate 생성 예시
```java
public Result doSomeCreation(CreateSomeReq req) {
    // 1. 데이터 중복 등 데이터가 유효한지 검사한다
    validate(req);
    
    // 2. Aggregate 생성한다
    SomeAgg agg = createSome(req);
    
    // 3. Repository에 Aggregate 저장한다
    someAggRepository.save(newAgg);
    
    // 4. 결과를 리턴한다
    return createSuccessResult(newAgg);
}
```

<br>

### Transaction 처리 예시
```java
public void blockMembers(String[] blockingIds) {
    if (blockingIds == null || blockingIds.length == 0) return;
    List<Member> members = memberRepository.findByIdIn(blockingIds);
    
    for (Member mem: members) {
        mem.block();
    }
}
```
* 몇몇의 `mem`만 `block` 상태처리면 안되기 때문

<br>

### 도메인 로직 넣지 않기
```java
public class ChangePasswordService {
    
    public void changePassword(String memberId, String oldPw, String newPw) {
        Member member = memberRepository.findById(memberId);
        checkMemberExists(member);
        member.changePassword(oldPw, newPw);
    }
}
```

```java
public class Member {

    public void changePassword(String oldPw, String newPw) {
        if (!matchPassword(oldPw) ) throw new BadPasswordException();
        setPassword(newPw);
    }
    
    // 현재 암호와 일치하는지 검사하는 도메인 로직
    public boolean matchPassword(String pwd) {
        return passwordEncoder.matches(pwd);
    }
    
    private void setPassword(String newPw) {
        if ( isEmpty(newPw) ) throw new IllegalArgumentException("no new password");
        
        this.pasword = newPw;
    }
}
```

<br>
<hr>
<br>

## 응용 서비스의 구현
#### 디자인 패턴의 facade 역할 수행

<br>

### 응용 서비스의 크기
```java
public class MemberService {

    //각 기능을 구현하는 데 필요한 리포지터리, 도메인 서비스 필드 추가
    private MemberRepository memberRepository;
    
    public void join(MemberJoinRequeset joinRequest) {...}
    public void changePassword(String memberId, String curPw, String newPw) {...}
    public void initializePassword(String memberId) {...}
    public void leave(String memberId, String curPw) {...}
}
```
* 기능 별로 작게 나누면 동일 로직에 대한 코드 중복 제거 가능

<br>

```java
public class MemberService {

    private MemberRepository memberRepository;
    private Notifier notifier;

    public void changePassword(String memberId, String curPw, String newPw) {
        Member member = findExistingMember(memberId);
        member.changePassword(currentPw, newPw);
    }
    
    public void initializePassword(String memberId) {
        Member member = findExistingMember(memberId);
        String newPassword = member.initializePassword();
        
        notifier.notifyNewPassword(member, newPassword);
    }
    
    public void leave(String memberId, String curPw) {
        Member member = findExistingMember(memberId);
        member.leave();
    }
    
    private Member findExistingMember(String memberId) {
        Member member = memberRepository.findById(memberId);
        if (member == null)
            throw new NoMemberException(memberId);
        
        return member;
    }
}
```
* 중복 기능은 private 메소드로 빼서 각 public 메소드에서 호출되도록 한다

<br>

### 복잡하지 않게 사용자의 요구에 맞춘 기능으로


<br>
<hr>
<br>
