# 애그리거트
> 
* 

<hr>
<br>

## 애그리거트
#### 관련된 객체를 하나의 군으로...

<br>

### 애그리거트
* 관련된 객체를 하나의 군으로 묶어 줌
  * 같거나 비슷한 라이프싸이클을 갖는다 (ex : Order-OrderLine)
  * 별도의 라이프싸이클을 갖는 관계에서는 서로 다른 애그리거트가 된다 (ex : 상품-리뷰)
* 상위 수준에서 도메인 모델 간의 관계 파악 가능! 작은 그림만 파악해서는 요구사항에 대해서 코드 수정을 최소한으로 하는 협의로만 갈 수밖에 없음!
* 애그리거트의 경계 설정의 기본
  * `도메인 규칙`
  * `요구사항`
* Example
```markdown
- 주문
  ⌞ Order
  ⌞ Orderer
  ⌞ Shipping Info
  ⌞ Receiver
  ⌞ Address
  ⌞ Delivery Tracking 
  ⌞ OrderLine 
- 결제
  ⌞ Payment Info
- 분류
  ⌞ Category
- 상품
  ⌞ Product
- 리뷰
  ⌞ Review
- 회원
  ⌞ Member
  ⌞ Member Grade
```
* 주문 (Order)가 좋은 예시인데, `함께 생성`되고 `함께 변경`되면 같은 애그리거트에 속할 확률이 높다
  * `Order`와 `OrderLine`의 관계처럼
  * `Order`와 `Orderer 및 ShippingInfo`의 관계처럼
* 상품 (Product)와 리뷰 (Review)는 다른 애그리거트

<br>

## 애그리거트 루트
#### 래그리거트 전체를 관리할 주체

<br>

### 애그리거트 루트
* `주문 애그리거트` 구성 엔티티
  * 총 금액인 totalAmounts를 갖고 있는 Order 엔티티
  * 개별 구매 상품의 개수인 quantity와 금액인 price를 갖고 있는 OrderLine 밸류
* `도메인 규칙`
  * $주문 총 금액 = 개별 상품의 주문 개수 \times 가격의 합$
* 애그리거트 루트
  * 래그리거트 전체를 관리할 주체로, 애그리거트에 속한 모든 객체가 정상 상태임을 관리

<br>

### 도메인 규칙과 일관성
* 주문 애그리거트는 `배송지 변경`, `상품 변경` 등의 기능을 제공
  * 애그리거트 루트인 `Order`가 기능을 구현한 메소드 제공

```java
public class Order {
    
    private ShippingInfo shippingInfo;
    
    // 애그리거트 루트는 도메인 규칙을 구현한 기능을 제공
    public void changeShippingInfo(ShippingInfo newShippingInfo) {
        verifyNotYetShipped();
        setShippingInfo(newShippingInfo);
    }
    
    private void verifyNotYetSipped() {
        if (state != OrderState.PAYMENT_WAITING && state != OrderState.PREPARING)
            throw new IllegalStateEception("already shipped");
    }
    
}
```
* 배송지 변경 기능의 도메인 규칙
  * `배송이 시작되기 전까지만 배송지 정보를 변경할 수 있다`

```java

```
* 애그리거트 외부에서 애그리거트에 속한 객체를 직접 변경하면 안 된다
* 따라서, 애그리거트 루트를 통해서만 도메인 로직을 구현
  * 단순히 필드를 변경하는 set 메소드를 공개(public) 범위로 만들지 않는다
  * 밸류 타입은 불변으로 구현한다

<br>

### 애그리거트 루트와 역할
* 애그리거트 루트는 애그리거트 내부의 다른 객체를 조합해서 기능 완성

<br>

### 애그리거트 루트와 역할 Example (1) GOOD 👍
```java
public class Order {
    private Money totalAmounts;
    private List<OrderLine> orderLines;
    
    private void calculateTotalAmounts() {
        int sum = orderLines.stream()
                            .mapToInt(ol -> ol.getPrice() * ol.getQuantity())
                            .sum();
                            
        this.totalAmounts = new Money(sum);
    }
}
```

```java
public class Member {
    private Password password;
    
    public void changePassword(String currentPassword, String newPassword) {
        if (!password.match(currentPassword) {
            throw new PAsswordNotMatchException();
        }
    }
    this.password = new Password(newPassword);
}
```

### 애그리거트 루트와 역할 Example (2) GOOD 👍
```java
public class OrderLine {
    private List<OrderLine> lines;
    
    public Money getTotalAmounts() {
        // 구현
    }
    
    public void changeOrderLines(List<OrderLine> newLines) {
        this.lines = newLines;
    }
}
```

```java
public class Order { 
    private Money totalAmounts;
    private OrderLines orderLines;
    
    public void changeOrderLines(List<OrderLine> newLines) {
        orderLines.changeOrderLines(newLines);
        this.totalAmounts = orderLines.getTotalAmounts();
    }
}
```

### 애그리거트 루트와 역할 Example (3) BAD 👎
```java
OrderLines lines = order.getOrderLines();
lines.changeOrderLines(newOrderLines);
```
* 주문의 OrderLine이 바뀌는데 총합은 계산하지 않는 버그를 야기
* 해결안) 외부에서 OrderLine 목록을 변경하지 못하도록 함
  * 패키지나 protected 범위 사용

<br>

### 애그리거트와 리포지토리

<br>

### ID를 이용한 애그리거트 참조

<br>
<hr>
<br>
