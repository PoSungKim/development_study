# 리포지터리와 모델 구현
> 
* 

<hr>
<br>

## JPA를 이용한 리포지터리 구현
#### 애그리거트를 어떤 저장소에 저장하느냐에 따라 리포지터리를 구현하는 방법이 다르며, 현 책에서는 JPA 사용

<br>

### 모듈 위치
* Domain Layer
  * Model
  * `<<interface>>` ModelRepository
* Infra Layer
  * JpaModelRepository

<br>

### 리포지터리 기본 기능 구현
* 기본 제공 기능
  * ID로 애그리거트 조회하기
  * 애그리거트 저장하기 

```java
public interface OrderRepository {
    Order findById(OrderNo no);
    void  save(Order order);
}
```
* `Order findById(OrderNo no);`
  * 있으면, Order; otherwise, null;
* `Optional<Order> findById(OrderNo no);`
  * 있으면, Order; otherwise, `정의한 특정 객체`;

<br>

### JPA와 스프링을 이용한 리포지토리 구현
```java
@Repository
public class JpaOrderRepository implements OrderRepository {
    
    @PersistenceContext
    private EntityManager entityManager;
    
    @Override
    public Order findById(OrderNo id) {
        return entityManager.find(Order.class, id);
    }
    
    @Override
    public void save(Order order) {
        entityManager.persist(order);
    }
}
```
* @PersistenceContext
  * 영속성 컨텍스트를 주입하는 표준 애노테이션
    * @Autowired가 스프링에서 제공하는 기능
    * @PersistenceContext는 JPA 스펙에서 제공하는 기능
* 스프링 데이터 JPA를 사용하면 EntityManager를 통한 직접 구현이 필요없긴 하다
  * 자동으로 해주니까

```java
public class ChangeOrderService {

    @Transactional
    public void changeShippingInfo(OrderNo no, ShippingInfo newShippingInfo) {
        Optional<Order> orderOpt = orderRepository.findById(no);
        Order order = orderOpt.orElseThrow( () -> new OrderNotFoundException() );
        order.changeShippingInfo(newShippingInfo);
    }
}
```

<br>

```java
public interface OrderRepository {
    List<Order> findByOrdererId(String ordererId, int startRow, int size);
}
```

<br>

### JPQL을 이용한 findByOrdererId 메서드 구현

```java
@Override
public List<Order> findByOrdererId(String ordererId, int startRow, int fetchSize) {
    TypedQuery<Order> query = entityManager.createQuery(
        "select o from Order o " +
            "where o.orderer.memberId.id = :ordererId " +
            "order by o.number.number desc ",
        Order.class);
    
    query.setParameter("ordererId", ordererId);
    query.setFirstResult(startRow);
    query.setMaxResults(fetchSize);
    
    return query.getResultList();
    );
}
```

<br>

```java
public interface OrderRepository {
    public void delete(Order order);
}
```

<br>

### JPA를 이용한 리포지터리 삭제 기능 구현
```java
public class JpaOrderRepository implements OrderRepository {
    
    @PersistenceContext
    private EntityManager entityManager;
    
    @Override
    public void delete(Order order) {
        entityManager.remove(order);
    }
}
```
* 삭제 기능
  * 실제로 삭제하기 보다는 원복 등의 이유로 인해 flag 값을 넣어서 변경하는 형태로 많이 `삭제 처리`를 많이 한다

<br>
<hr>
<br>

## 스프링 데이터 JPA를 이용한 리포지터리 구현
#### Spring + JPA = Spring Data JPA, 즉 규칙에 맞게 Repository Interface를 정의하면 구현체를 알아서 Bean으로 등록해줌

<br>

### Repository Interface 정의 규칙
* org.springframework.data.repository.Repository<T, ID> 인터페이스 상속
* T는 엔티티 타입을 지정하고 ID는 식별자 타입을 지정

```java
@Entity
@Table(name = "purchase_order")
@Access(AccessType.FIELD)
public class Order {
    @EmbeddedId
    private OrderNo number; // OrderNo가 식별자 타입
}
```

```java
public interface OrderRepository extends Repository<Order, OrderNo> {
    Optional<Order> findById(OrderNo id);
    
    void save(Order order);
}
```

```java
@Service
public class CancelOrderService {
    private OrderRepository orderRepository;
    
    public CancelOrderService(OrderRepository orderRepository, ...) {
        this.orderRepository = orderRepository;
    }
    
    @Transactional
    public void cancel(OrderNo orderNo, Canceller canceller) {
        Order order = orderRepository.findById(orderNo);
                                     .orElseThrow( () -> new NoOrderException() );
        if ( !cancelPolicy.hasCancellationPermission(order, canceller) ) {
            throw new NoCancellablePermission();
        }
        
        order.cancel();
        
    }
}
```

<br>

### save()
```java
Order save(Order entity)
void  save(Order entity)
```

<br>

### findById()
```java
Order           findById(OrderNo id)
Optional<Order> findById(OrderNo id)
```

<br>

### findBy프로퍼티이름(프로퍼티 값)
```java
List<Order> findByOrderer(Orderer orderer)
```

<br>

### findBy중첩프로퍼티이름(프로퍼티 값)
```java
List<Order> findByOrdererMemberId(MemberId memberId)
```
* Orderer 객체의 memberId 프로퍼티

<br>

### delete()
```java
void delete(Order order)
void deleteById(OrderNo id)
```
* 식별자로 삭제

<br>
<hr>
<br>

## 엔티티와 밸류 매핑
#### 

<br>

### 

<br>
<hr>
<br>

## 매핑 구현 
#### 밸류 컬렉션 매핑

<br>

### 엔티티와 밸류 기본 매핑 구현
* 기본 규칙
  * Aggregate => 엔티티 => @Entity
  * Value => @Embeddable
  * Value 타입 Property => @Embedded
* Example
  * Root Entity = Order
  * Value = {Orderer, ShippingInfo}

<div align="center">
    <img width="80%" alt="스크린샷 2022-10-05 오전 10 42 45" src="https://user-images.githubusercontent.com/37537227/193961346-1b2b2d8f-3cf3-4341-a5ea-5cff648536e0.png">
</div>

```java
@Entity
@Table(name = "purchase_order")
public class Order {
    ...
}
```
* `Order` --> `Root Entity` of 주문 Aggregate --> `@Entity`

```java
@Embeddable
public class Orderer {

    // MemberId에 정의된 칼럼 이름을 변경하기 위해 @AttributeOverride 애너테이션 사용
    @Embedded
    @AttributeOverrides(
        @AtttributeOverride( name = "id", column = @Column(name = "orderer_id") )
    )
    private MemberId memberId;
    
    @Column(name = "orderer_name")
    private String name;
}
```
* Order에 속하는 `Orderer`는 `Value` --> `@Embeddable`
* `memberId`는 Member Aggregate를 ID로 참조

```java
@Embeddable
public class MemberId implements Serializable {
    @Column(name = "member_id")
    private String id;
}
```
* 테이블 칼럼 이름으로 `member_id` 지정
* `@AtttributeOverride( name = "id", column = @Column(name = "orderer_id") )`
  * Orderer의 memberId 프로퍼티와 매핑되는 칼럼 이름은 `orderer_id`이므로 MemberId에 설정된 `member_id`와 이름이 다르다.
  * @Embeddable 타입에 설정한 칼럼 이름과 실제 칼럼 이름이 다르므로 @AttributeOverrides 애너테이션을 이용해서 Orderer의 memberId 프로퍼티와 매핑할 칼럼 이름을 변경

```java
@Embeddable
public class ShippingInfo {
    @Embedded
    @AttributeOverrides({
        @AttributeOverride( name   = "zipCode",
                            column = @Column( name = "shipping_zipcode" ) ),
        @AttributeOverride( name   = "address1",
                            column = @Column( name = "shipping_addr1" ) ),  
        @AttributeOverride( name   = "address2",
                            column = @Column( name = "shipping_addr2" ) ),
                            
    })
    private Address address;
    
    @Column(name = "shipping_message")
    private String message;
    
    @Embedded
    private Receiver receiver;
}
```
* 테이블 칼럼 이름 매핑

```java
@Entity
public class Order {
    ...
    @Embedded
    private Orderer orderer;
    
    @Embedded
    private ShippingInfo shippingInfo;
    ...
}
```
* Root Entity Order에 @Embedded로 Value 타입 Property 설정

<br>

### 기본 생성자
```java
public class Receiver {
    private String name;
    private String phone;
    
    protected Receiver() {} // JPA 적용을 위한 기본생성자 
    
    public Receiver(String name, String phone) {
        this.anme  = name;
        this.phone = phone;
    }
    
}
```
* 불편 타입임을 약속했기 때문에, Setter 필요 X
* `@Entity`, `@Embeddable`를 통한 클래스 매핑을 위해서는 기본 생성자 제공 필요
* JPA는 필드 접근 방식 및 메서드 접근 방식 사용
  * 필드 접근 방식 : @Access(AccessType.FIELD)
  * 메서드 접근 방식 : @Access(AccessType.PROPERTY)
* JPA 구현체인 Hibernate는 @Access의 명시적 접근 방식이 지정되어 있지 않으면, @Id, @EmbeddedId의 위치 (필드, 메소드)를 본다
* @Enumerated 
  * EnumType.ORDINAL : 순서값 
  * EnumType.STRING  : String값

<br>

### JPA의 필드 접근 방식 사용
```java
@Entity
@Access(AccessType.PROPERTY)
public class Order {
    
    @Column(name = "state')
    @Enumerated(EnumType.STRING)
    public OrderState getState() {
        return state;
    }
    
    public void setState(OrderState state) {
        this.state = state;
    }
}
```

```java
@Entity
@Access(AccessType.FIELD)
public class Order {
    
    @EmbeddedId
    private OrderNo number;
    
    @Column(name = "state')
    @Enumerated(EnumType.STRING)
    private OrderState state;
    
}
```

<br>

### AttributeConverter를 이용한 밸류 매핑 처리
```java
public class Length {
    private int value;
    private String unit;
}
```
* 객체 Property 2개 --> 테이블 칼럼 1개 매핑
  * value와 unit --> width VARCHAR(20)

```java
public interface AttributeConverter<X, Y> {
    public Y convertToDatabaseColumn (X attribute);
    public X convertToEntityAttribute (Y dbData);
}
```
* X : 밸류 타입 
* Y : DB 타입

<br>

### @Converter(autoApply = true) 케이스

```java
@Converter(autoApply = true)
public class MoneyConverter implements AttributeConverter<Money, Integer> {
    
    @Override
    public Integer convertToDatabaseColumn(Money money) {
        return moeny == null ? null : money.getValue();
    }
    
    @Override
    public Money convertToEntityAttribute(Integer value) {
        return value == null ? null : new Money(value);
    }
}
```

```java
@Entity
@Table(name = "purchase_order")
public class Order {

    ...
    @Column(name = "total_amounts")
    private Money totalAmounts; // MoneyConverter를 적용해서 값 변환
}
```

<br>

### @Converter(autoApply = false) 케이스

```java
@Entity
@Table(name = "purchase_order")
public class Order {

    @Column(name = "total_amounts")
    @Convert(converter = MoneyConverter.class)
    private Money totalAmounts; // MoneyConverter를 적용해서 값 변환
}
```
* autoApply = false가 default 값
  * `@Convert(converter = MoneyConverter.class)` 명시해줘야 함

<br>

### 밸류 컬렉션 --> 별도 테이블 매핑

<div align="center">
    <img width="50%" src="https://user-images.githubusercontent.com/37537227/194015514-732a96c4-b574-4d72-98b7-04bea6543fe0.png">
</div>

```java
public class Order {
    private List<OrderLine> orderLines;
    ...
}
```

```java
@Entity
@Table(name = "purchase_order")
public class Order {
    
    @EmbeddedId
    private OrderNo number;
    
    @ElementCollection(fetch = FetchType.EAGER)
    @CollectionTable( name = "order_line",
                      joinColumns = @JoinColumn(name = "order_number") )
    @OrderColumn(name = "line_idx")
    private List<OrderLine> orderLines;
}

@Embeddable
public class OrderLine {
    @Embedded
    private ProductId productId;
    
    @Column( name = "price" )
    private Money price;
    
    @Column( name = "quantity" )
    private int quantity;
    
    @Column( name = "amounts" )
    private Money amounts;
    
}
```
* 밸류 컬렉션을 별도 테이블로 매핑할 때
  *  `@ElementCollection` : 콜랙션 객체 저장
  *  `@CollectionTable`   : 저장할 테이블 지정
    *  name : 테이블명
    *  joinColumns : 외부키로 사용할 칼럼 지정
* ORDER_LINE 테이블의 인덱스 값 저장을 위한 `@OrderColumn`

<br>
<hr>
<br>

## 애그리거트 로딩 전략과 영속성 전파
#### 

<br>

### 

<br>
<hr>
<br>

## 식별자 생성 기능
#### 

<br>

### 
