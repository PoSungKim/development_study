# 주요 개념 
> 국가 표준프레임워크

* 방대한 기능이 제공되며, 그만큼 안정적이기 때문에, 배우는 것이 필수
* ORM vs SQL Mapper, JPA [Hibernate] vs MyBatis, JPA [Hibernate], (dto, vo) vs MyBatis (DAO), oom vs erd

<hr>
<br>

## 1. Spring Framework

#### [공식 홈페이지](https://spring.io/projects/spring-framework)

<div align="center">
    <img width="456" alt="스크린샷 2021-05-01 오후 9 44 48" src="https://user-images.githubusercontent.com/37537227/116782850-78b05280-aac6-11eb-90a9-9b6cab7db8e9.png">
</div>

<br>

```bash
총 20개의 구성 : Spring Boot, Spring Cloud, Spring Data, Spring Batch, Spring Security
스프링의 핵심 기능 : DI, AOP, ... etc
```

* Spring 1.0 버전이 2004년 3월에 출시된 이후로, JAVA Enterprise Application 개발 프레임워크에서 1위를 계속해서 유지 중
* ```테스트의 용이성```, ```느슨한 결합```에 집중

<br>
<hr>
<br>

## 2. DI - Dependency Injection

#### 객체와 객체가 의존하는 상태일 때, 외부에서 주입하는 방식을 통해서 추상화를 진행하고, 순환참조를 막고, Mock을 통한 안정적인 테스팅이 가능하다

```java
IEncoder encoder = new Base64Encoder();
String result = encoder.encode(url);

IEncoder urlEncoder = new UrlEncoder();
String urlResult = urlEncoder.encode(url);
```

* DI를 사용하지 않는 방식은 비효율성을 보여준다

<br>

### [<프로젝트명>Application.java]
``` java
Encoder encoder = new Encoder(new Base64Encoder());
//Encoder encoder = new Encoder(new UrlEncoder());

encoder.encode(url);
```
* ```IEncoder``` : Interface
* ```Base64Encoder```와 ```UrlEncoder```는 ```IEncoder``` Interface를 extend하고 있는 상태
* ```Encoder``` Class 내부에서 ```IEncoder``` Interface를 정의해서 해당 Interface와 관계를 맺고 있는 다수의 클래스를 주입 받을 수 있다 (함수의 parameter 형식으로)
* DI를 사용하면, ```IEncoder``` Interface를 ```Encoder``` Class안에 정의하여, ```new Base64Encoder()```와 ```new UrlEncoder()```를 주입하는 형식을 통해 효율적인 코드 생성이 가능하다

### [Encoder.java]

```java
public class Encoder {
	private IEncoder iEncoder;
	
	public Encoder(IEncoder iEncoder) {
		this.iEncoder = iEncoder;
	}
	
	public void setIEncoder(IEncoder iEncoder) {
		this.iEncoder = iEncoder;
	}
	
	public String encode(String message) {
		return iEncdoer.encode(message);	
	}
}
```
* 

<br>
<hr>
<br>

## 3. IoC - Inversion of Control
#### 스프링에서는 new로 Java 객체를 생성하여 개발자가 관리하는 방식이 아니라, ```Spring Container```에서 일반적인 Java 객체를 싱글톤 형태로 관리한다
#### 즉, ```객체 관리에 대한 권한```이 ```개발자에서 프레임워크로``` 옮겨졌기 때문에 Inversion of Control, 제어의 역전이 발생한다

<br>

### [3.11 Base64Encoder.java | Base64Encoder와 UrlEncoder만 ```@Component``` 해준 상태]
```java
@Component("anotherNameForBase65Encoder")
public class Base64Encoder implements IEncoder {
    ...
}
```
* ```@Component``` Annotation을 Class 위에 작성해주면, 해당 Class가 Bean으로 등록이 되고, ```@SpringBootApplication``` 옆 돋보기 아이콘을 눌러보면 확인가능하다
    * 즉, 이는 ```이 Class는 Spring에서 관리를 해줘! Spring에서 Class를 Bean으로 만들어서 너가 관리해!```라는 메세지가 담겨있다
    * Spring은 ```싱글톤 방식```으로 Bean들을 관리하게 된다
* @Component(```"<다른 이름>"```) : ```@Qualifier```에서 참조할 수 있는 이름을 지정해놓을 수 있다
	* 보통 ```Base64Encoder``` Class명은 ```base64Encoder```로 첫 알파벳이 소문자로 변환되는데,
	* 아예 다른 이름으로 바꾸고 싶다면, @Component(```"<다른 이름>"```) 방식으로 parameter 값으로 넣어주면 된다

<br>

### [3.12 ApplicationContextProvider.java | Base64Encoder와 UrlEncoder만 ```@Component``` 해준 상태]
```java
import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.stereotype.Component;


@Component
public class ApplicationContextProvider implements ApplicationContextAware {
	
	private static ApplicationContext context;
	
	@Override
	public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
		context = applicationContext;
	}
	
	public static ApplicationContext getContext() {
		return context;
	}
}
```
* ```Spring Container```에 직접 접근해서 객체 (Bean)을 가져오기 위해서 ```Spring Application Context```가 필요하다
* ```setApplicationContext()```에서 ```ApplicationContext applicationContext```를 주입받는데, Spring이 자동으로 주입해주는 부분이다
* 주입된 ```ApplicationContext applicationContext```를 ```private static ApplicationContext context```로 받아준다
	* ```static```으로 정의가 되어 있기 때문에, ```this```는 필요없다

<br>

### [3.13 <프로젝트명>Application.java | Base64Encoder와 UrlEncoder만 ```@Component``` 해준 상태]
```java
@SpringBootApplication

public class Application {
	public static void main(String[] args) {
		SpringApplication.run(Application.class, args);
		ApplicationContext context = ApplicationContextProvider.getContext();
		
		Base64Encoder base64Encoder = context.getBean(Base64Encoder.class);
		UrlEncoder urlEncoder = context.getBean(UrlEncoder.class);
		
		Encoder encoder = new Encoder(base64Encoder);
		String url = "<URL>"
		
		String result = encoder.encode(url);
		System.out.println(result);
		
		encoder.setIEncoder(urlEncoder);
		result = encoder.encode(url);
		System.out.println(result);
	}
}
```
* ```@Component```를 선언해주면, ```ApplicationContext```를 사용하여 new를 사용하지 않고, ```context.getBean()```함수로 ```Spring Container```에 있는 해당 객체를 ```Bean```으로 사용할 수 있다
    * ```Spring```이 객체를 개발자 대신에 관리해주기 시작하는 순간

<br>


### [3.21 Encoder.java | Encoder도  ```@Component``` 해준 상태]
```java
@Component
public class Encoder {
	private IEncoder iEncoder;
	
	public Encoder(@Qualifier("base64Encoder") IEncoder iEncoder) {
		this.iEncoder = iEncoder;
	}
	
	public void setIEncoder(IEncoder iEncoder) {
		this.iEncoder = iEncoder;
	}
	
	public String encode(String message) {
		return iEncdoer.encode(message);	
	}
}
```
* @Component는 ```IEncoder``` Interface를 사용하는 ```Encoder``` Class에도 선언할 수 있고, 이는 보다 IoC 개념을 확장시킨다

<br>

### [3.22 <프로젝트명>Application.java | Encoder도  ```@Component``` 해준 상태]
```java
@SpringBootApplication

public class Application {
	public static void main(String[] args) {
		SpringApplication.run(Application.class, args);
		ApplicationContext context = ApplicationContextProvider.getContext();
		
		Encoder encoder = context.getBean(Encoder.class);
		String url = "<URL>"
		
		String result = encoder.encode(url);
		System.out.println(result);
	}
}
```
* 이로서 ```new ``` 선언이 모두 사라지고, 모든 ```객체 관리 권한```은 Spring에게 넘어갔다 --> ```Inversion of Control```
	* Spring Container에서 관리되는 모든 객체 --> ```Bean``` 

<br>

### [3.31 <프로젝트명>Application.java | 다수의 Encoder Class를 사용하고자 할 때]

```java
@Configuration 
class Appconfig = {
    @Bean("base64Encoder")
    public Encoder encoder (Base64Encoder base64Encoder) { 
        return new Encoder(base64Encoder);
    } 
    
    @Bean("urlEncoder")
    public Encoder encoder (UrlEncoder urlEncoder) { 
        return new Encoder(urlEncoder);
    } 
}
```

<br>

### [3.32 <프로젝트명>Application.java | 다수의 Encoder Class를 사용하고자 할 때]

```java
@SpringBootApplication

public class Application {
	public static void main(String[] args) {
		SpringApplication.run(Application.class, args);
		ApplicationContext context = ApplicationContextProvider.getContext();
		
		Encoder encoder = context.getBean("urlEncoder", Encoder.class);
		String url = "<URL>"
		
		String result = encoder.encode(url);
		System.out.println(result);
	}
}
```
* ```context.getBean("urlEncoder", Encoder.class);``` 부분에서 첫 번째 Parameter 값을 바꾸면서 사용한다
    * ```ApplicationContext```를 통한 IoC는 이해를 돕기 위한 예시이고, 실제 프로젝트에서는 ```Set Method```나 ```변수에 @Autowired``` 등을 사용한다고 한다

<br>
<hr>
<br>

## 4. AOP (Aspect Oriented Programming)

#### ```관점지향``` 프로그래밍 - Spring ```MVC 웹 어플리케이션```은 대부분 ```Web Layer```, ```Business Layer```, ```Data Layer```로 구성

### [AOP - 기본 Layer 구성, 각 Layer가 하나의 주요 기능에 집중할 수 있도록]
```java
Web Layer: REST API를 제공하며, Client 중심의 로직 적용
Business Layer: 내부 정책에 따른 Logic을 개발하며, 주로 해당 부분 개발
Data Layer: 데이터베이스 및 외부와의 연동을 처리
```

<br>

### [주요 AOP @Annotation]
```java
@Aspect : 자바에서 널리 사용하는 AOP 프레임워크에 포함되며, AOP를 정의하는 Class에 할당
@Pointcut : 기능을 어디에 적용시킬지, 메소드, @ 등 AOP를 적용 시킬 지점을 설정
@Before : 메소드를 실행하기 이전
@After : 메소드가 성공적으로 실행 후, 예외가 발생 되더라도 실행
@AfterReturing : 메소드 호출 성공 실행 시 (Not Throws)
@AfterThrowing : 메소드 호출 실패 예외 발생 (Throws)
@Around : Before/After 모두 제어
```
* DI를 사용하지 않는 방식은 비효율성을 보여준다

<br>

### [build.gradle]
``` groovy
dependencies {
	implementation 'org.springframework.boot:spring-boot-starter-aop' // 추가 필요
}
```

<br>

### [ParameterAop.java]
```java
@Aspect
@Component
public class ParameterAop {

    @Pointcut("execution(* com.pfm.Spring_Backend.controller..*.*(..))")
    private void cut() {
    }

    @Before("cut()")
    private void before(JoinPoint joinPoint) {

        MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature();
        Method method = methodSignature.getMethod();
        System.out.println(method);

        Object[] args = joinPoint.getArgs();

        for (Object obj : args) {
            System.out.println("type : " + obj.getClass().getSimpleName());
            System.out.println("value : " + obj);
        }
    }

    @AfterReturning(value = "cut()", returning = "returnObj")
    private void AfterReturn(JoinPoint jointPoint, Object returnObj) {
        System.out.println("return obj");
        System.out.println(returnObj);
    }
}
```

<br>

### [Terminal - Log 결과창]
```bash
public com.pfm.Spring_Backend.controller.Hello com.pfm.Spring_Backend.controller.HelloController.getHello(int)
type : Integer
value : 1
return obj
<201 CREATED Created,com.pfm.Spring_Backend.controller.Hello@35c3cde7,[]>

public org.springframework.http.ResponseEntity com.pfm.Spring_Backend.controller.HelloController.putHello(com.pfm.Spring_Backend.dto.InputDto,int)
type : InputDto
value : InputDto(value=value, value2=value2)
return obj
com.pfm.Spring_Backend.controller.Hello@4087d030
```
* AOP로 시점들을 나누어서, 비즈니스 로직을 작성하는 곳은 비즈니스 로직에만 집중할 수 있게 하고, Log를 다른 곳에서 집중할 수 있게 해주는 용도로 잘 쓰이는 것 같다
* 또한, ```@Before```와 ```@AfterReturning```을 통해서, 선 처리 후 처리 등을 해줄 수도 있다 (예시: 암호화)

<br>
<hr>
<br>

## 5. @Annotation 정리

#### REST + ORM + AOP

```java
@SpringBootApplication : spring boot application으로 설정 

@Controller : View를 제공하는 controller로 설정
@RestController : REST API를 제공하는 controller로 설정
@RequestMapping : URL 주소를 맵핑
@GetMapping : Http GetMethod URL 주소 맵핑
@PostMapping : Http PostMethod URL 매핑
@PutMapping : Http PutMethod URL 주소 맵핑
@RequestParam : URL Query Parameter 맵핑

@Valid : POJO Java Class의 검증
@Configuration : 1개 이상의 bean을 등록 할 때 설정
@Component : 1개의 Class 단위로 등록 할 때 사용
@Bean : 1개의 외부 Library로부터 생성한 객체를 등록 시 사용
@Autowired : DI를 위한 곳에 사용
@Qualifier : @Autowired 사용시 bean이 2개 이상 일때 명시적 사용
@Resource : @Autowired + @Qualifier의 개념으로 이해

@Aspect : AOP 적용시 사용
@Before : AOP 메소드 이전 호출 지정
@After : AOP 메소드 호출 이후 지정 예외 발생 포함
@Around : AOP 이전/이후 모두 포함 예외 발생 포함
@AfterReturning : AOP 메소드의 호출이 정상일 때 실행
@AfterThrowing : AOP시 해당 메소드가 예외 발생시 지정
```

<br>
<hr>
<br>

## 6. ORM (Object-Relational Mapping)

#### [참고 자료](https://victorydntmd.tistory.com/m/195)

<div align="center">
    <img width="1179" alt="스크린샷 2021-05-01 오후 9 00 25" src="https://user-images.githubusercontent.com/37537227/116781790-44399800-aac0-11eb-8f8f-cd97ad963efb.png">
</div>

<br>

``` bash
ORM : 객체와 데이터베이스 간의 관계를 매핑한다는 개념
```
<br>

### [ORM을 구현하는 방법: JPA (Java Persistence API)]

<br>

<div align="center">
	<img height="300" width="330" alt="스크린샷 2021-05-01 오후 9 19 34" src="https://user-images.githubusercontent.com/37537227/116782252-f1adab00-aac2-11eb-802e-c815a02b8e4b.png">
	<img height="300" width="330" alt="스크린샷 2021-05-01 오후 9 21 23" src="https://user-images.githubusercontent.com/37537227/116782307-30dbfc00-aac3-11eb-8d0f-ce94ccfe0221.png">
	<img height="300" width="330" alt="스크린샷 2021-05-01 오후 9 22 50" src="https://user-images.githubusercontent.com/37537227/116782334-64b72180-aac3-11eb-948c-33376088f0e7.png">
</div>

<br>


```bash
JPA : ORM 구현을 위한 기본 인터페이스
Hibernate : 인터페이스를 실제 구현한 클래스들
Spring Data JPA : Hibernate 클래스들 중에서도 자주 사용되는 등의 주요 클래스들
```

<br>

### [Lombok]

``` java
@Getter
@Setter
@ToString
@NoArgsConstructor
@AllArgsConstructor
@RequiredArgsConstructor
@Data
@Builder
@ToString
public class [class명] {
    @NonNull
    private [데이터타입][멤버변수]    
}
```
* Class명 위에서 한 번만 선언하는 방법 (추천)
* ```@ToString```은 모든 Classs는 Object를 상속받는데, toString() 함수의 리턴값이 원하는 방향이랑 다르기 때문에, Spring에서도 공식적으로 Override해서 사용하라고 권고한다.
	* 따라서, 보통 우리가 바라는 결과값, Class 명과 안의 멤버 변수 값이 어떻게 구성되어 있는지 확인하는 toString() 함수로 변환시켜주는 것이 ```@ToString``` annotation이다. 
* ```@Data``` = ```@RequiredArgsConstructor``` +  ```@ToString``` + ```@EqualsAndHashCode``` + ```@Getter``` +  ```@Setter```
* ```@Builder``` : Testing 용도

<br>

``` java
public class [class명] {

    @Getter
    @Setter
    @ToString
    private string name;
}
```
* 멤버 변수마다 선언하는 방법 (비추천)

<br>

### [Terminal - DTO Testing 결과]
```java
public class InputDtoTest {
    @Test
    void test() {
        InputDto inputDto = InputDto.builder().value("testValue").build();

        System.out.println(inputDto.toString());
    }
}
```

<br>

### [H2 DB]

<div align="center">
  <img width="30%" alt="스크린샷 2021-05-08 오후 3 42 56" src="https://user-images.githubusercontent.com/37537227/117529723-13071d80-b014-11eb-88a9-8d3430354007.png">

  <img width="65%" alt="스크린샷 2021-05-08 오후 3 46 43" src="https://user-images.githubusercontent.com/37537227/117529786-9d4f8180-b014-11eb-8658-f9387935677b.png">
</div>

* Java 기반의 In-memory Embedded Memory 관게형 DB
  * ```개발 초기 DB``` 혹은 ```JUnit 테스팅 DB``` 용도로 보통 사용된다
* 메모리에서 실행되기 때문에 애플리케이션 재시작할 때마다 초기화
* ```SQL statement```섹션에서 SQL문을 작성해서 실행하면 된다

<br>

### [JPA]
```java
 * @param <T> the domain type the repository manages
 * @param <ID> the type of the id of the entity the repository manages
 * @author Oliver Gierke
 */
@Indexed
public interface Repository<T, ID> {

}
```
* JpaRepository의 왼쪽 데이터는 ```Domain```, 오른쪽 데이터는 ```id```가 되어야 한다
	* @param <T> the domain type the repository manages
	* @param <ID> the type of the id of the entity the repository manages
* Domain repositories extending this interface can selectively expose CRUD methods by simply declaring methods of the
* same signature as those declared in {@link CrudRepository}.

<br>

### [JPA 제공 메소드]

```java
List<T> findAll();
List<T> findAll(Sort sort);
List<T> findAllById(Iterable<ID> ids);
<S extends T> List<S> saveAll(Iterable<S> entities);
void flush();
<S extends T> S saveAndFlush(S entity);
void deleteInBatch(Iterable<T> entities);
void deleteAllInBatch();
T getOne(ID id);
<S extends T> List<S> findAll(Example<S> example);
<S extends T> List<S> findAll(Example<S> example, Sort sort);
```

* ```JpaRepository```를 ```extends```하는 것이기 때문에, 상속을 받는 것이다
  * 상속받은 메소드를 바로 사용
  * 상속받은 메소드를 Overidding해서 사용
* 바로 사용한다면, 상속 받은 메소드가 무엇이 있는지 알아야 한다
  * Ctrl + click를 통해 확인 가능


<br>
<hr>
<br>

## 7. SQL Mapper - Hibernate (dto, vo) vs MyBatis (DAO), oom vs erd

#### [참고 자료](https://victorydntmd.tistory.com/m/195)

<div align="center">
    <img width="1179" alt="스크린샷 2021-05-01 오후 9 00 25" src="https://user-images.githubusercontent.com/37537227/116781790-44399800-aac0-11eb-8f8f-cd97ad963efb.png">
</div>

* ORM : 객체와 관계형 데이터를 매핑한다는 개념 
    *  개념으로서, 구현하는 방법으로 크게 2가지 방법이 있다 : SQL Mapper와 JPA
    *  MyBatis --> SQL Mapper 
    *  Hibernate --> ORM 


<br>
<hr>
<br>

## 8. REST 

#### (Representational State Transfer : 자원의 상태 전달) - 네트워크 아키텍처

<br>

### [조건1. 자원의 식별 - URI(Uniform Resource Identifier)]
```bash
https://foo.co.kr/user/100

Resource: user
식별자:100
```
* 구분 지을 때 Resource와 Identifier를 사용하고, 모두 URI에 포함되어 있다

<br>

### [조건2. 메세지를 통한 리소스 조작]
```bash
HTML, XML, JSON, TEXT 등의 다양한 데이터가 Web에서 공유된다
```
* HTTP Header 부분에서 content-type을 통해, 데이터 타입을 지정해줄 수 있다
* Packet의 Body 부분에 리소스를 넣을 수 있다

<br>

### [조건3. 자기서술적 메세지]
```bash
HTTP 기반의 REST에서는 HTTP Method와 Header 정보, 그리고 URI의 포함되는 정보로 표현 가능

GET    : https://foo.co.kr/user/100, 사용자의 정보 요청
POST   : https://foo.co.kr/user    , 사용자 정보 생성
PUT    : https://foo.co.kr/user    , 사용자 정보 생성 및 수정
DELETE : https://foo.co.kr/user/100, 사용자의 정보 삭제
```
* HTTP Header 부분에서 content-type을 통해, 데이터 타입을 지정해줄 수 있다
* URI에 모두 못 넣는다면, Packet의 Body 부분에 리소스를 활용할 수 있다

<br>

### [조건4. Application 상태에 대한 엔진으로써 하이퍼미디어]
```bash
Client 요청에 대한 데이터만 응답하는 것이 아니라, 관련 리소스에 대한 Link 정보까지 포함해야 한다
```
* 조건4까지는 잘 안 지켜지고 있다고 한다

<br>
<hr>
<br>

## 9. URI (Uniform Resource Identifier) 

#### URL은 URI의 하위 개념

<br>

### [URI vs URL]
```bash
URI (Uniform Resource Identifier)
인터넷에서 특정 자원을 나타내느 주소 값

https://www.foo.co.kr/resource/sample/1

URL (Uniform Resource Locator)
인터넷 상에서의 자원, 특정 파일이 어디에 위치하는지 식별 하는 주소

https://www.foo.co.kr/foo.pdf

```

<br>

### [URI 설계 원칙]
```bash
1. 슬래시 구분자 (/)는 계층 관계를 나타내는 데 사용한다
2. URI 마지막 문자로 /를 포함하지 않는다
3. 하이픈 (-)은 가독성을 높인다
4. 밑줄 (_)은 사용하지 않는다
5. URI 경로에는 소문자가 적합하다
6. 파일 확장자 (.jsp)는 URI에 포함하지 않는다
7. 프로그래밍 언어에 의존적인 확장자를 사용하지 않는다
8. 구현에 의존적인 경로를 사용하지 않는다 (servlet을 사용했다는 것을 굳이 노출할 필요가 없다)
9. Session ID를 포함하지 
10.프로그래밍 언어의 Method명을 이용하지 않는다
11.명사에 단수형 보다는 복수형을 사용해야 한다. 컬렉션에 대한 표현은 복수로 사용
12.컨트롤러 이름으로는 동사나 동사구를 사용한다
13.경로 부분 중 변하는 부분은 유일한 값으로 대체한다
14.CRUD 기능을 나타내는 것은 URI에 사용하지 않는다
15.URI Query Parameter 디자인 (?key=value)
16.URI Query는 컬렉션의 결과를 페이지로 구분하여 나타내는데 사용한다
17.API에 있어서 서브 도메인은 일관성 있게 사용해야 한다 ([서브 도메인명].foo.co.kr or [서브 도메인명]-foo.co.kr)
18.클라이언트 개발자 포탈 서브 도메인은 일관성 있게 만든다
```
* HTTP Header 부분에서 content-type을 통해, 데이터 타입을 지정해줄 수 있다
* Packet의 Body 부분에 리소스를 넣을 수 있다

<br>
<hr>
<br>

## 10. HTTP (Hyper Text Transfer Protocol)

#### HTML, XML, JSON, Image, Voice, Video, Javascript, PDF 등 다양한 컴퓨터에서 다룰 수 있는 것은 모두 전송할 수 있다
#### TCP를 기반으로 REST의 특징을 모두 구현하고 있는 Web 기반 Protocol이다

<br>

### [HTTP는 Request를 주고 Response를 받는 형태의 통신 방법]

<div align="center">

  ![스크린샷 2021-04-29 오전 12 01 53](https://user-images.githubusercontent.com/37537227/116426498-1d8c1f00-a87e-11eb-81ca-f0da3df73e21.png)

</div>

### [HTTP Status Code]
```bash
1XX : 처리 중 

2XX : 성공 

3XX : 리다이렉트

4XX : 클라이언트 에러

5XX : 서버 에러

```

<br>

### [주요 Code]

```bash
200 : 성공 

201 : 성공. 리소스 생성 성공

301 : 리다이렉트. 리소스가 다른 장소로 변경

303 : 리다이렉트. 클라이언트가 자동으로 새로운 리소스로 요청 처리

400 : 요청 오류. 파라미터 에러

401 : 권한 없음 (인증 실패)

500 : 서버 내부 에러

503 : 서비스 정리 (점검 등등)
```

<br>
<hr>
<br>

## 11. JUnit5 - MVC Test

#### ``` @restcontroller```에  대한 테스팅 진행

<br>


### [build.gradle]

```bash
test {
	useJUnitPlatform()
}
```

* Spring에는 JUnit이 기본적으로 설치되어 있다

<br>

### [JUnit5 - ```@WebMvcTest```]

```java
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;
import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.*;

@WebMvcTest
class HelloControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @Test
    void getHello() throws Exception {
        mockMvc.perform(MockMvcRequestBuilders.get("/api/user/1"))
            .andDo(print())
            .andExpect(status().isOk())
            .andExpect(content().json("{\"value\" : \"Hello User\"}"));
    }

}
```
* Frontend 서버를 직접 구축해서 확인하는 방법도 가능하지만, JUnit을 사용해서 test 디렉토리에서 바로 바로 확인하는 방법도 있다
* ```@WebMvcTest``` : 
* ```@Autowired```  : 
* ```@Test```       : 

<br>

### [Terminal - Testing 결과]

```bash
MockHttpServletRequest:
      HTTP Method = GET
      Request URI = /api/user/1
       Parameters = {}
          Headers = []
             Body = null
    Session Attrs = {}

Handler:
             Type = com.pfm.Spring_Backend.controller.HelloController
           Method = com.pfm.Spring_Backend.controller.HelloController#getHello(int)

Async result = null

Resolved Exception:
             Type = null

ModelAndView:
        View name = null
             View = null
            Model = null

FlashMap:
       Attributes = null

MockHttpServletResponse:
           Status = 200
    Error message = null
          Headers = [Vary:"Origin", "Access-Control-Request-Method", "Access-Control-Request-Headers", Content-Type:"application/json"]
     Content type = application/json
             Body = {"value":"Hello User"}
    Forwarded URL = null
    Redirected URL= null
          Cookies = []
```
* ```HTTP Method```, ```Request URI```, ```status```, ```Headers```, ```Content-type```, ```Body``` 등이 주요 요소들


<br>
<hr>
<br>
