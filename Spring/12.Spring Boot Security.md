# Spring Boot Security
> 인터넷을 통해 모두가 연결되는 세상에서 리소스에 대한 인증/인가는 필수 개념
* [정말좋은영상 - 인증/인가](https://www.youtube.com/watch?v=y0xMXlOAfss)
* [카카오 옥탑방개발자 Gitlab](https://gitlab.com/jongwons.choi/spring-boot-security-lecture/-/tree/master/)

<hr>
<br>

## 기본 개념
#### 어떠한 Flow로 최근에 사용되고 있는 JWT까지 도달했는지에 대한 내용

<br>

### [인증과 인가]
* 인증 (Authentication) : (식별 가능한 정보로) 서비스에 등록된 유저의 신원을 입증하는 과정
  * Username, Password 로그인 인증
    * Session 방식
    * Token 토큰 (Session 방식은 Scale-out시 동기화 문제 발생 가능)
  * 소셜 로그인 인증
    * Google, Naver, ...etc
* 인가 (Authorization) : 인증된 사용자에 대한 자원 접근 권한 확인 
  * Secured (Deprecated)
  * Pre/PostAuthorize
  * AOP

<br>

### [Flow]
* 인증 : Request Header (Basic Token)
* 인증 유지 : Browser (Basic Token)
* 안전한 인증 : Server (Session ID)
* 효율적 인증 : Server (Bearer Token - JWT)
* 채널 인증 : OAuth

<br>

### [Flow 1 : Request Header (인증)]
<div align="center">
   <img width="80%" src="https://user-images.githubusercontent.com/37537227/147868177-87954dd2-64bf-4905-9615-ef488ddc7f00.png">
</div>

* 절차
    * HTTP 통신에서는 Header에 로그인 정보 (`username:password`)가 Base64로 Encoding된 값이 포함되어 전송
* 단점
    * Request Header만 사용하면, 사용자는 매번 로그인 정보를 기입해서 서비스 이용 필요

<br>

### [Flow 2 : Browser (인증 유지)]

<div align="center">
   <img width="80%" src="https://user-images.githubusercontent.com/37537227/147868118-e62e21f5-6b98-48b8-b31c-5085ba24fc80.png">
</div>

* 절차
    * Cookie, LocalStorage, SessionStorage 등에 로그인 정보를 저장하여, Browser가 자동으로 해당 정보를 Request Header에 포함하여 전송
* 장점 
    * 사용자는 매번 자신의 로그인 정보를 기입하지 않아도 됌
* 단점  
    * Browser는 항상 해킹에 취약하기에, 그대로 저장되어 있는 로그인 정보가 쉽게 노출됌

<br>

### [Flow 3 : Server (안전한 인증)]

<div align="center">
   <img width="80%" src="https://user-images.githubusercontent.com/37537227/147868329-7bd4ea03-1201-46a5-bb09-9de2b9fcdc2d.png">
   <img width="80%" src="https://user-images.githubusercontent.com/37537227/147868484-3e8947f6-ead3-433e-9978-ed1f39214595.png">
</div>

* 절차
   * 로그인 정보로 최초 로그인 시, 서버에서 SessionId 값을 클라이언트에게 발급
   * 추후에는 SessionId 값으로 인증 유지
* 장점
   * Raw한 로그인 정보가 아닌, SessionId 값을 사용하기에 해킹의 대상이 로그인 정보가 아닌 SessionId
* 단점
   * 각 서버에서 독자적으로 SessionId을 관리하면, Load Balance시 SessionId값이 매칭이 안되는 문제 발생
   * 모든 서버가 같은 로그인 서버와 연동하여 관리하면, 해당 서버에 과부하 발생하기 쉬움

<br>

### [Flow 4 : JWT Token (효율적 인증)]

<div align="center">
   <img width="80%" src="https://user-images.githubusercontent.com/37537227/147868712-93641ca3-c1b1-4884-81a9-f127dd0b27c4.png">
</div>

* 절차
   * 로그인 정보로 최초 로그인 시, 서버에서 Secret Key를 사용하여 JWT 토큰을 클라이언트에게 발급
* 장점
   * 각 서버가 Secret Key를 사용하여, Load Balance에 상관없이 인증 및 인가 절차 진행 가능
   * 만료기간과 Refresh 토큰 값을 적절히 사용하면 보안 강화 가능
* 단점
   * JWT Decode하기 쉽다

<br>
<hr>
<br>

## CSRF 공격 및 CSRF Token
#### [CSRF 좋은글](https://codevang.tistory.com/282)

<br>

### [공격 방식]
* Post 방식에서는 csrf Filter 발동

<br>
<hr>
<br>

## Spring Boot Security
#### 무수한 Filter들을 지나면서 Authentication과 Authorization 절차를 밟는 것이 주요 개념

<br>

<div align="center">
    <img width="80%" src="https://user-images.githubusercontent.com/37537227/148076463-4b71ed95-58c2-44b8-b8d9-ca59c0878056.png">
</div>

<br>

### [기본 설정 틀 - SecurityConfig.java]
```java
@EnableWebSecurity(debug = true)
public classs SecurityConfig extends WebSecurityConfigurerAdapter {
    
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequest( request -> {
            request.antMatchers("/").permitAll()
                   .anyRequest().authenticated()
                   ;
        });
    }
    
}
```
* @EnableWebSecurity, WebSecurityConfigurerAdapter
    * 무수한 Filter에 대한 설정이 가능한 Class
    * springSecurityFilterChain 등록 

* HttpSecurity
    * http 관련 보안

* .antMatcher()
    * 해당 패턴의 리퀘스트

* .anyRequest()
    * 모든 리퀘스트

<br>

### [Authentication 정보 확인]
```java
public getMyAuthInfo() {
    return SecurityContextHolder.getContext().getAuthentication();
}
```
* SecurityContextHolder
  * Auth 정보를 갖고 있는 객체로 이용자는 자신의 Auth 정보 조회 가능

<br>

### [인증 방법]
* 메모리 사용자 인증
* Basic Token 인증 (+Base64 Encode)
* Bearer Token 인증

<br>
<hr>
<br>

## JWT
#### 

<br>

### [예시]
```java
import io.jsonwebtoken.Jwts;

Jwts.builder()... //
```



