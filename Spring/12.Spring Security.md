# Spring Security
> 인터넷을 통해 모두가 연결되는 세상에서 리소스에 대한 인증/인가는 필수 개념
* [정말좋은영상 - 인증/인가](https://www.youtube.com/watch?v=y0xMXlOAfss)
* [카카오 옥탑방개발자 Gitlab](https://gitlab.com/jongwons.choi/spring-boot-security-lecture/-/tree/master/)

<hr>
<br>

## 기본 개념
#### 어떠한 절차로 사용자가 접속을 했을 때 자신이 인증되고, 어떠한 권한을 부여받아서 사용할 수 있는지에 대한 개념
#### 과거부터 어떠한 히스토리를 통해 현재의 Bearer Token 방식까지 도달했는 지에 대한 개념    

<br>

### [인증과 인가]
* 인증 (Authentication) : (식별 가능한 정보로) 서비스에 등록된 유저의 신원을 입증하는 과정
  * Username, Password 로그인 인증
    * Session 방식
    * Token 토큰 (Session 방식은 Scale-out시 동기화 문제 발생 가능)
  * 소셜 로그인 인증
    * Google, Naver, ...etc
* 인가 (Authorization) : 인증된 사용자에 대한 자원 접근 권한 확인 
  * Secured (Deprecated)
  * Pre/PostAuthorize
  * AOP

<br>

### [Flow]
* 인증 : Request Header (Basic Token)
* 인증 유지 : Browser (Basic Token)
* 안전한 인증 : Server (Session ID)
* 효율적 인증 : Server (Bearer Token - JWT)
* 채널 인증 : OAuth

<br>

### [Flow 1 : Request Header (인증)]
<div align="center">
   <img width="80%" src="https://user-images.githubusercontent.com/37537227/147868177-87954dd2-64bf-4905-9615-ef488ddc7f00.png">
</div>

* 절차
    * HTTP 통신에서는 Header에 로그인 정보 (`username:password`)가 Base64로 Encoding된 값이 포함되어 전송
* 단점
    * Request Header만 사용하면, 사용자는 매번 로그인 정보를 기입해서 서비스 이용 필요

<br>

### [Flow 2 : Browser (인증 유지)]

<div align="center">
   <img width="80%" src="https://user-images.githubusercontent.com/37537227/147868118-e62e21f5-6b98-48b8-b31c-5085ba24fc80.png">
</div>

* 절차
    * Cookie, LocalStorage, SessionStorage 등에 로그인 정보를 저장하여, Browser가 자동으로 해당 정보를 Request Header에 포함하여 전송
* 장점 
    * 사용자는 매번 자신의 로그인 정보를 기입하지 않아도 됌
* 단점  
    * Browser는 항상 해킹에 취약하기에, 그대로 저장되어 있는 로그인 정보가 쉽게 노출됌

<br>

### [Flow 3 : Server (안전한 인증)]

<div align="center">
   <img width="80%" src="https://user-images.githubusercontent.com/37537227/147868329-7bd4ea03-1201-46a5-bb09-9de2b9fcdc2d.png">
   <img width="80%" src="https://user-images.githubusercontent.com/37537227/147868484-3e8947f6-ead3-433e-9978-ed1f39214595.png">
</div>

* 절차
   * 로그인 정보로 최초 로그인 시, 서버에서 SessionId 값을 클라이언트에게 발급
   * 추후에는 SessionId 값으로 인증 유지
* 장점
   * Raw한 로그인 정보가 아닌, SessionId 값을 사용하기에 해킹의 대상이 로그인 정보가 아닌 SessionId
* 단점
   * 각 서버에서 독자적으로 SessionId을 관리하면, Load Balance시 SessionId값이 매칭이 안되는 문제 발생
   * 모든 서버가 같은 로그인 서버와 연동하여 관리하면, 해당 서버에 과부하 발생하기 쉬움

<br>

### [Flow 4 : JWT Token (효율적 인증)]

<div align="center">
   <img width="80%" src="https://user-images.githubusercontent.com/37537227/147868712-93641ca3-c1b1-4884-81a9-f127dd0b27c4.png">
</div>

* 절차
   * 로그인 정보로 최초 로그인 시, 서버에서 Secret Key를 사용하여 JWT 토큰을 클라이언트에게 발급
* 장점
   * 각 서버가 Secret Key를 사용하여, Load Balance에 상관없이 인증 및 인가 절차 진행 가능
   * 만료기간과 Refresh 토큰 값을 적절히 사용하면 보안 강화 가능
* 단점
   * JWT Decode하기 쉽다

<br>
<hr>
<br>

## CSRF 공격 및 CSRF Token
#### [CSRF 좋은글](https://codevang.tistory.com/282)

<br>

### [공격 방식]
* Post 방식에서는 csrf Filter 발동

<br>
<hr>
<br>

## Spring Boot Security - Authentication 방식
#### 무수한 Filter들을 지나면서 Authentication과 Authorization 절차를 밟는 것이 주요 개념

<br>

<div align="center">
    <img width="80%" src="https://user-images.githubusercontent.com/37537227/148076463-4b71ed95-58c2-44b8-b8d9-ca59c0878056.png">
</div>

<br>

### [springSecurityFilterChain 등록 - SecurityConfig.java]
```java
@EnableWebSecurity(debug = true)
public classs SecurityConfig extends WebSecurityConfigurerAdapter {
    
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequest( request -> {
            request.antMatchers("/").permitAll()
                   .anyRequest().authenticated()
                   ;
        });
    }
    
}
```
* 기본 개념
  * 무수한 각각의 Filter는 AuthenticationManager를 통해 Authentication 인증 절차 완료 후 그 결과를 SecurityContextHolder에 넣어주는 역할 수행
* @EnableWebSecurity, WebSecurityConfigurerAdapter
    * 무수한 Filter에 대한 설정이 가능한 Class
* HttpSecurity
    * http 관련 보안
* .antMatcher()
    * 해당 패턴의 리퀘스트
* .anyRequest()
    * 모든 리퀘스트

<br>

### [Authentication]

<div align="center">
    <img width="50%" src="https://user-images.githubusercontent.com/37537227/148330380-470df9ab-17ba-40e0-a902-5b1495115913.png">
</div>

```java
public getMyAuthInfo() {
    return SecurityContextHolder.getContext().getAuthentication();
}
```
* Authentication (인증)
  * Credentials : 인증을 받기 위해 필요한 정보, 비번등 (input)
  * Principal : 인증된 결과. 인증 대상 (output)
  * Details : 기타 정보, 인증에 관여된 된 주변 정보들
  * Authorities : 권한 정보들
* SecurityContextHolder (인증보관함 보관소)
  * Auth 정보를 갖고 있는 객체로 이용자는 자신의 Auth 정보 조회 가능
  * 세션 유무에 상관없이 FilterChain에서 항상 가능

<br>

### [AuthenticationProvider]

<div align="center">
    <img width="50%" src="https://user-images.githubusercontent.com/37537227/148330422-93595942-6b66-418e-b769-ab63640f0205.png">
</div>

* AuthenticationProvider (인증 제공자)
  * Authentication 객체의 Credentials 내용을 보고, 그에 상응하는 Principal 결과를 담은 Authentication 객체를 다시 반환
  * 인증 결과는 AuthenticationManager에게 리턴
* AuthenticationManager (인증 관리자)
  * AuthenticationManager Interface의 구현체 Provider Manager

<br> 

### [AuthenticationManager]

<div align="center">
    <img width="50%" alt="스크린샷 2022-01-06 오후 1 55 38" src="https://user-images.githubusercontent.com/37537227/148330437-490ac47c-1f34-40ab-a447-592cd824a564.png">
</div>

<br>

### [인증 방법]
* 메모리 사용자 인증
* Basic Token 인증
  * Base64 Encoding (Authorization : username:password)
* Bearer Token 인증
  * JWT 토큰
  * Opaque 토큰

<br>

### [메모리 사용자 인증]

<br>

### [Basic Token 인증]
```java
@EnableWebSecurity(debug = true)
public classs SecurityConfig extends WebSecurityConfigurerAdapter {
    
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.basic();
    }
    
}
```

<br>

```java
String secretKey = Base64.getEncoder().encodeToString(SecretKey.getBytes());
```
* Client에서 Base64로 인코딩된 `username:password` 정보가 Header의 `Authorization` 키의 밸류 값으로 들어온다
* Server에서 해당 정보로 인증을 받으면, SessionId 값을 생성하여 연결을 유지하는 것이 기존부터 사용되던 방식
  * 다만, Basic Token의 경우, Base64로 Encoding되는데, Decode하기 쉽기 때문에, 이는 보안적으로 강하지 않다
  * 이러한 이유로 Basic Token에서 Bearer Token으로 넘어가게 되는 다양한 이유들 중 하나가 되었다
* 신기한 사실은 Cookie 개념은 Browser에만 존재
  * Javascript로 Cookie를 사용하는 것부터 접했기에, Mobile 환경에서는 Cookie를 사용하지 않는다는 점을 늦게 접했다
  * Native Apps like Android and IOS don't need Cookies because they are not running on top of browser라고 한다
  * Native Apps는 별도의 Session Object가 존재하여 Cookie개념이 없다

<br>

### [Bearer Token 인증]

<br>
<hr>
<br>


## JWT
#### 

<br>

### [예시]
```java
import io.jsonwebtoken.Jwts;

Jwts.builder()... //
```



