# Thread
> 프로그램이 실행되면 OS로 부터 메모리를 할당받아 프로세스 상태가 됌
* 프로세스는 하나 이상의 Thread를 가지게 되고, 실제 작업을 수행하는 단위는 Thread
* [tcpschool 글](http://tcpschool.com/java/java_thread_multi)

<hr>
<br>

## 기본 배경지식
#### 프로그램이 프로세스 그리고 스레드로서 실행되는 일련의 과정 이해 필요

<br>

### [컴퓨터 내부 실행 과정]

<div align="center">
  <img width="40%" src="https://user-images.githubusercontent.com/37537227/118350966-473e8900-b594-11eb-88be-80c2b01f3d73.png">
  <img width="43%" src="https://user-images.githubusercontent.com/37537227/118350922-05154780-b594-11eb-9f37-54b2bac92bfd.png">
</div>

<br>

* HW 별 점유 단위
  * ```Hard Disk```: 프로그램 (Program)
  * ```Memory```: 프로세스 (Process)
  * ```CPU```: 스레스 (Thread)

<br>

### [Shared Resource - Thread 간의 자원 공유]

<div align="center">
  <img width = "40%" src ="https://user-images.githubusercontent.com/37537227/118351144-2aef1c00-b595-11eb-80c4-b16dcd3aedfb.png">
</div>

<br>

* ```Context Switching```: Thread는 각각 자신만의 작업 공간을 갖고 이를 Context라고 부른다 (Process Control Block - PCB)
  * ```Static Instance```: Java에서는 공유 자원을 보통 static instance로 할당
  * ```동기화``` : ```multi-threading``` 프로그래밍에서는 Thread 간에 자원을 공유할 수 있기 때문에, Thread 간에 올바른 순서로 사용할 수 있게 동기화를 진행해줘야 한다
  * ```Race Condition``` : 각 thread가 서로 자원을 차지하려는 현상
  * ```Critical Section```: ```race condition```이 발생하는 구간 
  * 예: 모든 Thread가 DB와 동시에 연동이 될 수는 없다

<br>
<hr>
<br>

## Thread 구현 2가지 방법
#### Thread Class와 Runnable Interface

<br>

### [extends Thread Class]

```java
public class Main {

    public static class MyThread extends Thread {

        public int myNum;

        public MyThread(int myNum) {
            this.myNum = myNum;
        }
        
        @Override
        public void run() {

            for (int i = 1; i<=200; i++) {
                System.out.printf("%s from Thread %s\n", i, myNum);

                if (myNum == 4)
                    throw new RuntimeException();

                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }

        }
    }

    public static void main(String[] args) {
        System.out.println(Thread.currentThread() + "start"); // static 메소드

        for(int i = 0; i < 5; i++) {
            MyThread th = new MyThread(i);
            th.start(); // Thread 시작
        }
        
        System.out.println(Thread.currentThread() + "end"); // static 메소드

        throw new RuntimeException();
    }
}
```
* .start() 메소드를 호출하면 완전히 독립된 Thread 실행
  * 하나의 MyThread에서 혹은 main 함수에서 `throw new RuntimeException()`이 발생해도 다른 MyThread는 문제없이 그대로 동작
* 하지만 JAVA에서는 Ambiguity 때문에 extends를 오직 Class 한 개만 가능한데, 그뜻은 Thread Class만 상속 가능해진다는 단점 발생

<br>

### [implements Runnable Interface]

```java
public class Main {

    public static class MyThread implements Runnable {

        public int myNum;

        public MyThread(int myNum) {
            this.myNum = myNum;
        }

        @Override
        public void run() {

            for (int i = 1; i<=3; i++) {
                System.out.printf("%s from Thread %s\n", i, myNum);

                if (myNum == 4)
                    throw new RuntimeException();

                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }

        }
    }

    public static void main(String[] args) {
        System.out.println(Thread.currentThread() + "start"); // static 메소드

        for(int i = 0; i < 5; i++) {
            MyThread myThread = new MyThread(i);
            Thread th = new Thread(myThread);

            th.setDaemon(true);

            th.start(); // Thread 시작
            System.out.println(th.isAlive()); // True
            if (i == 1)
                throw new RuntimeException();

            try {
                th.join();
                System.out.println(th.isAlive()); // False
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

        }

        System.out.println(Thread.currentThread() + "end"); // static 메소드
    }
}
```
* Java는 다수의 Interface를 Implements할 수 있고, 하나의 Class를 Extends할 수 있기 때문에, Class를 Extends할 수 있는 여유가 있다는게 장점
* Daemon Thread는 주 Thread를 보조하는 역할로 주 Thread가 종료되면 Daemon Thread도 종료
  * extends Thread Class 예시와는 달리, Daemon Thread로 구성되어 있기 때문에, Main 함수 Thread에서 `throw new RuntimeException()`하면 Daemon Thread들도 모두 종료
* .join()
  * 함수를 호출한 Thread의 연산이 모두 완료될 때까지 대기 (Waits for this thread to die)
* .isAlive()
  * .start()했고 아직 die하지 않은 상태이면 True; otherwise, False


<br>
<hr>
<br>

## Thread Status (상태)
#### Thread의 상태와 상태 변경 메소드

<br>

<div align="center">
  <img width = "80%" src ="https://user-images.githubusercontent.com/37537227/168476448-131ce7da-9583-4b87-bae9-149af09d7a56.png">
</div>

<br>

<div align="center">
  <img width = "80%" src ="https://user-images.githubusercontent.com/37537227/118351743-a1d9e400-b598-11eb-874f-120729522c35.png">
</div>

<br>

### [주요 메소드]

<div align="center">
  <img width = "80%" src ="https://user-images.githubusercontent.com/37537227/118351948-b10d6180-b599-11eb-8b54-a0e50e5eeae4.png">
</div>

<br>

```java
Thread.currentThread(); //현재 Thread 정보 조회

th.setPriority(Thread.MAX_PRIORITY); //우선순위 설정
th.setPriority(Thread.NORM_PRIORITY);
th.setPriority(Thread.MIN_PRIORITY);

th1.join(); //main 함수 THREAD가 th1 Thread를 기다린다
th2.join(); //main 함수 THREAD가 th2 Thread를 기다린다
```

<br>
<hr>
<br>

## Multi-thread 프로그래밍에서의 동기화
#### Critical Section과 Semaphore

<br>

<div align="center">
  <img src ="https://user-images.githubusercontent.com/37537227/118352268-75739700-b59b-11eb-96b7-9440e720568f.png">
</div>

* ```Critical Section```: 2개 이상의 Thread가 동시에 접근할 수 없는 영역 (Shared Resource를 사용하는 영역)
* ```Semaphore```: 시스템 객체로, get과 release 기능 탑재
  * 오직 1개의 thread만이 ```semaphore를 얻어서 Critical Section에 접근```할 수 있고, ```나머지는 대기``` (blocking) 상태가 된다

<br>

### [동기화 예시 - Synchronized 메소드 방식]

```java
class Bank {
  private int money = 10000;
  
  public synchronized void saveMoney (int save) {
    int m = getMoney();
    ...
  }
  
  public synchronized void minusMoney (int minus) {
    int m = getMoney();
    ... 
  }
}
```
* ```synchronized```: 해당 타입의 메소드가 진행되고 있는 동안에는 ```Shared Resource``` 혹은 이 메소드가 속해있는 객체에 Lock이 걸어진다

<br>

### [DeadLock]

<div align="center">
  <img src="https://user-images.githubusercontent.com/37537227/118352775-31ce5c80-b59e-11eb-862f-e16beaf0711b.png">
</div>

* ```Deadlock```: dealock이 발생하지 않도록 synchronized 메소드에서 다른 synchronized 메소드를 호출하지 않도록 하자

<br>

### [동기화 예시 - Synchronized 블럭 방식]

```java
class Bank {
  private int money = 10000;
  
  public void saveMoney (int save) {
    syncrhonized(this) {
      int m = getMoney();
      ...
    }
    
  }
  
  public void minusMoney (int minus) {
    syncrhonized(this) {
      int m = getMoney();
      ...
    }
  }
}
```

<br>

### [동기화 예시 - wait(), notify()]

```java
class FastLibrary {
  public ArrayList<String> shelf = new ArrayList<>();
  
  public FastLibrary() {
    shelf.add("book 1");
    shelf.add("book 2");
    shelf.add("book 3");
    shelf.add("book 4");
    shelf.add("book 5");
  }
  
  public synchronized String lendBook () throws InterruptedException {
    
    Thread t = Thread.currentThread();
    
    while (shelf.size() == 0) {
      wait();
    }
    
    if (shelf.size() > 0) {
      String book = shelf.remove(0);
      return book;
    } else return null;
    
  }
  
  public synchronized void returnBook (String book) throws InterruptedException {

    Thread t = Thread.currentThread();
    
    shelf.add(book);
    
    //notify();     // 하나의 Thread를 Randomly 깨운다
    notifyAll();  // 모든 Thread를 깨워서 Race Condition으로 만들고 경쟁을 시킨다 (이런 상황이 더 공평하다고 한다)
    
  }
}
```
* 예시 상황 : 도서관 책 빌리기 (예약해놓고 재고가 생기면 연락받는 형식)
* ```wait(), notify()```: 만약 shared resource가 이미 사용 중이라면 사용 필요
  * 이 예시는 FastLibrary 클래스로 객체 하나만을 생성하는 예시
  * `shelf` 리스트를 static 리소스로 변경하는 것이 더 올바른 예시가 되지 않을까 싶음
