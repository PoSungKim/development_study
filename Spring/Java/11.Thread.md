## Thread
> 프로그램이 실행되면 OS로 부터 메모리를 할당받아 프로세스 상태가 됌
* 프로세스는 하나 이상의 Thread를 가지게 되고, 실제 작업을 수행하는 단위는 Thread

<hr>
<br>

## 기본 배경지식

#### 프로그램이 프로세스 그리고 스레드로서 실행되는 일련의 과정 이해 필요

<br>

### [컴퓨터 내부 실행 과정]

<div align="center">
  <img width="40%" src="https://user-images.githubusercontent.com/37537227/118350966-473e8900-b594-11eb-88be-80c2b01f3d73.png">
  <img width="43%" src="https://user-images.githubusercontent.com/37537227/118350922-05154780-b594-11eb-9f37-54b2bac92bfd.png">
</div>

<br>

* HW 별 점유 단위
  * ```Hard Disk```: 프로그램 (Program)
  * ```Memory```: 프로세스 (Process)
  * ```CPU```: 스레스 (Thread)

<br>

### [Shared Resource - Thread 간의 자원 공유]

<div align="center">
  <img width = "40%" src ="https://user-images.githubusercontent.com/37537227/118351144-2aef1c00-b595-11eb-80c4-b16dcd3aedfb.png">
</div>

<br>

* ```Context Switching```: Thread는 각각 자신만의 작업 공간을 갖고 이를 Context라고 부른다 (Process Control Block - PCB)
  * ```Static Instance```: Java에서는 공유 자원을 보통 static instance로 할당
  * ```동기화``` : ```multi-threading``` 프로그래밍에서는 Thread 간에 자원을 공유할 수 있기 때문에, Thread 간에 올바른 순서로 사용할 수 있게 동기화를 진행해줘야 한다
  * ```Race Condition``` : 각 thread가 서로 자원을 차지하려는 현상
  * ```Critical Section```: ```race condition```이 발생하는 구간 
  * 예: 모든 Thread가 DB와 동시에 연동이 될 수는 없다

<br>
<hr>
<br>

## Thread 구현 2가지 방법

#### Thread Class와 Runnable Interface

<br>

### [Thread Class]

```java
class MyThread extends Thread {
  
  public void run() {
    int i;
    for (i = 1; i<=200; i++) {
      System.out.println()i + "\t";
    }
  }
}

public class ThreadTest {
  public static void main(String[] args) {
    
    System.out.println(Thread.currentThread() + "start"); // static 메소드
    MyThread th1 = new MyThread();
    MyThread th2 = new MyThread();
    
    th1.start(); // Thread 시작
    th2.start(); // Thread 시작
    
    System.out.println(Thread.currentThread() + "end"); // static 메소드
  }
}

```

<br>

### [Runnable Interface]

```java
class MyThread implements Runnable {
  
  @Override
  public void run() {
    int i;
    for (i = 1; i<=200; i++) {
      System.out.println()i + "\t";
    }
  }
}

public class ThreadTest {
  public static void main(String[] args) {
    
    System.out.println(Thread.currentThread() + "start"); // static 메소드
    
    MyThread runnable = new MyThread();
    
    Thread th1 = new Thread(runnable);
    Thread th2 = new Thread(runnable);
    
    th1.start(); // Thread 시작
    th2.start(); // Thread 시작
    
    System.out.println(Thread.currentThread() + "end"); // static 메소드
    
    /* *************************************************************** */
    
    Runnable runnable = new Runnable() {
      @Override
      public void run() {
        System.out.println("run");
      }
    }
    
    runnable.run();
  }
}
```

<br>
<hr>
<br>

## Thread Status (상태)

#### Thread의 상태와 상태 변경 메소드

<br>

<div align="center">
  <img src ="https://user-images.githubusercontent.com/37537227/118351743-a1d9e400-b598-11eb-874f-120729522c35.png">
</div>

<br>

### [주요 메소드]

<div align="center">
  <img src ="https://user-images.githubusercontent.com/37537227/118351948-b10d6180-b599-11eb-8b54-a0e50e5eeae4.png">
</div>

<br>

```java
th.setPriority(Thread.MAX_PRIORITY); // 우선순위 설정
th.setPriority(Thread.NORM_PRIORITY);
th.setPriority(Thread.MIN_PRIORITY);

th1.join(); //main 함수 THREAD
th2.join();
```
