# Note
> Java에 대한 주요 핵심 개념 정리

* 객체 지향에 대한 기본기 중요

<hr>
<br>

## 1. Java

#### 국내 기업에서 가장 안정적으로 많이 사용되는 언어

<br>

### [객체지향 언어]
```bash
1. 캡슐화 
  - 객체의 속성을 보호하기 위함
  - 변수는 private, 메소드는 public
  - public 메소드의 매개변수는 validation한 이후에 실행
  - Access Modifier (접근 지시자)
    - private   : 클래스 내부에서 접근 가능
    - public    : 모두가 접근 가능
    - default   : 같은 패키지 내에서 접근 가능
    - protected : 같은 패키지나 상위 클라스도 접근 가능
  - Information Hiding (정보 은닉)
    - 객체의 변수를 노출하지 않고, 내부 로직도 모두 오픈하지 않는다

```

<br>

<div align="center">
  <img width="840" alt="스크린샷 2021-05-02 오후 11 08 11" src="https://user-images.githubusercontent.com/37537227/116816019-46245980-ab9b-11eb-93c1-911a3621403a.png">
</div>

<br>

```
2. 상속 
  - 최상위 클래스에서 하위 클래스로 내려갈 수록 구체화
```

<br>

<div align="center">
  <img width="928" alt="스크린샷 2021-05-02 오후 11 12 14" src="https://user-images.githubusercontent.com/37537227/116816174-d82c6200-ab9b-11eb-9db8-535e704fe352.png">
</div>

<br>

```bash
3. 다형성
  - 하나의 개체가 여러 개의 형태로 변화하는 것을 말한다 
  - 오버라이딩을 통해서 구현 가능
```

<br>

<div align="center">
  <img width="874" alt="스크린샷 2021-05-02 오후 11 16 39" src="https://user-images.githubusercontent.com/37537227/116816329-74eeff80-ab9c-11eb-9a20-28956b7d1358.png">
</div>

<br>

```bash
4. 추상화 
  - 객체지향에서의 추상화는 모델링
  - 공통적인 부분, 특정 분리 부분 등을 재조합하는 것이 추상화
  - 상속과 다형성 모두 추상화에 속한다  
```

<br>
<hr>
<br>

## 2. .java => Compiler => .class => JVM

#### Java 프로그램이 Process로서 컴퓨터 메모리에 적재되어 Running 하기 까지의 과정 정리

![스크린샷 2021-04-24 오후 12 24 38](https://user-images.githubusercontent.com/37537227/115945757-0bb22100-a4f8-11eb-88bd-df374feb6c87.png)

* Java 언어는 Write Once And Run Anywhere (WORA) 개념이 있는데, 즉 HW Independent 하다는 뜻이다
  * 보통, Source Code를 Compile하게 되면, MacOS에서 컴파일한 파일은 MacOS에서만 돌아가고, Window에서 컴파일한 파일은 Window에서만 돌아가지만, Java는 그렇지 않다

<br>

![스크린샷 2021-04-24 오후 12 29 30](https://user-images.githubusercontent.com/37537227/115945884-bc202500-a4f8-11eb-9a62-30f8d8f9d98f.png)

* Java 언어는 Compile된 Byte Code를 JVM을 사용하게 된다면 어디서든 사용할 수 있게 된다 
* JVM (Java Virtual Machine) > JRE (Java Runtime Environment) > JDK (Java Development Kit)이라는 포함관계가 있기 때문에, JDK만 설치하면 된다
  * JRE는 C 언어의 Linker와 Loader 역할을 수행한다
  * JVM은 JAVA 프로그램이 실행되는 공간이다 (Write Once and Run Anywhere이 구현되는 공간)


<br>
<hr>
<br>


## 3. 변수와 메모리 할당 구조

#### 지역 변수, 인스턴스 변수 (멤버 변수), 참조 변수, Static 변수/메소드 등 다른 메모리에서 구동된다는 점을 이해해야 한다

<br>

### [메소드와 Stack Memory]
<div align="center">
  <img width="700" alt="스크린샷 2021-05-02 오후 10 54 12" src="https://user-images.githubusercontent.com/37537227/116815618-53404900-ab99-11eb-8ecb-048f5acb1d82.png">
</div>

* 운영체제에서 배운 바와 같이, 함수가 호출되고, 그때 그때 ```지역변수```에 대한 할당이 필요할 때 Stack Register를 더 사용했다가 끝나면 할당을 풀어주는 과정이 수행된다.
* ```메소드```와 ```함수```의 차이점
  * ```함수```는 단독 모듈로, Class에 속하지 않음
  * ```메소드```는 Class에 속함

<br>

### [객체와 Heap Memory]
<div align="center">
  <img width="700" alt="스크린샷 2021-05-02 오후 11 36 03" src="https://user-images.githubusercontent.com/37537227/116816980-4292d180-ab9f-11eb-9e49-071aa1896a0b.png">
</div>

* ```참조 변수```가 인스턴스이다.
  * ```System.out.println(<인스턴스>)```을 해보면, 주소값이 나오는데, 해당 주소값이 가르키는 주소는 Heap Memory에 할당된 주소이다.
* ```왼쪽 참조변수``` Stack Memory, ```오른쪽 new 객체```는 Heap Memory
  * ```주소값```은 ```Stack Memory```에, 주소에 저장된 각각의 ```실제 값```들은 ```Heap Memory```에 저장된다

<br>

### [여러 인스턴스가 공유하는 변수 - Static 변수]
<div align="center">
  <img width="308" alt="스크린샷 2021-05-05 오전 11 51 47" src="https://user-images.githubusercontent.com/37537227/117092107-49386900-ad98-11eb-82ea-8ac6d70df20e.png">
  <img width="657" alt="스크린샷 2021-05-05 오후 12 12 42" src="https://user-images.githubusercontent.com/37537227/117093179-34a9a000-ad9b-11eb-8f71-bb838358485d.png">
</div>

* 같은 클래스의 다수의 인스턴스가 존재하고, ```다수의 인스턴스가 공유하고자 하는 변수```가 필요할 때, ```Static 변수```를 사용한다
* ```인스턴스```는 ```Heap Memory```에 적재되어 생성되었다가 사용이 완료되면, ```Garbage Collector (GC)```가 메모리를 수거하는 형식이기 때문에 Class 내에서 선언된 Static 변수도 Heap Memory에 적재된다고 생각할 수도 있다
  * 하지만, ```Static 변수```는 ```처음 Program이 Memory에 적재```되어 하나의 Process로서 Running할 때 함께 적재된다
  * 구체적으로는, 하나의 ```Process```는 크게 ```Code 영역```과 ```Data 영역```으로 구성되는데, 바로 ```Data 영역에 Static 변수```가 적재되는 것이다
  * 따라서, Process가 종료되어 메모리에서 Unload될 때, Static 변수도 함께 Unload된다
* ```<인스턴스명>.<static변수명>```과 ```<클래스명>.<static변수명>``` 형태로 호출할 수 있는데, ```<클래스명>```으로 호출이 가능한 이유는 ```Data영역에 이미 적재```되어 있기 때문

<br>

### [Static 함수]

* Static 함수 또한 Program이 메모리에 로딩될 때 함께 로드된다
* ```<클래스명>.<static메소드명>()```형태로 호출 가능
* 사용 가능 변수
  * ```지역 변수```
  * ```Static 변수```
* 사용 불가능 변수 
  * ```멤버 변수``` : 이유는 멤버 변수는 인스턴스가 할당될 때 생성되기 때문에, 아직 생성되지 않은 ```인스턴스 변수```에 대한 처리는 불가능


<br>
<hr>
<br>

## 4. 디자인 패턴 

#### ```효율적인 객체지향 프로그래밍```을 위해서 만든 ```디자인 패턴 23개 가량``` 존재

<br>

### [싱글톤 패턴 (Singleton Pattern)]
```java
public class Company {

  private static instance = new Company();
  
  private Company () {
  
  }
  
  public static Compnay getInstance() {
    if (instance == null ) {
      instance = new Company();
    }
  
    return instance;
  }
  
}
```

<br>

```java
public class CompanyTest {
  public static void main (String[] args) {
    Company companyOne = Company.getInstance();
    Company companyTwo = Company.getInstance();
    
    System.out.println(companyOne);
    System.out.println(companyTwo);
    
    //Calender calender = new Calender() -- 이렇게 사용하지는 않는다, 날짜를 관리하는 객체는 하나만 존재해도 충분하기 때문
    Calender caldender  = Calender.getInstance() 
  }
}
```
* ```프로그램 내에서 한 개의 인스턴스만```을 생성하는 디자인 패턴
  * ```default 생성자```는 ```public```이기 때문에, ```private```으로 생성 필요
* ```companyOne```과 ```companyTwo``` 변수 모두 같은 주소값을 갖게 된다 --> 같은 인스턴스를 가리키고 있기 때문에

<br>
<hr>
<br>

## 5. Primitive Data Type vs. Object Data Type 

#### ```int, double``` 등이 ```Primitive Data Type```으로 Byte가 정해져 있고, ```Integer, String Builder``` 등이 ```Object Data Type```으로 flexible한 크기를 갖는다

### [String vs String Builder, String Buffer]
```java

```
* 보통, 성능을 개선하기 위해 Object Data Type들이 개발되고 도입되고 있다는 Context가 있다

<br>
<hr>
<br>

## 6. 상속

#### 새로운 클래스를 생성할 때, 기존에 이미 만들어진 클래스로부터 상속을 받아서, 보다 기능과 속성을 확장시키고자 한다

<div align="center">
  <img width="388" alt="스크린샷 2021-05-07 오후 1 59 02" src="https://user-images.githubusercontent.com/37537227/117399844-6443de00-af3c-11eb-89dd-63f9386c6d4f.png">
</div>

### [단일 상속 - 하위 Class가 상위 Class 1개만을 확장시킨다, Extend 시킨다]
```java
Class A {
  protected 속성1;
  protected 속성2;
  
  ...
}

Class B extends A {
  ... 
  public B {
    속성1 = "속성1";
    속성2 = "속성2";
  }
}
```
* 구조
  * 상속하는 Class A : ```상위 클래스```, ```Parent Class```, Base Class, Super Class - 보다 일반적인 기능과 개념으로 구성됌 
  * 상속받는 Class B : ```하위 클래스```, ```Child Class```, Derived Class, Subclass  - 보다 구체적인 기능과 개념으로 구성됌
* 단일 상속 (Single Inheritance)
  * ```extends``` 단위 뒤로는 클래스 1개만 가능
  * ```Interface``` 뒤에는 다수의 클래스 가능
* ```상위 클래스에서 상속받는 멤버변수```는 ```protected``` 타입, 그리고 ```상속받는 메소드```는 ```public``` 타입
  * ```protected``` 타입은 ```클래스 내부```와 ```하위 클래스```에서 사용가능하기 때문

<br>

<div align="center">
  <img width="588" alt="스크린샷 2021-05-07 오후 2 52 12" src="https://user-images.githubusercontent.com/37537227/117403850-d23fd380-af43-11eb-8d56-564fb10e53f2.png">
</div>

<br>

### [super() - 하위 클래스 Constructor에서 default로 상위 클래스 Constructor인 Super() 호출]
```java
...
  public B {
    super();
    
    속성1 = "속성1";
    속성2 = "속성2";
  }
...
```
* ```super.<메소드>``` 그리고 ```super.<멤버 변수>``` 형식으로도 사용 가능
* 상위 클래스 Constructor가 호출되면서 포함되는 멤버 변수들이 모두 호출되고 (Private 변수들도 생성된다, 접근을 못할 뿐)
* 그 다음에 하위 클래스 Constructor가 호출되면서 남은 멤버 변수들도 호출되는 형식

<br>

### [형변환 - 업캐스팅]
```java
UpperClassA upperClassA = new lowerClassB();
```
* 하위 클래스를 상위 클래스로 형변환 가능 --> 업캐스팅
* 다만, 하위 클래스 인스턴스이지만, 상위 클래스 Type으로 생성됐기 때문에, 상위 클래스 변수와 메소드만 사용할 수 있다 (제한이 걸림)
  * 하위 클래스 인스턴스이기 때문에, 하위 클래스 내용도 모두 호출 및 생성이 되었기 때문에, 하위 클래스로 형변환을 한다면 모두 사용할 수 있게 된다

<br>
<hr>
<br>

## 7. Multi-thread 환경에서 동기화 진행, 동기화를 진행하는 시스템 함수 (semaphore?)

#### 국내 기업에서 가장 안정적으로 많이 사용되는 언어

### [.java]
```java
  ssh
  wget
  curl
  ping
  ps
```
* 명령어를 실행하면 배포 관련 안정성 체크를 하고 부족한 점들을 안내해줌

<br>
<hr>
<br>

## 8. Package, Import  언어별로 정리 필요

#### 국내 기업에서 가장 안정적으로 많이 사용되는 언어

### [.java]
```java
  ssh
  wget
  curl
  ping
  ps
```
* 명령어를 실행하면 배포 관련 안정성 체크를 하고 부족한 점들을 안내해줌

<br>
<hr>
<br>

## 9. Java 10부터 local variable inference 가능 (다만 처음에 선언한 데이터 타입에서 다른 타입으로 중간에 변환 불가능)

#### 국내 기업에서 가장 안정적으로 많이 사용되는 언어

### [.java]
```java
  ssh
  wget
  curl
  ping
  ps
```
* 명령어를 실행하면 배포 관련 안정성 체크를 하고 부족한 점들을 안내해줌

<br>
<hr>
<br>

## 10. 객체지향, POJO, 

#### 국내 기업에서 가장 안정적으로 많이 사용되는 언어

### [.java]
```java
  ssh
  wget
  curl
  ping
  ps
```
* 명령어를 실행하면 배포 관련 안정성 체크를 하고 부족한 점들을 안내해줌

<br>
<hr>
<br>

## 11. Generics

#### 국내 기업에서 가장 안정적으로 많이 사용되는 언어

### [.java]
```java
  ssh
  wget
  curl
  ping
  ps
```
* 명령어를 실행하면 배포 관련 안정성 체크를 하고 부족한 점들을 안내해줌

<br>
<hr>
<br>




