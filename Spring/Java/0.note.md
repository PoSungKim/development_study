# Note
> Java에 대한 주요 핵심 개념 정리

* 객체 지향에 대한 기본기 중요

<hr>
<br>

## 1. Java

#### 국내 기업에서 가장 안정적으로 많이 사용되는 언어

<br>

### [객체지향 언어]
```bash
1. 캡슐화 
  - 객체의 속성을 보호하기 위함
  - 변수는 private, 메소드는 public
  - public 메소드의 매개변수는 validation한 이후에 실행
  - Access Modifier (접근 지시자)
    - private   : 클래스 내부에서 접근 가능
    - public    : 모두가 접근 가능
    - default   : 같은 패키지 내에서 접근 가능
    - protected : 같은 패키지나 상위 클라스도 접근 가능
  - Information Hiding (정보 은닉)
    - 객체의 변수를 노출하지 않고, 내부 로직도 모두 오픈하지 않는다

```

<br>

<div align="center">
  <img width="840" alt="스크린샷 2021-05-02 오후 11 08 11" src="https://user-images.githubusercontent.com/37537227/116816019-46245980-ab9b-11eb-93c1-911a3621403a.png">
</div>

<br>

```
2. 상속 
  - 최상위 클래스에서 하위 클래스로 내려갈 수록 구체화
```

<br>

<div align="center">
  <img width="928" alt="스크린샷 2021-05-02 오후 11 12 14" src="https://user-images.githubusercontent.com/37537227/116816174-d82c6200-ab9b-11eb-9db8-535e704fe352.png">
</div>

<br>

```bash
3. 다형성
  - 하나의 개체가 여러 개의 형태로 변화하는 것을 말한다 
  - 오버라이딩을 통해서 구현 가능
```

<br>

<div align="center">
  <img width="874" alt="스크린샷 2021-05-02 오후 11 16 39" src="https://user-images.githubusercontent.com/37537227/116816329-74eeff80-ab9c-11eb-9a20-28956b7d1358.png">
</div>

<br>

```bash
4. 추상화 
  - 객체지향에서의 추상화는 모델링
  - 공통적인 부분, 특정 분리 부분 등을 재조합하는 것이 추상화
  - 상속과 다형성 모두 추상화에 속한다  
```

<br>
<hr>
<br>

## 2. .java => Compiler => .class => JVM

#### Java 프로그램이 Process로서 컴퓨터 메모리에 적재되어 Running 하기 까지의 과정 정리

![스크린샷 2021-04-24 오후 12 24 38](https://user-images.githubusercontent.com/37537227/115945757-0bb22100-a4f8-11eb-88bd-df374feb6c87.png)

* Java 언어는 Write Once And Run Anywhere (WORA) 개념이 있는데, 즉 HW Independent 하다는 뜻이다
  * 보통, Source Code를 Compile하게 되면, MacOS에서 컴파일한 파일은 MacOS에서만 돌아가고, Window에서 컴파일한 파일은 Window에서만 돌아가지만, Java는 그렇지 않다

<br>

![스크린샷 2021-04-24 오후 12 29 30](https://user-images.githubusercontent.com/37537227/115945884-bc202500-a4f8-11eb-9a62-30f8d8f9d98f.png)

* Java 언어는 Compile된 Byte Code를 JVM을 사용하게 된다면 어디서든 사용할 수 있게 된다 
* JVM (Java Virtual Machine) > JRE (Java Runtime Environment) > JDK (Java Development Kit)이라는 포함관계가 있기 때문에, JDK만 설치하면 된다
  * JRE는 C 언어의 Linker와 Loader 역할을 수행한다
  * JVM은 JAVA 프로그램이 실행되는 공간이다 (Write Once and Run Anywhere이 구현되는 공간)


<br>
<hr>
<br>


## 3. 변수와 메모리 할당 구조

#### 지역 변수, 인스턴스 변수 (멤버 변수), 참조 변수, Static 변수/메소드 등 다른 메모리에서 구동된다는 점을 이해해야 한다

<br>

### [메소드와 Stack Memory]
<div align="center">
  <img width="700" alt="스크린샷 2021-05-02 오후 10 54 12" src="https://user-images.githubusercontent.com/37537227/116815618-53404900-ab99-11eb-8ecb-048f5acb1d82.png">
</div>

* 운영체제에서 배운 바와 같이, 함수가 호출되고, 그때 그때 ```지역변수```에 대한 할당이 필요할 때 Stack Register를 더 사용했다가 끝나면 할당을 풀어주는 과정이 수행된다.
* ```메소드```와 ```함수```의 차이점
  * ```함수```는 단독 모듈로, Class에 속하지 않음
  * ```메소드```는 Class에 속함

<br>

### [객체와 Heap Memory]
<div align="center">
  <img width="700" alt="스크린샷 2021-05-02 오후 11 36 03" src="https://user-images.githubusercontent.com/37537227/116816980-4292d180-ab9f-11eb-9e49-071aa1896a0b.png">
</div>

* ```참조 변수```가 인스턴스이다.
  * ```System.out.println(<인스턴스>)```을 해보면, 주소값이 나오는데, 해당 주소값이 가르키는 주소는 Heap Memory에 할당된 주소이다.
* ```왼쪽 참조변수``` Stack Memory, ```오른쪽 new 객체```는 Heap Memory
  * ```주소값```은 ```Stack Memory```에, 주소에 저장된 각각의 ```실제 값```들은 ```Heap Memory```에 저장된다

<br>

### [여러 인스턴스가 공유하는 변수 - Static 변수]
<div align="center">
  <img width="308" alt="스크린샷 2021-05-05 오전 11 51 47" src="https://user-images.githubusercontent.com/37537227/117092107-49386900-ad98-11eb-82ea-8ac6d70df20e.png">
  <img width="657" alt="스크린샷 2021-05-05 오후 12 12 42" src="https://user-images.githubusercontent.com/37537227/117093179-34a9a000-ad9b-11eb-8f71-bb838358485d.png">
</div>

* 같은 클래스의 다수의 인스턴스가 존재하고, ```다수의 인스턴스가 공유하고자 하는 변수```가 필요할 때, ```Static 변수```를 사용한다
* ```인스턴스```는 ```Heap Memory```에 적재되어 생성되었다가 사용이 완료되면, ```Garbage Collector (GC)```가 메모리를 수거하는 형식이기 때문에 Class 내에서 선언된 Static 변수도 Heap Memory에 적재된다고 생각할 수도 있다
  * 하지만, ```Static 변수```는 ```처음 Program이 Memory에 적재```되어 하나의 Process로서 Running할 때 함께 적재된다
  * 구체적으로는, 하나의 ```Process```는 크게 ```Code 영역```과 ```Data 영역```으로 구성되는데, 바로 ```Data 영역에 Static 변수```가 적재되는 것이다
  * 따라서, Process가 종료되어 메모리에서 Unload될 때, Static 변수도 함께 Unload된다
* ```<인스턴스명>.<static변수명>```과 ```<클래스명>.<static변수명>``` 형태로 호출할 수 있는데, ```<클래스명>```으로 호출이 가능한 이유는 ```Data영역에 이미 적재```되어 있기 때문

<br>

### [Static 함수]

* Static 함수 또한 Program이 메모리에 로딩될 때 함께 로드된다
* ```<클래스명>.<static메소드명>()```형태로 호출 가능
* 사용 가능 변수
  * ```지역 변수```
  * ```Static 변수```
* 사용 불가능 변수 
  * ```멤버 변수``` : 이유는 멤버 변수는 인스턴스가 할당될 때 생성되기 때문에, 아직 생성되지 않은 ```인스턴스 변수```에 대한 처리는 불가능


<br>
<hr>
<br>

## 4. 디자인 패턴 

#### ```효율적인 객체지향 프로그래밍```을 위해서 만든 ```디자인 패턴 23개 가량``` 존재

<br>

### [싱글톤 패턴 (Singleton Pattern)]
```java
public class Company {

  private static instance = new Company();
  
  private Company () {
  
  }
  
  public static Compnay getInstance() {
    if (instance == null ) {
      instance = new Company();
    }
  
    return instance;
  }
  
}
```

<br>

```java
public class CompanyTest {
  public static void main (String[] args) {
    Company companyOne = Company.getInstance();
    Company companyTwo = Company.getInstance();
    
    System.out.println(companyOne);
    System.out.println(companyTwo);
    
    //Calender calender = new Calender() -- 이렇게 사용하지는 않는다, 날짜를 관리하는 객체는 하나만 존재해도 충분하기 때문
    Calender caldender  = Calender.getInstance() 
  }
}
```
* ```프로그램 내에서 한 개의 인스턴스만```을 생성하는 디자인 패턴
  * ```default 생성자```는 ```public```이기 때문에, ```private```으로 생성 필요
* ```companyOne```과 ```companyTwo``` 변수 모두 같은 주소값을 갖게 된다 --> 같은 인스턴스를 가리키고 있기 때문에

<br>
<hr>
<br>

## 5. Primitive Data Type vs. Object Data Type 

#### ```int, double``` 등이 ```Primitive Data Type```으로 Byte가 정해져 있고, ```Integer, String Builder``` 등이 ```Object Data Type```으로 flexible한 크기를 갖는다

### [String vs String Builder, String Buffer]
```java

```
* 보통, 성능을 개선하기 위해 Object Data Type들이 개발되고 도입되고 있다는 Context가 있다

<br>
<hr>
<br>

## 6. 상속

#### 새로운 클래스를 생성할 때, 기존에 이미 만들어진 클래스로부터 상속을 받아서, 보다 기능과 속성을 확장시키고자 한다

<div align="center">
  <img width="388" alt="스크린샷 2021-05-07 오후 1 59 02" src="https://user-images.githubusercontent.com/37537227/117399844-6443de00-af3c-11eb-89dd-63f9386c6d4f.png">
</div>

### [단일 상속 - 하위 Class가 상위 Class 1개만을 확장시킨다, Extend 시킨다]
```java
Class A {
  protected 속성1;
  protected 속성2;
  
  ...
}

Class B extends A {
  ... 
  public B {
    속성1 = "속성1";
    속성2 = "속성2";
  }
}
```
* 구조
  * 상속하는 Class A : ```상위 클래스```, ```Parent Class```, Base Class, Super Class - 보다 일반적인 기능과 개념으로 구성됌 
  * 상속받는 Class B : ```하위 클래스```, ```Child Class```, Derived Class, Subclass  - 보다 구체적인 기능과 개념으로 구성됌
* 단일 상속 (Single Inheritance)
  * ```extends``` 단위 뒤로는 클래스 1개만 가능
  * ```Interface``` 뒤에는 다수의 클래스 가능
* ```상위 클래스에서 상속받는 멤버변수```는 ```protected``` 타입, 그리고 ```상속받는 메소드```는 ```public``` 타입
  * ```protected``` 타입은 ```클래스 내부```와 ```하위 클래스```에서 사용가능하기 때문

<br>

<div align="center">
  <img width="588" alt="스크린샷 2021-05-07 오후 2 52 12" src="https://user-images.githubusercontent.com/37537227/117403850-d23fd380-af43-11eb-8d56-564fb10e53f2.png">
</div>

<br>

### [super() - 하위 클래스 Constructor에서 default로 상위 클래스 Constructor인 Super() 호출]
```java
...
  public B {
    super();
    
    속성1 = "속성1";
    속성2 = "속성2";
  }
...
```
* ```super.<메소드>``` 그리고 ```super.<멤버 변수>``` 형식으로도 사용 가능
* 상위 클래스 Constructor가 호출되면서 포함되는 멤버 변수들이 모두 호출되고 (Private 변수들도 생성된다, 접근을 못할 뿐)
* 그 다음에 하위 클래스 Constructor가 호출되면서 남은 멤버 변수들도 호출되는 형식

<br>

### [형변환 (업캐스팅)]
```java
UpperClassA upperClassA = new lowerClassB();
```
* 하위 클래스를 상위 클래스로 형변환 가능 --> 업캐스팅
* 다만, 하위 클래스 인스턴스이지만, 상위 클래스 Type으로 생성됐기 때문에, 상위 클래스 변수와 메소드만 사용할 수 있다 (제한이 걸림)
  * 하위 클래스 인스턴스이기 때문에, 하위 클래스 내용도 모두 호출 및 생성이 되었기 때문에, 하위 클래스로 형변환을 한다면 모두 사용할 수 있게 된다

<br>

### [오버라이딩 (Overriding) vs 오버로딩 (Overloading)]
```java
@Override 
public <변한 값> <함수명> (<매개변수>) {
  ...
}
```
* 오버라이딩  : ```상위 클래스```에서 정의된 함수가 ```하위 클래스```에서는 적합하지 않아서, ```같은 이름, 같은 매개변수, 같은 반환 값의 함수```를 다시 작성하는 것
  * ```@Override``` : 에노테이션으로 컴파일러에게 추가 정보를 전달해준다
* 오버로딩   : ```같은 클래스``` 내에서 ```같은 이름의 함수```들로 ```다른 조합의 매개변수```를 받을 수 있게 다수의 함수들을 작성하는 것
  * 대표 예시: 매개변수를 받지 않는 default Contructor와 매개변수를 받는 Constructor - 같은 이름이지만, 다른 조합의 매개변수를 가지고 있다

<br>

<div align="center">
  <img width="572" alt="스크린샷 2021-05-07 오후 3 37 53" src="https://user-images.githubusercontent.com/37537227/117407925-34033c00-af4a-11eb-9b5d-2349f52ed5c2.png">
</div>

<br>

* 재미있는 포인트 : 하위 클래스 인스턴스가 상위 클래스 타입으로 생성이 되었을 때, 오버로딩된 함수를 호출하면, 상위 클래스의 함수와 하위 클래스의 함수 들 중 어느 함수가 호출이 될까?
  * 정답은 ```재정의된, 오버로딩된 하위 클래스의 함수가 호출```된다. 
  * ```각 클래스 별로 가상 메소드 테이블이 존재```하는데, 하위 클래스에서 오버로딩을 하게 되면, ```같은 이름의 메소드가 가리키는 주소값이 달라```지기 때문


<br>
<hr>
<br>

## 7. 다형성 (Polymorphism)

#### 상위 클래스의 하나의 코드가 하위 클래스의 여러 자료형으로 구현되어 실행되는 것 (```오버라이딩```과 ```업캐스팅```을 통해 구현 가능)

### [함수 케이스]
```java
public void moveAnimal (Animal animal) {
  animal.move();
}
```
* 상황
  * 상위 클래스 : ```Animal```
  * 하위 클래스 : ```Human```, ```Eagle```, ```Tiger```
* 중요 포인트
  * ```moveAnimal``` 메소드가 ```Human```, ```Eagle```, ```Tiger```을 매개변수로 받는데, 타입은 상위 클래스인 ```Animal```이다
    * 기본적으로, ```업캐스팅```된 상황이다
  * 추가적으로 ```오버라이딩```이 되었기 때문에, ```animal.move()``` 메소드가 가리키는 주소값이 달라진다
    * 결과적으로, ```moveAnimal``` 메소드 하나가 ```Human```, ```Eagle```, ```Tiger```의 ```.move``` 함수를 처리할 수 있는 함수가 된다

<br>

### [ArrayList 케이스]
```java
ArrayList<Animal> animalList = new ArrayList<>();

animalList.add(new Tiger());
animalList.add(new Eagle());
animalList.add(new Human());

for(Animal animal : animalList) {
  animal.move();
}
```
* ```Human```, ```Eagle```, ```Tiger``` 모두 ```<Animal> 타입```으로 ```ArrayList```에 넣어서 사용 가능

<br>

### [다형성의 중요성]
```java
if (customerLevel == "GOLD") {
  ...
} else if (customerLevel == "SILVER") {
  ...
} else if (customerLevel == "TOP") {
  ...
}
```
* 다형성이 없다면, 위의 코드처럼 상황에 따라 다른 로직을 구축해야 할 때 if 문의 조건들이 점점 많아지는 단점이 있다
  * 따라서, 코드의 유지보수가 어려워지며, 불필요하게 복잡해질 수 있다
* 다형성이 있다면, 각 상황에 맞는 Class를 생성하여 ```각 Class에서 집중해야 하는 로직만 작성```할 수 있다는 장점이 있다
  * 보통, if 문으로 복잡하게 구축된 로직을 조금 수정하게 되면, 전체적으로 영향도가 어떻게 될지가 큰 어려움으로 다가오는데, ```나눠서 합치는 방식```을 통해 ```확장성에서 큰 이점```이 생긴 것 같다

<br>

### [IS-A 관계 vs HAS-A 관계]
* IS-A 관계
  * 상속 O 
  * 뼈대를 만들어서 상속을 통해 환장시키는 형태
  * 필요에 따라, IS-A 관계를 잘 설계해서 개발하면 큰 장점을 얻을 수 있음
* HAS-A 관계
  * 상속 X 
  * ArrayList를 통해 포함하거나 Class 내에 다른 Class를 포함하여 사용하는 형태
  * 보통, HAS-A 관계로 코딩이 작성됌


<br>
<hr>
<br>

## 8. 형변환 (다운캐스팅) 및 instanceof

#### 업캐스팅 시 접근할 수 있는 멤버변수와 메소드에 제한이 생기기 때문에, 다시 다운캐스팅해야 하는 상황도 필요

### [.java 예시 파일]
```java
Customer customerE = new GoldCustomer(20, "Edward");

if (customerE instanceof GoldCustomer) {
  GoldCustomer downCastCustomerE = (GoldCustomer)customerE;
}
```
* ```instanceof```를 통해, 형변환하기 전에 에러가 발생하지 않도록 확인하고 형변환을 진행할 수 있다
* 다만, if 문이 또 길게 발생할 수 있기 때문에, 가능하다면 다형성을 사용해서 오버라이드를 통해 로직을 작성하는 것도 중요

<br>
<hr>
<br>

## 9. 추상 클래스 (Abstract Class) 구현하기

#### ```구현부가 없는 추상 메소드```를 포함하는 클래스, ```상속을 위한``` 클래스

### [최상위 클래스]
```java
public abstract class Computer {
  public abstract void display();
  public abstract void typing();
  
  public void turnOn() {
    System.out.println("전원 키기");
  };
  
  public void turnOff() {
    System.out.println("전원 끄기");
  };
}
```

* 추상인 변수와 메소드 타입 : ```abstract```
* 추상 메소드를 포함하는 추상 클래스 : ```Computer```
  * 구현부가 없는 추상 메소드 : ```display()```, ```typing()```
  * 보통 메소드 : ```turnOn()```, ```turnOff()```
* ```abstract class```는 ```new```할 수 없다

<br>

### [하위 abstract 클래스]
```java
public abstract class Notebook extends Computer {
  @Override
  public void display() {
    System.out.println("display 키기");
  }
}
```

* 아직 정의되지 않은 추상 메소드 : ```typing()```
  * 모든 추상 메소드가 정의하지 않은 하위 클래스도 ```abstract```
* ```abstract class```는 ```new```할 수 없다

<br>

### [하위 보통 클래스]
```java
public class MyNotebook extends Notebook {
  @Override
  public void typing() {
    System.out.println("typing 키기");
  }
}
```
* 모든 추상 메소드가 정의되었을 때, ```default class```가 된다
* ```abstract class```가 아닐 때, ```default class```가 되면, ```new`` 가능


<br>
<hr>
<br>

## 10. Multi-thread 환경에서 동기화 진행, 동기화를 진행하는 시스템 함수 (semaphore?)

#### 국내 기업에서 가장 안정적으로 많이 사용되는 언어

### [.java]
```java
  ssh
  wget
  curl
  ping
  ps
```
* 명령어를 실행하면 배포 관련 안정성 체크를 하고 부족한 점들을 안내해줌

<br>
<hr>
<br>

## 10. Package, Import  언어별로 정리 필요

#### 국내 기업에서 가장 안정적으로 많이 사용되는 언어

### [.java]
```java
  ssh
  wget
  curl
  ping
  ps
```
* 명령어를 실행하면 배포 관련 안정성 체크를 하고 부족한 점들을 안내해줌

<br>
<hr>
<br>

## 11. Java 10부터 local variable inference 가능 (다만 처음에 선언한 데이터 타입에서 다른 타입으로 중간에 변환 불가능)

#### 국내 기업에서 가장 안정적으로 많이 사용되는 언어

### [.java]
```java
  ssh
  wget
  curl
  ping
  ps
```
* 명령어를 실행하면 배포 관련 안정성 체크를 하고 부족한 점들을 안내해줌

<br>
<hr>
<br>

## 12. 객체지향, POJO, 

#### 국내 기업에서 가장 안정적으로 많이 사용되는 언어

### [.java]
```java
  ssh
  wget
  curl
  ping
  ps
```
* 명령어를 실행하면 배포 관련 안정성 체크를 하고 부족한 점들을 안내해줌

<br>
<hr>
<br>

## 13. Generics

#### 국내 기업에서 가장 안정적으로 많이 사용되는 언어

### [.java]
```java
  ssh
  wget
  curl
  ping
  ps
```
* 명령어를 실행하면 배포 관련 안정성 체크를 하고 부족한 점들을 안내해줌

<br>
<hr>
<br>




