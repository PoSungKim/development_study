# Generics
> 어떠한 자료 타입도 담을 수 있는 Generic Programming  
* 어떤 자료 타입의 값이 올지 알 수 없을 때, 제너릭 타입으로 받아서 처리하는 등 유용하다

<hr>
<br>

## 일반적 사용법

#### ```T``` 제너릭 타입으로, 해당 클래스를 선언할 때 ```<Type명>```을 작성해서 주입 가능

<br>

### [GenericPrinter.java]
```java
public class GenericPrinter<T> {
  private T material;
  
  public T getMaterial() {
    return material;
  }
  
  public void setMaterial(T material) {
    this.material = material;
  }
 
  public String toString() {
    return material.toString();
  }
}
```

* ```자료형 매개변수 T (Type Parameter)```: 이 클래스를 사용하는  시점에서 실제로 사용할 자료형을 지정, static 변수는 사용할 수 없음

<br>

### [주입하지 않는 경우 - Object 타입 반환]

```java
public class GenericPointerTest {
  public static void main(String[] args) {
    Powder powder = new Powder();
    GenericPrinter genericPointer = new GenericPrinter();
    
    genericPointer.setMaterial(powder);
    
    Powder p = (Powder)genericPointer.getMaterial();
  }
}
```

* Powder p = ```(Powder)```genericPointer.getMaterial();
  * Generic을 사용하지 않으면 ```Object``` 타입을 리턴하기 때문에, ```(Powder)``` 형변환 및 다운 캐스팅이 필요

<br>

### [주입하는 경우 - 주입한 타입 반환]

```java
public class GenericPointerTest {
  public static void main(String[] args) {
    Powder powder = new Powder();
    GenericPrinter<Powder> genericPointer = new GenericPrinter();
    
    genericPointer.setMaterial(powder);
    
    Powder p = genericPointer.getMaterial();
  }
}
```

* Powder p = genericPointer.getMaterial();
  * Generic을 사용했기 때문에, GenericPrinter<Powder> genericPointer의 ```<Powder>``` 타입으로 ```GenericPrinter.java``` 의 모든 ```T``` 타입이 변경됌
  * 즉, ```형변환 없이 사용``` 할 수 있기 때문에, ```모든 타입의 자료를 받을 수 있는 Generic Programming``` 이 가능해지는 것이다
  * ```T``` 로 선언해 놓고, 실제로 사용할 <Type>을 주입해서 사용하는 방식

<br>
<hr>
<br>

## 처리할 수 있는 타입에 제한 두기
#### 모든 타입을 처리하는 것이 능사는 아닐 수 있다

<br>

### [무엇이든 담을 수 있는 generics에 제한 두기 1]
```java
public class GenericPrinter<T extends Material> {
  private T material;
  
  public T getMaterial() {
    return material;
  }
  
  public void setMaterial(T material) {
    this.material = material;
  }
 
  public String toString() {
    return material.toString();
  }
}
```

* Material Abstract Class를 생성하고, powder와 plastics가 상속을 받는다
* ```T extends Material```를 통해,
 * 하단 코드에서 형변환없이 사용할 수 있게 되고,
 * powder와 plastics만 담을 수 있게 된다

<br>

### [무엇이든 담을 수 있는 generics에 제한 두기 2]
```java
public class GenericPointerTest {
  public static void main(String[] args) {
    Powder powder = new Powder();
    
    GenericPrinter<Powder>genericPointer = new GenericPrinter<Powder>();
    genericPointer.setMaterial(powder); 
    Powder p = genericPointer.getMaterial(); // 형변환 필요없음

    GenericPrinter genericPointer = new GenericPrinter(); 가능 
    genericPointer.setMaterial(powder);
    Powder p = (Powder)genericPointer.getMaterial();
  }
}
```

<br>
<hr>
<br>

## 와일드카드 (?)
#### 하나 이상의 타입을 지정해야 하는 경우
  
<br>
  
### [사용 형태]
* ?
  * 모든 타입 가능

* ? extends 상위클래스
  * 상위클래스를 상속받는 하위 클래스들 가능
  * Interface를 상속하더라도 동일하게 `extends`

* ? super 클래스
  * 해당 클래스와 클래스의 상위 클래스들 가능
