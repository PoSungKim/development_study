# 중첩 내부 클래스 및 메모리누수
> 클래스는 내부 클래스를 가질 수 있다
* [Tecoble.TechCourse](https://tecoble.techcourse.co.kr/post/2020-11-05-nested-class/)

<hr>
<br>

## Nested Inner Class
#### Nested Inner Class = {non-static inner class, static inner class}

<br>

### [Non-static vs Static]
```java
public class Outer {

    public Outer() {
        System.out.println("Outer is created");
    }

    public class NonStaticInner {

        public NonStaticInner() {
            System.out.println("NonStaticInner is created");
        }

    }

    public static class StaticInner {

        public StaticInner() {
            System.out.println("StaticInner is created");
        }
    }
}

```

```java
public class Main {

    public static void main(String[] args) {
        testInnerAndOuterClass();
    }

    public static void testInnerAndOuterClass() {
        Outer.NonStaticInner nonStaticInner = new Outer().new NonStaticInner();
        Outer.NonStaticInner nonStaticInner2 = new Outer().new NonStaticInner();
        System.out.println(nonStaticInner == nonStaticInner2);

        Outer.StaticInner staticInner = new Outer.StaticInner();
        Outer.StaticInner staticInner2 = new Outer.StaticInner();
        System.out.println(staticInner == staticInner2);
    }
}
```
* `new Outer().new NonStaticInner()` vs `new Outer.StaticInner();`
  * Non-static Inner Class : 내부 클래스는 자신을 인스턴스화해준 외부 클래스에 대한 외부참조를 가진다
  * Static Inner Class : 내부 클래스는 인스턴스화 과정이 없기 때문에 외부참조를 가지 않는다

```bash
> Task :Main.main()
Outer is created
NonStaticInner is created
Outer is created
NonStaticInner is created
false

StaticInner is created
StaticInner is created
false
```
* NonStaticInner 클래스는 Outer 클래스가 먼저 생성된 이후에 외부참조로 내부 클래스를 생성한다
  * 둘의 참조값은 다르다 --> 당연
* StaticInner 클래스는 Outer 클래스 생성 필요없이 바로 생성된다
  * 둘의 참조값은 다르다 --> 왜?! --> 다르면 사용될 때마다 static memory에 다른 Static Inner Class가 생성된다는 의미인거 아닌가?! --> 그럼 메모리 터질텐데?! --> 이팩티브 자바에서는 static inner class를 추천한다고!? --> 더 리서치가 필요 

<br>

### [외부참조 예시]
```java
public class Outer {

    public Outer() {
        System.out.println("Outer is created");
    }

    public void outerMethod() {
        System.out.println("OuterMethod is called");
    }

    public class NonStaticInner {

        public NonStaticInner() {
            System.out.println("NonStaticInner is created");
            Outer.NonStaticInner.this.nonStaticInnerMethod();
        }

        public void nonStaticInnerMethod() {
            Outer.this.outerMethod();
        }

    }

    public static final class StaticInner {

        public StaticInner() {
            System.out.println("StaticInner is created");
        }

        public void staticInnerMethod() {
            //Outer.this.outerMethod(); # 컴파일 에러
        }
    }
}
```
* `Outer.this.outerMethod();` : this로 외부참조를 하여 호출 가능 vs 컴파일 에러 발생


<br>
<hr>
<br>

## 메모리 누수
#### Static 영역은 GC 관여 X vs Heap 영역은 GC 관여 O


<br>

### [단순 예시]
```java
public class Main {

    public static void main(String[] args) {
        testInnerAndOuterClass();
    }

    public static void testInnerAndOuterClass() {
        Outer outer = new Outer();
        Outer.NonStaticInner nonStaticInner1 = outer.new NonStaticInner();
        Outer.NonStaticInner nonStaticInner2 = outer.new NonStaticInner();
        System.out.println(nonStaticInner1 == nonStaticInner2);
    }

}
```
* outer에 담긴 instance 입장에서는 nonStaticInner1과 nonStaticInner2가 모두 GC에게 Free 당해야지 outer도 GC에게 Free 당할 수 있게 된다
  * 자신이 가지고 있는 모든 외부참조가 없고, 더 이상 사용되지 않는다면...!
  * 이렇게 굳이 외부참조가 남아 있을 수 있는 경우를 남길 가능성을 남기지 않는게 좋기에, Nested Inner Class를 생성할 때는 static으로 설계하는 것이 좋다고 한다

<br>
<hr>
<br>
