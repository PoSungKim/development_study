# 

## String, StringBuilder, StringBuffer, Textblock

#### Java - 문자열 관련 다양한 클래스 및 기능 제공

### [String 클래스]
```java
String str1 = new String("abc");
String str2 = "abc";
```
* ```new String("abc")``` : 힙 메모리에 인스턴스로 생성되서 해당 인스턴스의 주소를 참조하는 경우
* ```"abc"```             : 상수 풀 (Constant Pool)에 있는 주소를 참조하는 경우

<br>

### [String 클래스 크기 비교]
```java
String str1 = new String("abc");
String str2 = new String("abc");

System.out.println(str1 == str2); // false (인스턴스 별로 다른 주소 값)

String str3 = "abc";
String str4 = "abc";

System.out.println(str3 == str4); // true (같은 문자열은 같은 상수 풀 주소)
```

<br>

### [String 클래스 - Immutable]
```java
private final byte[] value; // new String("<문자열 내용>"); final로 선언이 되어있다 --> Immutable

String java = new String("java");
String android = new String("android");

System.out.println(System.identityHashCode(java)); // 주소값이 다름

java = java.concat(android);

System.out.println(System.identityHashCode(java)); // 주소값이 다름, Garbage Collector의 역할이 커진다
```

<br>

### [StringBuilder, StringBuffer - Mutable]
```java
String java = new String("java");
String android = new String("android");

StringBuilder buffer = new StringBuilder(java);
System.out.println(System.identityHashCode(buffer)); // 같은 인스턴스이기 때문에, 주소값이 같다

buffer.append(android);
System.out.println(System.identityHashCode(java));   // 같은 인스턴스이기 때문에, 주소값이 같다

String test = buffer.toString();
System.out.println(test);
```
* 두 클래스 공통
  * 내부적으로 가변적인 버퍼가 있어서, 문자열이 변하더라도, 새로운 인스턴스를 생성하는 것이 아니라, 기존 인스턴스의 내부 버퍼를 줄였다 늘렸다하면서 문자열을 처리한다
* 단일 스레드 : StringBuilder 사용
* 멀티 스레드 : StringBuffer 사용
  * 동기화 (Synchronization)을 보장

<br>

### [text block - java13부터]
```java
String strBlock = """
        Hello,
        hi,
        how are you""";
System.out.println(strBlock);
```
