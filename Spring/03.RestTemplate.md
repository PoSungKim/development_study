# RestTemplate 
> Server To Server 연결을 위해 사용
* 서버 간의 통신을 위한 Service를 생성해서 Controller로 Service 결과를 반환

<hr>
<br>

## 1. URI 생성

#### 다른 서버의 주소와 리소스를 정의

<br>

### [```Query Param``` 방식]

```java
// http://도메인명:포트번호/path명?name="Kim"&age=10

URI uri = UriComponentsBuilder
          .fromUriString("<http://도메인명:포트번호>")
          .path("/<path명>")
          .queryParam("키1", "값1")
          .queryParam("키2", "값2")
          .encode()
          .build()
          .toUri();

System.out.println(uri.toString());
```
* ```queryParam``` 사용

<br>

### [```Path Variable``` 방식]

```java
// http://도메인명:포트번호/path명/변수1값/변수2값

URI uri = UriComponentsBuilder
      .fromUriString("<http://도메인명:포트번호>")
      .path("path명/{변수1명}/{변수2명}")
      .encode()
      .build()
      .expand(변수1값)
      .expand(변수2값)
      .toUri();
```
* ```{변수1명}```, ```expand``` 사용

<br>
<hr>
<br>

## 2. RestTemplate 클래스

#### JS의 ```axios, fetch```처럼, Java에서도 서버 간의 통신을 가능하게 해주는 기능을 담은 클래스

<br>

### [GET 방식 - service.java]

```java
@Service
public class RestTemplateService {
    public String get() {
        URI uri = UriComponentsBuilder
                  .fromUriString("http://localhost:9090")
                  .path("/api/server")
                  .queryParam("name", "Kim")
                  .queryParam("age", 10)
                  .encode()
                  .build()
                  .toUri();

        System.out.println(uri.toString());

        RestTemplate restTemplate = new RestTemplate();

        // String result = restTemplate.getForObject(uri, String.class); // GET 방식으로 요청을
        // 보내면 Object 형태의 Response를 받고자 한다
        ResponseEntity<String> result = restTemplate.getForEntity(uri, String.class);
        System.out.println(result.getStatusCode());
        System.out.println(result.getBody());

        return result.getBody();
    }
}
```
* ```getForObject```: String, User 등 Data Type 그대로 받을 수 있는 메소드
* ```getForEntity```: Packet 형태로 메타데이터와 데이터를 받을 수 있는 메소드
* ```String``` : API 호출을 할때, 어떠한 값이 리턴될지 모를 경우, 일단 ```String``` 값으로 받아볼 수 있다
  * 예를 들어, 받은 이후에는 ```json``` 파일의 내부 내용을 스트링 값으로 확인하고 이에 맞는 DTO를 생성해서 다시 제대로 받아볼 수 있다

<br>

### [POST 방식 - service.java]

```java
@Service
public class RestTemplateService {
    public String post() {
        URI uri = UriComponentsBuilder
                .fromUriString("http://localhost:9090")
                .path("/api/server/user/{userId}/name/{userName}")
                .encode()
                .build()
                .expand(100, "kim")
                .toUri();

        System.out.println(uri.toString());
        
        // http body -> object -> object mapper -> json -> rest template -> http body json
        UserRequest req = new UserRequest();
        req.setName("kim");
        req.setAge(10);
        
        RestTemplate restTemplate = new RestTemplate();

        ResponseEntity<UserResponse> result = restTemplate.getForEntity(uri, req, UserRequest.class);
        System.out.println(result.getStatusCode());
        System.out.println(result.getHeaders());
        System.out.println(result.getBody());

       return result.getBody();
    }
}
```
* ```http body -> object -> object mapper -> json -> rest template -> http body json```
* ```postForObject```: String, User 등 Data Type 그대로 받을 수 있는 메소드
* ```postForEntity```: ```ResponseEntity``` 타입으로 헤더와 바디를 받을 수 있는 메소드

<br>

### [POST 방식 (Header 수정) - service.java]

```java
@Service
public class RestTemplateService {
    public String exchange1() {
        URI uri = UriComponentsBuilder
                .fromUriString("http://localhost:9090")
                .path("/api/server/user/{userId}/name/{userName}")
                .encode()
                .build()
                .expand(100, "kim")
                .toUri();

        System.out.println(uri.toString());
        
        UserRequest req = new UserRequest();
        req.setName("kim");
        req.setAge(10);
        
        RequestEntity<UserRequest> requestEntity = RequestEntity
                                                   .post(uri)
                                                   .contentType(MediaType.APPLICATION_JSON)
                                                   .header("x-authorization", "abcd")
                                                   .header("custom-header", "fffff")
                                                   .body(req);
        
        RestTemplate restTemplate = new RestTemplate();

        ResponseEntity<UserResponse> result = restTemplate.exchange(requestEntity, UserResponse.class); //
        System.out.println(result.getStatusCode());
        System.out.println(result.getHeaders());
        System.out.println(result.getBody());

       return result.getBody();
    }
}
```
* ```exchange```: user-defined ```RequestEntity```를 보낼 수 있는 메소드

## 3. RequestEntity - JSON 파일 내부 정리

#### 

<br>

### [JSON - 예상 내부 정보 구성]

```js
{
  "header" : {
            "response_code" : "200"
  },
  "body" : {
            "book" : "spring boot",
            "page"  : 1024
  }
}
```

<br>

### [DTO - Header와 Body 키 값 넣어주기]

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
public class Req<T> {
          private Header header;
          private T rBody;
          
          @Data
          @AllArgsConstructor
          @NoArgsConstructor
          public static class Header {
                    private String responseCode;
          }
}
```
* 제너릭 타입과 내부 클래스 활용
  * Header 내부 정보는 ```고정``` : ```static 내부 클래스```
  * Body 내부 정보는 ```변동``` : ```제너릭 T 타입```
    * ```UserRequest```와 ```UserResposne``` 클래스를 받을 수 있게 설계 가능


### [POST 방식 - JSON (고정 내용 + 변동 내용 반영 DTO)]

```java
@Service
public class RestTemplateService {
    public String exchange2() {
        URI uri = UriComponentsBuilder
                .fromUriString("http://localhost:9090")
                .path("/api/server/user/{userId}/name/{userName}")
                .encode()
                .build()
                .expand(100, "kim")
                .toUri();

        System.out.println(uri.toString());
        
        UserRequest userRequest = new UserRequest();
        userRequest.setName("kim");
        userRequest.setAge(10);
        
        Req<UserRequest> req = new Req<>();
        req.setHeader(
          new Req.Header();
        );
        
        req.setBody(
          userRequest
        );
        
        
        RequestEntity<Req<UserRequest>> requestEntity = RequestEntity
                                                   .post(uri)
                                                   .contentType(MediaType.APPLICATION_JSON)
                                                   .header("x-authorization", "abcd")
                                                   .header("custom-header", "fffff")
                                                   .body(req);
        
        RestTemplate restTemplate = new RestTemplate();

        ResponseEntity<Req<UserResponse>> result = restTemplate.exchange(requestEntity, new ParameterizedTypeReference<Req<UserResponse>>(){}); //
        System.out.println(result.getStatusCode());
        System.out.println(result.getHeaders());
        System.out.println(result.getBody());

       return result.getBody().getrBody();
    }
}
```
