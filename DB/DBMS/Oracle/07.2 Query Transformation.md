# Query Transformation
> 
* [Docs Oracle - Query Transformation](https://docs.oracle.com/en/database/oracle/oracle-database/23/tgsql/query-transformations.html#GUID-B2914447-CD6D-411C-8467-6E10E78F3DE0)

<hr>
<br>

## 쿼리 변환 대상 최소 단위
#### Query Block

<br>

### Query Block
* Type
  * Top-Level Statement
  * Subquery
  * Unmerged View
* 예시) 2 Query blocks
  * outer query block = Top-Level Statement
  * inner query block = Subquery
  ```
  SELECT first_name, last_name
  FROM   hr.employees
  WHERE  department_id 
  IN     (SELECT department_id 
          FROM   hr.departments 
          WHERE  location_id = 1800);
  ```

<br>

### Query Subplan
* For each query block, the optimizer generates a query subplan


<br>
<hr>
<br>

## Query Transformation 기법
#### 

<br>

### OR Expansion
* Concatenation
  * Union All

<br>

### View Merging
* View
  * 1개의 Inner Query Block -> 1개의 별도의 Subplan이 되어서 Suboptimal Execution Plan이 생성된다
  * Inner Query Block부터 최적화하면서 Outer Query Block으로 최적화가 이어진다
* View Mergeing
  * 1개의 Inner Query Block가 없어지고, Outer Query Block에 포함된다
    * Additional join orders and access paths available after the merge
      * 순열 (Outer Table, View) vs (Outer Table1, Outer Table2, Outer Table3)
    * View는 Index를 만들지 못하기 때문에, View에서 테이블을 분리하면, Nested Loop 조인을 인덱스에 연산시킬 수 있게 된다
  * Outer Query Block 1개의 최적화가 진행되면서, Optimal Execution Plan이 생성된다

<br>

### Predicate Pushing for Unmerged View

<br>

### Subquery Unnesting

<br>

### Pushing Subquery for Nested Subquery

<br>

### Materialized View

<br>

### Table Expansion


<br>
<hr>
<br>
