# 조인 원리와 활용
> 
* 

<hr>
<br>

## Nested Loops 조인
#### 

<br>

### 기본 메커니즘
* 중첩 루프문 (Nested Loop) 방식으로 수행된다

```sql
select /*+ ordered use_nl(b) */ e.empno, e.ename, d.danem
from   emp e, dept d
where  d.deptno = e.deptno;
```

<br>

### 힌트를 이용해 NL 조인을 제어하는 방법
* ordered : from절에 기술된 순서대로 조인하라고 옵티마이저에게 지시할 때 사용
* use_nl : NL 방식으로 조인하라고 지시할 때 사용

```sql
select /*+ ordered use_nl(e) */ *
from   dept d, emp e
where  e.deptno = d.deptno;
```

* Outer 테이블, Inner 테이블
  * 액세스 순서에 따라 명칭이 변경된다
  
  ```sql
  NESTED LOOPS
      TABLE ACCESS (FULL) OF 'DEPT' (TABLE) --> Outer / Driving
      TABLE ACCESS (FULL) OF 'EMP' (TABLE)  --> Inner / Driven

  MERGE JOIN
      SORT (JOIN)
          TABLE ACCESS (FULL) OF 'DEPT' (TABLE) --> Outer / First
      SORT (JOIN)
          TABLE ACCESS (FULL) OF 'EMP' (TABLE)  --> Inner / Second
 
  HASH JOIN
      TABLE ACCESS (FULL) OF 'DEPT' (TABLE) --> Outer / Build Input
      TABLE ACCESS (FULL) OF 'EMP' (TABLE)  --> Inner / Probe Input
  ```
  
|                   | Nested Loop 조인       | Sort Merge 조인       | Hash 조인   |
|-------------------|------------------------|-----------------------|-------------|
| 실행계획상 위쪽   | Outer(=Driving) 테이블 | Outer(=First) 테이블  | Build Input |
| 실행계획상 아래쪽 | Inner(=Driven) 테이블  | Inner(=Second) 테이블 | Probe Input |

```sql
-- ordered : from 조건절 순서대로
select /*+ ordered user_nl(B) user_nl(C) use_hash(D) */ *
from   A, B, C, D
where  ...

-- leading : from 조건절 테이블 액세스 순서 지정
select /*+ leading(C, A, D, B) user_nl(A) user_nl(D) use_hash(B) */ *
from   A, B, C, D
where  ...

-- 순서 미지정하여 옵티마이저가 판단하도록 지시
select /*+ use_nl(A, B, C, D) */ *
from   A, B, C, D
where  ...
```

<br>

### NL 조인 수행 과정 분석
```sql
select /*+ ordered use_nl(e) */ e.empno, e.ename, d.danme, e.job, e.sal
from   dept d, emp e
(1) where  e.deptno = e.deptno
(2) and    d.loc = 'SEOUL'
(3) and    d.gb = '2'
(4) and    e.sal >= 1500
order by sal desc;
```

```sql
pk_dept        : dept.deptno
dept_loc_idx   : dept.loc
pk_emp         : emp.empno
emp_deptno_idx : emp.deptno
emp_sal_idx    : emp.sal
```

* 조건비교 순서
  * (2) --> (3) --> (1) --> (4)
* 실행계획
  * 형제 (Sibling) 노드 간에는 위에서 아래로 읽는다
  * 부모-자식 (Parent-Child) 노드 간에는 안쪽에서 바깥쪽으로, 즉 자식 노드부터 읽는다
  
  ```sql
  0 SELECT STATEMENT
  1     SORT ORDER BY
  2         NESTED LOOP
  3             TABLE ACCESS BY INDEX ROWID DEPT
  4                 INDEX RANGE SCAN DEPT_LOC_IDX
  5             TABLE ACCESS BY INDEX ROWID EMP
  6                 INDEX RANGE SCAN EMP_DEPTNO_IDX
  ```
  
  <div align="center">
    <img width="50%" src="https://github.com/PoSungKim/development_study/assets/37537227/e4d75a16-2af5-40e2-9483-3ca1c7c5a118" >
  </div>

  * 실행 순서
    * DEPT_LOC_IDX 인덱스 범위 스캔 
    * 인덱스 rowid로 DEPT 테이블 액세스
    * EMP_DEPTNO_IDX 인덱스 범위 스캔
    * 인덱스 rowid로 EMP 테이블 액세스

  <div align="center">
    <img width="50%" src="https://github.com/PoSungKim/development_study/assets/37537227/03e6ea59-73a2-4c25-ab82-a8063c2e0251" >
  </div>

  * 그림으로 보는 실행 순서
    * one-plus 스캔 (그림 속 리턴 모양)
      * (11), (19), (31), (32)
    * 테이블 필터링
      * (O) : No Filter
      * (X) : Yes Filter
    * dept_loc_idx (NL 조인의 첫 번째 부하지점)
      * NL 조인에서 dept_loc_idx 인덱스를 스캔하는 양에 따라 전체 일량이 좌우됨
        * = 조건으로 비효율없이 6(5+1)건을 읽었다
        * 5번의 테이블 Random Access 발생함
    * dept (NL 조인의 두 번째 부하지점)
      * 만약 5번 중 대다수가 gb='2'을 만족하지 못하고 필터링되는 비율이 높다면 dept_loc_idx 인덱스에 gb 칼럼 추가 방안에 대해서 고려 필요
    * emp_deptno_idx (NL 조인의 세 번째 부하지점)
      * Outer 테이블인 dept 테이블에서 emp_deptno_idx로 조인 액세스가 얼마나 발생하는가이다
        * = 조건으로 3건 발생
        * emp_deptno_idx 높이가 3이면 매 건마다 그만큼 블록 I/O 발생 (버퍼 Pinning 효과를 논외로 한다면)
        * 리프 블록을 스캔하면서 추가적인 블록 I/O 추가
    * emp (NL 조인의 네 번째 부하지점)
      * 만약 7번 중 대다수가 sal>='1500'을 만족하지 못하고 필터링되는 비율이 높다면 emp_deptno_idx 인덱스에 sal 칼럼 추가 방안에 대해서 고려 필요
* OLTP 환경에서의 조인 튜닝
  * 일차적으로 NL 조인부터 고려하는 것이 올바른 순서이다
    * 각 단계의 수행 일량을 분석해 과도한 Random 액세스 발생 지점을 파악한다
    * 조인 순서 변경, 인덱스 칼럼 구성 변경, 다른 인덱스 사용 등을 통해 튜닝한다
  * 만약 NL조인이 효과적이지 못하다고 판단이 되면, Sort Merge 조인 혹은 Hash 조인을 검토한다

<br>

### NL 조인의 특징
* 1) NL조인은 Random 액세스 위주의 조인 방식
  * 오라클은 기본적으로 블록단위로 I/O 수행하며, 하나의 레코드를 얻기 위해 블록을 통째로 읽는 Random 액세스 방식은 메모리 버퍼에서 빠르게 읽더라도 비효율 존재
  * 따라서, 인덱스 구성이 완벽하더라도, 대량의 데이터를 조인할 때 매부 비효율적
* 2) 조인을 한 레코드씩 순차적으로 진행
  * 부분범위처리가 가능한 상황에서 대용량 집합이러라도 매우 극적인 응답 속도 가능
  * 먼저 액세스되는 테이블ㅇ의 처리 범위에 의해 전체 일량 결정
* 3) 인덱스 구성 전략이 특히 중요
  * 조인 칼럼에 대한 인덱스 존재 여부 및 인덱스 구성 칼럼 구성도에 따라 조인 효율이 크게 달라짐
* 종합) NL조인은 소량의 데이터를 주로 처리하거나 부분범위처리가 가능한 온라인 트랜잭션 환경에 적합한 조인 방식

<br>

### NL 조인 튜닝 실습
```sql
pk_jobs : jobs.job_id
jobs_max_sal_ix : jobs.max_salary
pk_employees : employees.employee_id
emp_job_ix : employees.job_id
emp_hiredate_ix : employees.hire_date
```
```sql
select /*+ ordered use_nl(e) index(j) index(e) */
       j.job_title, e.first_name, e.last_name
     , e.hire_date, e.salary, e.email, e.phone_number
from   jobs j, employees e
(1) where  e.job_id = j.job_id
(2) and    j.max_salary >= 1500
(3) and    j.job_type = 'A'
(4) and    e.hire_date >= to_date('19960101', 'yyyymmdd') 
```

* 조건절 비교 순서 및 사용되는 인덱스 정리
  * (2) : jobs_max_sal_ix
  * (3) : jobs 
  * (1) : emp_job_ix
  * (4) : employees

* 튜닝 사례 1) 테이블 Random Access의 비효율 확인 및 개선
  * 개선점
    * JOBS_MAX_SAL_IX 인덱스에서 발생한 Random Access 개수가 278개이고, 테이블 액세스 후 리턴된 레코드는 오직 3건
    * 즉, 불필요하게 너무 많은 테이블 액세스가 발생한 것이다 --> 1% (3/278)

  ```md
  Rows Row Source Operation
  ---- -------------------------------------------
  5    NESTED LOOPS
  3      TABLE ACCESS BY INDEX ROWID JOBS
  278      INDEX RANGE SCAN JOBS_MAX_SAL_IX
  5      TABLE ACCESS BY INDEX ROWID EMPLOYEES
  8        INDEX RANGE SCAN EMP_JOB_IX
  ```

  * 해결안
    * JOBS_MAX_SAL_IX 인덱스에 job_type 추가 --> (max_salary, job_type)
    * Index Range Scan에서 수직 탐색 조건으로 사용되면서 수평 탐색의 범위가 좁아지고 테이블 액세스 횟수도 감소

* 튜닝 사례 2) Index Range Scan의 비효율 확인 및 개선
  * 개선점
    * JOBS_MAX_SAL_IX 인덱스에서 단 3건을 리턴하지만 논리적으로 1000개의 인덱스 블록을 읽은 것을 확인할 수 있다
    * max_salary 가 인덱스 선두 칼럼인데 부등호(>=)를 사용하고 있기 때문
    * 선두 칼럼이 범위조건이면, 해당 조건에 해당하는 많은 양의 인덱스 블록을 스캔하면서, 후방 칼럼 조건 (job_type='A') 조건을 필터링했을 것이다

  ```md
  Rows Row Source Operation
  ---- -------------------------------------------
  5    NESTED LOOPS (cr=1015 pr=255 pw=0 time=...)
  3      TABLE ACCESS BY INDEX ROWID JOBS (cr=1003 pr=254 pw=0 time=...)
  3        INDEX RANGE SCAN JOBS_MAX_SAL_IX (cr=1000 pr=254 pw=0 time=...)
  3      TABLE ACCESS BY INDEX ROWID EMPLOYEES (cr=12 pr=1 pw=0 time=...)
  8        INDEX RANGE SCAN EMP_JOB_IX (cr=8 pr=0 pw=0 time=...) 
  ```

  * 해결안
    * JOBS_MAX_SAL_IX 인덱스 칼럼 순서 변경 --> (job_type, max_salary)

* 튜닝 사례 2) Index Range Scan의 비효율 확인 및 개선
  * 개선점
    * JOBS_MAX_SAL_IX 인덱스에서 단 3건을 리턴하지만 논리적으로 1000개의 인덱스 블록을 읽은 것을 확인할 수 있다
    * max_salary가 인덱스 선두 칼럼이 부등호(>=)를 사용하고 있기 때문
    * 선두 칼럼이 범위조건이면, 해당 조건에 해당하는 많은 양의 인덱스 블록을 스캔하면서, 후방 칼럼 조건 (job_type='A') 조건을 필터링했을 것이다
  * 해결안
    * JOBS_MAX_SAL_IX 인덱스 칼럼 순서 변경 --> (job_type, max_salary)

<br>

### 테이블 Prefetch

<br>

### 배치 I/O

<br>

### 버퍼 Pinning 효과
* 8i에서 나타난 버퍼 Pinning 효과
* 9i에서 버퍼 Pinning 효과
* 10g에서 버퍼 Pinning 효과
* 11g에서 버퍼 Pinning 효과
* 

<br>
<hr>
<br>
