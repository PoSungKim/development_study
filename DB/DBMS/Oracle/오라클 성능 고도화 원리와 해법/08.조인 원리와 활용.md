# 조인 원리와 활용
> 
* 

<hr>
<br>

## Nested Loops 조인
#### 

<br>

### 기본 메커니즘
* 중첩 루프문 (Nested Loop) 방식으로 수행된다

```sql
select /*+ ordered use_nl(b) */ e.empno, e.ename, d.danem
from   emp e, dept d
where  d.deptno = e.deptno;
```

<br>

### 힌트를 이용해 NL 조인을 제어하는 방법
* ordered : from절에 기술된 순서대로 조인하라고 옵티마이저에게 지시할 때 사용
* use_nl : NL 방식으로 조인하라고 지시할 때 사용

```sql
select /*+ ordered use_nl(e) */ *
from   dept d, emp e
where  e.deptno = d.deptno;
```

* Outer 테이블, Inner 테이블
  * 액세스 순서에 따라 명칭이 변경된다
  
  ```sql
  NESTED LOOPS
      TABLE ACCESS (FULL) OF 'DEPT' (TABLE) --> Outer / Driving
      TABLE ACCESS (FULL) OF 'EMP' (TABLE)  --> Inner / Driven

  MERGE JOIN
      SORT (JOIN)
          TABLE ACCESS (FULL) OF 'DEPT' (TABLE) --> Outer / First
      SORT (JOIN)
          TABLE ACCESS (FULL) OF 'EMP' (TABLE)  --> Inner / Second
 
  HASH JOIN
      TABLE ACCESS (FULL) OF 'DEPT' (TABLE) --> Outer / Build Input
      TABLE ACCESS (FULL) OF 'EMP' (TABLE)  --> Inner / Probe Input
  ```
  
|                   | Nested Loop 조인       | Sort Merge 조인       | Hash 조인   |
|-------------------|------------------------|-----------------------|-------------|
| 실행계획상 위쪽   | Outer(=Driving) 테이블 | Outer(=First) 테이블  | Build Input |
| 실행계획상 아래쪽 | Inner(=Driven) 테이블  | Inner(=Second) 테이블 | Probe Input |

```sql
-- ordered : from 조건절 순서대로
select /*+ ordered user_nl(B) user_nl(C) use_hash(D) */ *
from   A, B, C, D
where  ...

-- leading : from 조건절 테이블 액세스 순서 지정
select /*+ leading(C, A, D, B) user_nl(A) user_nl(D) use_hash(B) */ *
from   A, B, C, D
where  ...

-- 순서 미지정하여 옵티마이저가 판단하도록 지시
select /*+ use_nl(A, B, C, D) */ *
from   A, B, C, D
where  ...
```

<br>

### NL 조인 수행 과정 분석
```sql
select /*+ ordered use_nl(e) */ e.empno, e.ename, d.danme, e.job, e.sal
from   dept d, emp e
(1) where  e.deptno = e.deptno
(2) and    d.loc = 'SEOUL'
(3) and    d.gb = '2'
(4) and    e.sal >= 1500
order by sal desc;
```

```sql
pk_dept        : dept.deptno
dept_loc_idx   : dept.loc
pk_emp         : emp.empno
emp_deptno_idx : emp.deptno
emp_sal_idx    : emp.sal
```

* 조건비교 순서
  * (2) --> (3) --> (1) --> (4)
* 실행계획
  * 형제 (Sibling) 노드 간에는 위에서 아래로 읽는다
  * 부모-자식 (Parent-Child) 노드 간에는 안쪽에서 바깥쪽으로, 즉 자식 노드부터 읽는다
  
  ```sql
  0 SELECT STATEMENT
  1     SORT ORDER BY
  2         NESTED LOOP
  3             TABLE ACCESS BY INDEX ROWID DEPT
  4                 INDEX RANGE SCAN DEPT_LOC_IDX
  5             TABLE ACCESS BY INDEX ROWID EMP
  6                 INDEX RANGE SCAN EMP_DEPTNO_IDX
  ```
  
  <div align="center">
    <img width="50%" src="https://github.com/PoSungKim/development_study/assets/37537227/e4d75a16-2af5-40e2-9483-3ca1c7c5a118" >
  </div>

  * 실행 순서
    * DEPT_LOC_IDX 인덱스 범위 스캔 
    * 인덱스 rowid로 DEPT 테이블 액세스
    * EMP_DEPTNO_IDX 인덱스 범위 스캔
    * 인덱스 rowid로 EMP 테이블 액세스

  <div align="center">
    <img width="50%" src="https://github.com/PoSungKim/development_study/assets/37537227/03e6ea59-73a2-4c25-ab82-a8063c2e0251" >
  </div>

  * 그림으로 보는 실행 순서
    * one-plus 스캔 (그림 속 리턴 모양)
      * (11), (19), (31), (32)
    * 테이블 필터링
      * (O) : No Filter
      * (X) : Yes Filter
    * dept_loc_idx (NL 조인의 첫 번째 부하지점)
      * NL 조인에서 dept_loc_idx 인덱스를 스캔하는 양에 따라 전체 일량이 좌우됨
        * = 조건으로 비효율없이 6(5+1)건을 읽었다
        * 5번의 테이블 Random Access 발생함
    * dept (NL 조인의 두 번째 부하지점)
      * 만약 5번 중 대다수가 gb='2'을 만족하지 못하고 필터링되는 비율이 높다면 dept_loc_idx 인덱스에 gb 칼럼 추가 방안에 대해서 고려 필요
    * emp_deptno_idx (NL 조인의 세 번째 부하지점)
      * Outer 테이블인 dept 테이블에서 emp_deptno_idx로 조인 액세스가 얼마나 발생하는가이다
        * = 조건으로 3건 발생
        * emp_deptno_idx 높이가 3이면 매 건마다 그만큼 블록 I/O 발생 (버퍼 Pinning 효과를 논외로 한다면)
        * 리프 블록을 스캔하면서 추가적인 블록 I/O 추가
    * emp (NL 조인의 네 번째 부하지점)
      * 만약 7번 중 대다수가 sal>='1500'을 만족하지 못하고 필터링되는 비율이 높다면 emp_deptno_idx 인덱스에 sal 칼럼 추가 방안에 대해서 고려 필요
* OLTP 환경에서의 조인 튜닝
  * 일차적으로 NL 조인부터 고려하는 것이 올바른 순서이다
    * 각 단계의 수행 일량을 분석해 과도한 Random 액세스 발생 지점을 파악한다
    * 조인 순서 변경, 인덱스 칼럼 구성 변경, 다른 인덱스 사용 등을 통해 튜닝한다
  * 만약 NL조인이 효과적이지 못하다고 판단이 되면, Sort Merge 조인 혹은 Hash 조인을 검토한다
   
<br>
<hr>
<br>
