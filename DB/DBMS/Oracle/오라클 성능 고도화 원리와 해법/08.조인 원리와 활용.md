# 조인 원리와 활용
> 
* 

<hr>
<br>

## Nested Loops 조인
#### 

<br>

### 기본 메커니즘
* 중첩 루프문 (Nested Loop) 방식으로 수행된다

```sql
select /*+ ordered use_nl(b) */ e.empno, e.ename, d.danem
from   emp e, dept d
where  d.deptno = e.deptno;
```

<br>

### 힌트를 이용해 NL 조인을 제어하는 방법
* ordered : from절에 기술된 순서대로 조인하라고 옵티마이저에게 지시할 때 사용
* use_nl : NL 방식으로 조인하라고 지시할 때 사용

```sql
select /*+ ordered use_nl(e) */ *
from   dept d, emp e
where  e.deptno = d.deptno;
```

* Outer 테이블, Inner 테이블
  * 액세스 순서에 따라 명칭이 변경된다
  
  ```sql
  NESTED LOOPS
      TABLE ACCESS (FULL) OF 'DEPT' (TABLE) --> Outer / Driving
      TABLE ACCESS (FULL) OF 'EMP' (TABLE)  --> Inner / Driven

  MERGE JOIN
      SORT (JOIN)
          TABLE ACCESS (FULL) OF 'DEPT' (TABLE) --> Outer / First
      SORT (JOIN)
          TABLE ACCESS (FULL) OF 'EMP' (TABLE)  --> Inner / Second
 
  HASH JOIN
      TABLE ACCESS (FULL) OF 'DEPT' (TABLE) --> Outer / Build Input
      TABLE ACCESS (FULL) OF 'EMP' (TABLE)  --> Inner / Probe Input
  ```
  
|                   | Nested Loop 조인       | Sort Merge 조인       | Hash 조인   |
|-------------------|------------------------|-----------------------|-------------|
| 실행계획상 위쪽   | Outer(=Driving) 테이블 | Outer(=First) 테이블  | Build Input |
| 실행계획상 아래쪽 | Inner(=Driven) 테이블  | Inner(=Second) 테이블 | Probe Input |

```sql
-- ordered : from 조건절 순서대로
select /*+ ordered user_nl(B) user_nl(C) use_hash(D) */ *
from   A, B, C, D
where  ...

-- leading : from 조건절 테이블 액세스 순서 지정
select /*+ leading(C, A, D, B) user_nl(A) user_nl(D) use_hash(B) */ *
from   A, B, C, D
where  ...

-- 순서 미지정하여 옵티마이저가 판단하도록 지시
select /*+ use_nl(A, B, C, D) */ *
from   A, B, C, D
where  ...
```

<br>

### NL 조인 수행 과정 분석
```sql
select /*+ ordered use_nl(e) */ e.empno, e.ename, d.danme, e.job, e.sal
from   dept d, emp e
(1) where  e.deptno = e.deptno
(2) and    d.loc = 'SEOUL'
(3) and    d.gb = '2'
(4) and    e.sal >= 1500
order by sal desc;
```

```sql
pk_dept        : dept.deptno
dept_loc_idx   : dept.loc
pk_emp         : emp.empno
emp_deptno_idx : emp.deptno
emp_sal_idx    : emp.sal
```

* 조건비교 순서
  * (2) --> (3) --> (1) --> (4)
* 실행계획
  * 형제 (Sibling) 노드 간에는 위에서 아래로 읽는다
  * 부모-자식 (Parent-Child) 노드 간에는 안쪽에서 바깥쪽으로, 즉 자식 노드부터 읽는다
  
  ```sql
  0 SELECT STATEMENT
  1     SORT ORDER BY
  2         NESTED LOOP
  3             TABLE ACCESS BY INDEX ROWID DEPT
  4                 INDEX RANGE SCAN DEPT_LOC_IDX
  5             TABLE ACCESS BY INDEX ROWID EMP
  6                 INDEX RANGE SCAN EMP_DEPTNO_IDX
  ```
  
  <div align="center">
    <img width="50%" src="https://github.com/PoSungKim/development_study/assets/37537227/e4d75a16-2af5-40e2-9483-3ca1c7c5a118" >
  </div>

  * 실행 순서
    * DEPT_LOC_IDX 인덱스 범위 스캔 
    * 인덱스 rowid로 DEPT 테이블 액세스
    * EMP_DEPTNO_IDX 인덱스 범위 스캔
    * 인덱스 rowid로 EMP 테이블 액세스

  <div align="center">
    <img width="50%" src="https://github.com/PoSungKim/development_study/assets/37537227/03e6ea59-73a2-4c25-ab82-a8063c2e0251" >
  </div>

  * 그림으로 보는 실행 순서
    * one-plus 스캔 (그림 속 리턴 모양)
      * (11), (19), (31), (32)
    * 테이블 필터링
      * (O) : No Filter
      * (X) : Yes Filter
    * dept_loc_idx (NL 조인의 첫 번째 부하지점)
      * NL 조인에서 dept_loc_idx 인덱스를 스캔하는 양에 따라 전체 일량이 좌우됨
        * = 조건으로 비효율없이 6(5+1)건을 읽었다
        * 5번의 테이블 Random Access 발생함
    * dept (NL 조인의 두 번째 부하지점)
      * 만약 5번 중 대다수가 gb='2'을 만족하지 못하고 필터링되는 비율이 높다면 dept_loc_idx 인덱스에 gb 칼럼 추가 방안에 대해서 고려 필요
    * emp_deptno_idx (NL 조인의 세 번째 부하지점)
      * Outer 테이블인 dept 테이블에서 emp_deptno_idx로 조인 액세스가 얼마나 발생하는가이다
        * = 조건으로 3건 발생
        * emp_deptno_idx 높이가 3이면 매 건마다 그만큼 블록 I/O 발생 (버퍼 Pinning 효과를 논외로 한다면)
        * 리프 블록을 스캔하면서 추가적인 블록 I/O 추가
    * emp (NL 조인의 네 번째 부하지점)
      * 만약 7번 중 대다수가 sal>='1500'을 만족하지 못하고 필터링되는 비율이 높다면 emp_deptno_idx 인덱스에 sal 칼럼 추가 방안에 대해서 고려 필요
* OLTP 환경에서의 조인 튜닝
  * 일차적으로 NL 조인부터 고려하는 것이 올바른 순서이다
    * 각 단계의 수행 일량을 분석해 과도한 Random 액세스 발생 지점을 파악한다
    * 조인 순서 변경, 인덱스 칼럼 구성 변경, 다른 인덱스 사용 등을 통해 튜닝한다
  * 만약 NL조인이 효과적이지 못하다고 판단이 되면, Sort Merge 조인 혹은 Hash 조인을 검토한다

<br>

### NL 조인의 특징
* 1) NL조인은 Random 액세스 위주의 조인 방식
  * 오라클은 기본적으로 블록단위로 I/O 수행하며, 하나의 레코드를 얻기 위해 블록을 통째로 읽는 Random 액세스 방식은 메모리 버퍼에서 빠르게 읽더라도 비효율 존재
  * 따라서, 인덱스 구성이 완벽하더라도, 대량의 데이터를 조인할 때 매부 비효율적
* 2) 조인을 한 레코드씩 순차적으로 진행
  * 부분범위처리가 가능한 상황에서 대용량 집합이러라도 매우 극적인 응답 속도 가능
  * 먼저 액세스되는 테이블의 처리 범위에 의해 전체 일량 결정
* 3) 인덱스 구성 전략이 특히 중요
  * 조인 칼럼에 대한 인덱스 존재 여부 및 인덱스 구성 칼럼 구성도에 따라 조인 효율이 크게 달라짐
* 종합) NL조인은 소량의 데이터를 주로 처리하거나 부분범위처리가 가능한 온라인 트랜잭션 환경에 적합한 조인 방식

<br>

### NL 조인 튜닝 실습
```sql
pk_jobs : jobs.job_id
jobs_max_sal_ix : jobs.max_salary
pk_employees : employees.employee_id
emp_job_ix : employees.job_id
emp_hiredate_ix : employees.hire_date
```
```sql
select /*+ ordered use_nl(e) index(j) index(e) */
       j.job_title, e.first_name, e.last_name
     , e.hire_date, e.salary, e.email, e.phone_number
from   jobs j, employees e
(1) where  e.job_id = j.job_id
(2) and    j.max_salary >= 1500
(3) and    j.job_type = 'A'
(4) and    e.hire_date >= to_date('19960101', 'yyyymmdd') 
```

* (일반적) 조건절 비교 순서 및 사용되는 인덱스 정리
  * (2) : jobs_max_sal_ix
  * (3) : jobs 
  * (1) : emp_job_ix
  * (4) : employees
* (이례적) 조건절 비교 순서 및 사용되는 인덱스 정리 --> hint에서 특정 인덱스를 지정하지 않았기 때문, 하지만 이례적
  * (2) : jobs_max_sal_ix
  * (3) : jobs
  * (4) : emp_hiredate_ix
  * (1) : employees

* if 튜닝 사례 1) `테이블 Random Access`의 비효율 확인 및 개선
```md
Rows Row Source Operation
---- -------------------------------------------
5    NESTED LOOPS
3      TABLE ACCESS BY INDEX ROWID JOBS
278      INDEX RANGE SCAN JOBS_MAX_SAL_IX
5      TABLE ACCESS BY INDEX ROWID EMPLOYEES
8        INDEX RANGE SCAN EMP_JOB_IX
```
  * 개선점
    * JOBS_MAX_SAL_IX 인덱스에서 발생한 Random Access 개수가 278개이고, 테이블 액세스 후 리턴된 레코드는 오직 3건
    * 즉, 불필요하게 너무 많은 테이블 액세스가 발생한 것이다 --> 1% (3/278)
  * 해결안
    * JOBS_MAX_SAL_IX 인덱스에 job_type 추가 --> (max_salary, job_type)
    * Index Range Scan에서 수직 탐색 조건으로 사용되면서 수평 탐색의 범위가 좁아지고 테이블 액세스 횟수도 감소

* if 튜닝 사례 2) `Index Range Scan`의 비효율 확인 및 개선
```md
Rows Row Source Operation
---- -------------------------------------------
5    NESTED LOOPS (cr=1015 pr=255 pw=0 time=...)
3      TABLE ACCESS BY INDEX ROWID JOBS (cr=1003 pr=254 pw=0 time=...)
3        INDEX RANGE SCAN JOBS_MAX_SAL_IX (cr=1000 pr=254 pw=0 time=...)
3      TABLE ACCESS BY INDEX ROWID EMPLOYEES (cr=12 pr=1 pw=0 time=...)
8        INDEX RANGE SCAN EMP_JOB_IX (cr=8 pr=0 pw=0 time=...) 
```
  * 개선점
    * JOBS_MAX_SAL_IX 인덱스에서 단 3건을 리턴하지만 논리적으로 1000개의 인덱스 블록을 읽은 것을 확인할 수 있다
    * max_salary 가 인덱스 선두 칼럼인데 부등호(>=)를 사용하고 있기 때문
    * 선두 칼럼이 범위조건이면, 해당 조건에 해당하는 많은 양의 인덱스 블록을 스캔하면서, 후방 칼럼 조건 (job_type='A') 조건을 필터링했을 것이다
  * 해결안
    * JOBS_MAX_SAL_IX 인덱스 칼럼 순서 변경 --> (job_type, max_salary)

* if 튜닝 사례 3) `조인 순서`의 비효율 확인 및 개선
```md
Rows Row Source Operation
---- -------------------------------------------
5    NESTED LOOPS (cr=2732 pr=386 pw=0 time=...)
1278   TABLE ACCESS BY INDEX ROWID JOBS (cr=166 pr=2 pw=0 time=...)
1278     INDEX RANGE SCAN JOBS_MAX_SAL_IX (cr=4 pr=0 pw=0 time=...)
5      TABLE ACCESS BY INDEX ROWID EMPLOYEES (cr=2566 pr=384 pw=0 time=...)
8        INDEX RANGE SCAN EMP_JOB_IX (cr=2558 pr=383 pw=0 time=...) 
```
  * 개선점
    * 1278번의 조인 시도를 했지만, 오직 5건의 결과집합만 생성된 부분이 비효율적이다
    * NL조인은 먼저 액세스되는 테이블의 처리 범위에 의해 전체 일량이 결정되는 특징이 있기 때문
  * 해결안
    * 테이블 조인순서 변경 --> 선 employees 탐색 후 jobs 조인
    * 다만, 상단의 5건 리턴은 오직 hire_date만 고려한 것이 아니라, (job_id, hire_date) 이렇게 2건의 칼럼이 고려된 레코드가 5건이라는 의미이기 때문에, 순서 변경 후에 hire_date만 고려되면 리턴 레코드 수가 훨씬 높을 수가 있기 때문에, 실제로 돌려보고 나서 확인해야 한다

<br>

### 테이블 Prefetch
* Prefetch : 디스크 I/O 수행 비용이 높기 때문에 한 번 I/O Call이 필요한 시점에 곧이어 읽을 가능성이 큰 블록들을 캐시에 미리 적재해두는 기능
  * db file sequential read --> db file parallel reads
  * 한 번의 I/O Call로서 여러 Single Block I/O 동시 수행
* 인덱스 rowid에 의한 Inner 테이블 액세스가 Nested Loops 위쪽에 표시되곤 하는데, 이는 해당 테이블 액세스 단계에 Prefetch 기능이 적용되었음을 표현하기 위함이다
* 새로운 포맷의 실행계획이 나타날 수 있는 경우
  * Inner 쪽 Non-Unique 인덱스를 Range Scan할 때는 테이블 Prefetch 실행계획이 항상 나타난다
  * Inner 쪽 Unique 인덱스를 Non-Unique 조건 (모든 인덱스 구성칼럼이 = 조건이 아닐 때)으로 Range Scan할 대도 테이블 Prefetch 실행계획이 항상 나타난다
  * Inner 쪽 Unique 인덱스를 Unique 조건 (모든 인덱스 구성칼럼이 = 조건)으로 액세스할 때도 테이블 Prefetch 실행계획이 나타날 수 있다. 이때 인덱스는 Range Scan으로 액세스한다. 테이블 Prefetch 실행계획이 안 나타날 때는 Unique Scan으로 액세스한다. 

```sql
select * from dept d, emp e where e.deptno = d.deptno

-- Prefetch 기능 활성화되어 있을 때
EXECUTION PLAN
-------------------------------------------------------
SELECT STATEMENT
  TABLE ACCESS (BY INDEX ROWID) OF 'EMP' (TABLE)
    NESTED LOOPS
      TABLE ACCESS (FULL) OF 'DEPT' (TABLE)
      INDEX (RANGE SCAN) OF 'EMP_DEPTNO_IDX' (INDEX)

-- Prefetch 기능 비활성화되어 있을 때 (_table_lookup_prefetch_size = 0)
EXECUTION PLAN
-------------------------------------------------------
SELECT STATEMENT
  NESTED LOOPS
    TABLE ACCESS (FULL) OF 'DEPT' (TABLE)
    TABLE ACCESS (BY INDEX ROWID) OF 'EMP' (TABLE)
      INDEX (RANGE SCAN) OF 'EMP_DEPTNO_IDX' (INDEX)
```

<br>

### 배치 I/O
* Inner 쪽 인덱스만으로 조인(id=2)을 하고 나서 테이블과의 조인(id=1)은 나중에 일괄(batch) 처리하는 메커니즘인 것으로 추정한다
  * Outer 테이블로부터 액세스되는 Inner 쪽 테이블 블록에 대한 디스크 I/O Call 횟수를 줄이기 위해, 테이블 Prefetch에 이어 추가로 도입된 메커니즘

```sql
EXECUTION PLAN
-------------------------------------------------------
0   SELECT STATEMENT
1 0   NESTED LOOPS
2 1     NESTED LOOPS
3 2       TABLE ACCESS (BY INDEX ROWID) OF 'EMP' (TABLE)
4 2       INDEX (UNIQUE SCAN) OF 'PK_DEPT' (INDEX (UNIQUE))
5 1   TABLE ACCESS (BY INDEX ROWID) OF 'DEPT' (TABLE)
```

<br>

### 버퍼 Pinning 효과
* 버퍼 Pinning : 버퍼를 읽고 나서 버퍼 Pin (버퍼 Lock)을 즉각 해제하지 않고, 데이터베이스 Call이 진행되는 동안 유지하는 기능
* 8i에서 나타난 버퍼 Pinning 효과
  * 테이블 블록에 대한 버퍼 Pinning 기능이 작동하기 시작
    * 단, 하나의 버퍼 블록만 Pinning하고, 하나의 Fetch Call을 완료하는 순간 Pin 해제
  * NL 조인에서 Non-Unique 조건으로 Inner 쪽 테이블을 액세스할 때도 똑같이 작용한다
    * Inner 쪽 인덱스를 통해 액세스되는 테이블 블록이 계속 같은 블록을 가리키면 논리 I/O (=CR Gets)가 추가로
  * 중요) 하나의 Outer 레코드에 대한 Inner 쪽과의 조인을 마치고 다른 레코드를 읽기 위해 Outer 쪽으로 돌아오는 순간 Pin을 해제한다
* 9i에서 버퍼 Pinning 효과
  * Inner 쪽 인덱스 루트 블록에 대한 버퍼 Pinning 효과가 나타나기 시작
    * 두 번째 액세스되는 순간 Pinning 한다
* 10g에서 버퍼 Pinning 효과
  * Inner 쪽 테이블을 Index Range Scan을 거쳐 NL 조인 위쪽엥서 액세스할 때는, 하나의 Outer 레코드에 대한 Inner 쪽과의 조인을 마치고 Outer 쪽으로 돌아오더라도 테이블 블록에 대한 Pinning 상태를 유지한다
  ```sql
  select /*+ ordered use_nl(d) */ count(e.ename), count(d.dname)
  from   t_emp e, dept d
  where  d.deptno = e.deptno;
  ```
  * Inner Table의 Unique 인덱스에 대한 Unique Scan 1건 조회 예시)
    * Inner쪽 인덱스(dept_pk)로 140만 번 액세스가 일어났는데, 논리적인 블록 I/O는 고작 2회뿐
      * dept 테이블이 4건짜리 테이블이기 때문에, 인덱스 루트 블록이 곧 리프 블록이기 때문
    * 테이블 블록은 Inner 쪽을 액세스할 때마다 한 건씩만 읽고 Outer 쪽으로 돌아가므로 테이블 블록에는 Pinning 효과가 나타나지 않았다
    * 따라서, 140만 번 액세스하는 동안 고스란히 140만번 블록 I/O 발생
  ```md  
  Rows      Row Source Operation
  ----      -------------------------------------------
  1         SORT AGGREGATE (cr=1409213 pr=0 pw=0 time=...)
  14000000    NESTED LOOPS (cr=1409213 pr=0 pw=0 time=...)
  14000000      TABLE ACCESS FULL T_EMP (cr=9211 pr=0 pw=0 time=...)
  14000000      TABLE ACCESS BY INDEX ROWID DEPT (cr=1400002 pr=0 pw=0 time=...)
  14000000        INDEX UNIQUE SCAN DEPT_PK (cr=2 pr=0 pw=0 time=...) 
  ```
  * Inner Table의 Unique 인덱스에 대한 Range Scan 다건 조회 예시)
    * 테이블 액세스가 NESTED LOOPS, 즉 NL 조인 위쪽에 위치한다
    * dept 테이블 블록은 단 하나뿐이다. 즉 140만개 레코드를 모두 처리하는 동안 버퍼 Pinnning 상태가 유지됨으로써 블록 I/O는 단 1(=9214 - 9213)회 발생했다
    * 인덱스 루트 블록도 Pinning되었다 (INDEX UNIQUE SCAN DEPT_PK (cr=2 ...)
  ```sql
  select /*+ ordered use_nl(d) */ count(e.ename), count(d.dname)
  from   t_emp e, dept d
  where  d.deptno between e.deptno and e.deptno + 1
  ```
  ```md  
  Rows      Row Source Operation
  ----      -------------------------------------------
  1         SORT AGGREGATE (cr=9214 pr=0 pw=0 time=...)
  14000000    TABLE ACCESS BY INDEX ROWID DEPT (cr=9214 pr=0 pw=0 time=...)
  14000000      NESTED LOOPS (cr=9213 pr=0 pw=0 time=...)
  14000000      TABLE ACCESS FULL T_EMP (cr=9211 pr=0 pw=0 time=...)
  14000000        INDEX UNIQUE SCAN DEPT_PK (cr=2 pr=0 pw=0 time=...) 
  ```
* 11g에서 버퍼 Pinning 효과
  * NL조인에서 Inner 쪽 루트 아래 인덱스 블록들도 Pinning하기 시작했다
  * 배치 I/O 예시)
  ```sql
  select /*+ ordered use_nl_with_index(d) nlj_batching(d) */
         count(e.ename), count(d.dname)
  from   t_emp e, dept d
  where  d.no = e.no
  and    d.deptno = e.deptno
  ```
  ```md  
  Rows   Row Source Operation
  ----   -------------------------------------------
  1      SORT AGGREGATE
  14000    NESTED LOOPS
  14000      NESTED LOOPS 
  14000        TABLE ACCESS FULL T_EMP
  14000          INDEX UNIQUE SCAN T_DEPT_PK
  14000      TABLE ACCESS BY INDEX ROWID T_DEPT
  ```
  * 테이블 Prefetch 예시)
  ```sql
  select /*+ ordered use_nl_with_index(d) nlj_prefetch(d) */
         count(e.ename), count(d.dname)
  from   t_emp e, dept d
  where  d.no = e.no
  and    d.deptno = e.deptno
  ```
  ```md  
  Rows   Row Source Operation
  ----   -------------------------------------------
  1      SORT AGGREGATE
  14000    TABLE ACCESS BY INDEX ROWID T_DEPT
  28001      NESTED LOOPS
  14000        TABLE ACCESS FULL T_EMP
  14000        INDEX UNIQUE SCAN T_DEPT_PK
  ```
  
<br>
<hr>
<br>

## 소트 머지 조인
#### NL 조인을 효과적으로 수행하기 위해서는 조인 칼럼에 인덱스 필요
#### 만약, 적절한 인덱스가 없다면 Inner 테이블을 탐색할 때마다 Full Scan이 반복적으로 수행된다
#### 이러한 비효율적인 상황에서 옵티마이저는 Sort Merge 조인이나 Hash 조인을 고려한다

<br>

### 기본 메커니즘
* Sort Merge Join = {소트 단계, 머지 단계}
  * 소트 단계 : 양쪽 집합을 조인 칼럼 기준으로 정렬
  * 머지 단계 : 정렬된 양쪽 집합을 서로 머지
* Outer 루프와 Inner 루프는 Sort Area에 미리 정렬해 둔 자료구조를 이용한다는 점만 다르다
  * Sort Area는 PGA 영역에 활당되므로 SGA를 경유해 인덱스와 테이블을 액세스할 때보다 훨씬 빠르다
    * PGA는 프로세스만을 위한 독립적인 메모리 공간이어서 데이터를 읽을 때 래치 획득 과정이 없기 때문
* use_merge : sort merge 조인 힌트
  * Outer(=First) 테이블인 dept를 deptno 기준으로 정렬한다
  * Inner(=Second) 테이블인 emp를 deptno 기준으로 정렬한다
  * Sort Area에 정렬된 dept 테이블을 스캔하면서, 정렬된 emp 테이블과 조인한다
  ```sql
  select /*+ ordered use_merge(e) */ d.deptno, d.dname, e.empno, e.ename
  from   dept d, emp e
  where  d.deptno = e.deptno  
  ```
* 1:M (Inner : Outer)
  * Inner(=Second) 테이블이 정렬되어 있기 때문에, Outer(=First) 테이블에서 조인 칼럼을 변경할 때마다 다른 값을 Inner(=Second)에서 마지막으로 스캔하다가 멈춘 지점을 기억했다가 다시 해당 지점에서부터 스캔을 이어나가면 된다

<div align="center">
  <img width="50%" src="https://github.com/PoSungKim/development_study/assets/37537227/f4db8abc-2d06-4b20-bf75-9f2958b6087c" >
</div>

* M:M (Inner : Outer)
<div align="center">
  <img width="50%" src="https://github.com/PoSungKim/development_study/assets/37537227/be4cf9e6-dd12-4c17-8a5d-f1a008e78a51" >
</div>

<br>

### 소트 머지 조인의 특징
* 특징 1) 소트 머지 조인은 조인을 위해 실시간으로 인덱스를 생성하는 것과 다름없다
  * 양쪽 집합을 정렬한 다음에는 NL 조인과 같은 방식으로 진행하지만 PGA 영역에 저장된 데이터를 이용하기 때문에 빠르다
  * 소트 부하만 감수한다면, 건건이 버퍼 캐시를 거치면서 조인하는 NL조인보다 유리
    * (요즘은 버퍼 Pinning 기능이 점점 확대되고 있어서 NL조인이 조금씩 유리해지는 중)
* 특징 2) 인덱스 유무에 따라 영향을 받지 않는다 (NL 조인은 인덱스 유무에 따라 크게 영향을 받는다)
  * 양쪽 집합을 개별적으로 읽고 나서 조인한다
  * 조인 칼럼에 인덱스가 없는 상황에서 두 테이블을 독립적으로 읽어 조인 대상 집합을 줄일 수 있을 때 아주 유리하다
* 특징 3) 스캔 (Scan) 위주의 액세스 방식을 사용한다
  * 다만, 양쪽 소스 집합에서 정렬 대상 레코드를 찾는 작업만큼은 인덱스를 이용해 Random 액세스 방식으로 처리될 수 있고, 이때 발생하는 Random 액세스량이 많다면 소트 머지 조인의 이점이 사라질 수 있다 (해시 조인도 마찬가지)
  * 예시) `d.loc = 'CHICAGO' && e.job = 'SALESMAN'` 조건에 부합하는 레코드를 찾을 때 인덱스 사용 가능
  ```sql
  select /*+ use_merge(d e) */ d.deptno, d.dname, e.empno, e.ename
  from   dept d, emp e
  where  d.deptno = e.deptno
  and    d.loc = 'CHICAGO'
  and    e.job = 'SALESMAN';
  ```
* 소트 머지 조인의 유리한 상황
  * First 테이블에 소트 연산을 대체할 인덱스가 있을 때
  * 조인할 First 집합이 이미 정렬돼 있을 때
  * 조인 조건식이 등치(=) 조건이 아닐 때

<br>

### First 테이블에 소트 연산을 대체할 인덱스가 있을 때
* First 테이블만 정렬 생략 가능
  * 각 테이블의 인덱스는 모두 조건절에 맞춰서 (d.loc = 'CHICAGO' or e.job = 'SALESMAN') 레코드를 조회해보면 조인 칼럼인 deptno로 이미 정렬이 완료되어 있다
  * 다만, 실행계획을 보면, DEPT 테이블만 SORT JOIN 오퍼레이션을 생략했는데, 이는 First Table만 생략이 가능하기 때문이다
  * 다행히, EMP 테이블에 대한 SORT JOIN 연산이 실행되도 이미 정렬이 되어 있기 때문에 부하가 크지 않다
* ORDER BY 정렬 생략 가능
  * MERGE JOIN 연산 후 결과집합은 이미 deptno 기준으로 정렬되어 있기 때문에, order by를 위한 추가 Sort 오퍼레이션도 생략되었다
* 항상 First Table만 먼저 읽지 않는다
  * 아래의 경우, 이미 정렬된 인덱스가 First Table이 가지고 있기 때문에, Second Table을 먼저 읽어서 PGA의 SORT AREA에 담고나서, dept_idx를 통해 First Table을 읽은 이후에, SORT AREA에 담긴 정렬된 emp 테이블을 탐색하면서 조인한다

```sql
create index dept_idx on dept(loc, deptno);
create index emp_idx on emp(job, deptno);

select /*+ ordered use_merge(e) */ *
from   dept d, emp e
where  d.deptno = e.deptno
and    d.loc = 'CHICAGO'
and    e.job = 'SALESMAN'
order by e.deptno;
```
```md
Id     Row Source Operation
----   -------------------------------------------
0      SELECT STATEMENT
1        MERGE JOIN
2          TABLE ACCESS BY INDEX ROWID DEPT
3            INDEX RANGE SCAN DEPT_IDX
4          SORT JOIN
4            TABLE ACCESS BY INDEX ROWID EMP
5              INDEX RANGE SCAN EMP_IDX
```
* 소트 머지 조인에서의 부분범위 처리 활용
  * Second 테이블은 항상 정렬을 수행하므로 전체범위처리가 불가피하지만 First 테이블만큼은 중간에 읽다가 멈출 수 있다

<div align="center">
  <img width="50%" src="https://github.com/PoSungKim/development_study/assets/37537227/d2fd23e4-d9fc-40c3-b49e-d14b9a9491db" >
</div>

  * 작은 dept 테이블이 First 테이블이 되도록 소트 머지 조인한 예시)
    * 큰 t_emp 테이블에서 정렬이 발생하면서 비효율 발생
  ```sql
  select /*+ leading(d) use_merge(e) full(d) full(e) */ *
  from   t_emp e, dept d
  where  d.deptno = e.deptno;
  ```
  ```md
  Rows   Row Source Operation
  ----   -------------------------------------------
  11     MERGE JOIN
  1        SORT JOIN
  4          TABLE ACCESS FULL DEPT
  11       SORT JOIN (cr=9204 pr=27631 pw=28869 time=18962638 us)
  1400000    TABLE ACCESS FULL T_EMP
  ```
  
  * 큰 t_emp 테이블이 First 테이블이 되도록 소트 머지 조인한 예시)
    * t_emp
  ```sql
  select /*+ ordered use_merge(d) full(d) index(e t_emp_idx) */ *
  from   t_emp e, dept d
  where  d.deptno = e.deptno;
  ```
  ```md
  Rows   Row Source Operation
  ----   -------------------------------------------
  11     MERGE JOIN
  11       TABLE ACCESS BY INDEX ROWID T_EMP (cr=6 pr=5 pw=0 time=32343 us)
  11         INDEX FULL SCAN T_EMP_IDX
  11       SORT JOIN
  4          TABLE ACCESS FULL DEPT
  ```

<br>

### 조인할 First 집합이 이미 정렬돼 있을 때
* 소트 머지 조인할 때, First쪽 집합이 조인 칼럼 기준으로 이미 정렬된 상태일 수 있다
  * group by, order by, distinct 연산 등을 먼저 수행한 경우인데, 그때는 조인을 위해 다시 정렬하지 않아도 되므로 소트 머지 조인이 유리
* First 집합만 소트 연산 생략 가능하며, Second 집합은 정렬되어 있더라도 Sort Join 연산이 수행된다
* First 집합이 이미 정렬되어 있는 예시 1)
  * Hash Group By 연산이 발생해서 Sort Join 연산 발생
```sql
select /*+ ordered use_merge(d) */ d.deptno, d.dname, e.avg_sal
from   (select deptno, avg(sal) avg_sal from emp group by deptno) e
       , dept d
where  e.deptno = d.deptno;
```
```md
Id     Row Source Operation
----   -------------------------------------------
0      SELECT STATEMENT
1        MERGE JOIN
2          SORT JOIN
3            VIEW
4              HASH GROUP BY
5                TABLE ACCESS FULL EMP
6          SORT JOIN
7            TABLE ACCESS FULL DEPT
```
* First 집합이 이미 정렬되어 있는 예시 2)
  * 인라인 뷰에 order by 절을 명시하여 Sort Group By 연산을 유도하면서 Sort Join 연산 생략
```sql
select /*+ ordered use_merge(d) */ d.deptno, d.dname, e.avg_sal
from   (select deptno, avg(sal) avg_sal from emp group by deptno order by deptno) e
       , dept d
where  e.deptno = d.deptno;
```
```md
Id     Row Source Operation
----   -------------------------------------------
0      SELECT STATEMENT
1        MERGE JOIN
2          VIEW
3            SORT GROUP BY
4              TABLE ACCESS FULL EMP
6          SORT JOIN
7            TABLE ACCESS FULL DEPT
```
* Second 집합이 이미 정렬되어 있는 예시 3)
  * Second 집합이기 때문에, Sort Group By 연산 후 Sort Join 연산도 발생
```sql
select /*+ ordered use_merge(e) */ d.deptno, d.dname, e.avg_sal
from   dept d
       , (select deptno, avg(sal) avg_sal from emp group by deptno order by deptno) e
where  e.deptno = d.deptno;
```
```md
Id     Row Source Operation
----   -------------------------------------------
0      SELECT STATEMENT
1        MERGE JOIN
2          SORT JOIN
3            TABLE ACCESS FULL DEPT
5          SORT JOIN
6            VIEW
7              SORT GROUP BY
8                TABLE ACCESS FULL EMP
```

<br>

### 조인 조건식이 등치(=) 조건이 아닐 때
```sql
select /*+ ordered use_merge(e) */ d.deptno, d.dname, e.empno, e.ename
from   dept d, emp e
where  d.deptno <= e.deptno;
```
```md
Id     Row Source Operation
----   -------------------------------------------
0      SELECT STATEMENT
1        MERGE JOIN
2          SORT JOIN
3            TABLE ACCESS FULL DEPT
5          SORT JOIN
6            TABLE ACCESS FULL EMP
```

<div align="center">
  <img width="50%" src="https://github.com/PoSungKim/development_study/assets/37537227/48af6e60-39bd-45ba-abdd-db4606e265b2" >
</div>

* default로 deptno 기준으로 오름차순(ASC) 정렬이 된다
  * 따라서, 오름차순 order by절을 추가하더라도 sort order by 오퍼레이션이 나타나지 않는다
  * 또한, 내림차순 (DESC) order by절을 추가하면 sort order by 오퍼레이션이 나타난다

```sql
select /*+ ordered use_merge(e) */ d.deptno, d.dname, e.empno, e.ename
from   dept d, emp e
where  d.deptno >= e.deptno;
```
```md
Id     Row Source Operation
----   -------------------------------------------
0      SELECT STATEMENT
1        MERGE JOIN
2          SORT JOIN
3            TABLE ACCESS FULL DEPT
5          SORT JOIN
6            TABLE ACCESS FULL EMP
```

<div align="center">
  <img width="50%" src="https://github.com/PoSungKim/development_study/assets/37537227/48af6e60-39bd-45ba-abdd-db4606e265b2" >
</div>

* default로 deptno 기준으로 내림차순(DSC) 정렬이 된다
  * 따라서, 내림차순 order by절을 추가하더라도 sort order by 오퍼레이션이 나타나지 않는다
  * 또한, 오름차순 (ASC) order by절을 추가하면 sort order by 오퍼레이션이 나타난다

```sql
select /*+ ordered use_merge(e) */ d.deptno, d.dname, e.empno, e.ename
from   dept d, emp e
where  d.deptno >= e.deptno;
order by d.deptno asc
```
```md
Id     Row Source Operation
----   -------------------------------------------
0      SELECT STATEMENT
1        SORT ORDER BY
2          MERGE JOIN
3            SORT JOIN
4              TABLE ACCESS FULL DEPT
5            SORT JOIN
6              TABLE ACCESS FULL EMP
```

<br>
<hr>
<br>

## 해시 조인
#### Sort Merge 조인과 Nested Loop 조인이 효과적이지 못할 때 대안으로서 Hash 조인이 개발됨

<br>

### 기본 메커니즘

<div align="center">
  <img width="80%" src="https://github.com/PoSungKim/development_study/assets/37537227/6f418ea4-e42a-4665-899c-6372e1a28359" >
</div>

* 둘 중 작은 집합(Build Input)을 읽어 Hash Area에 해시 테이블을 생성하고, 반대쪽 큰 집합(Probe Input)을 읽어 해시 테이블을 탐색하면서 조인하는 방식
* 해시 테이블을 생성할 때 해시 함수를 사용한다; 즉, 해시 함수에서 리턴받은 버킷 주소로 찾아가 해시 체인에 엔트리를 연결한다
* 해시 테이블을 탐색할 때도 해시 함수를 사용한다; 즉, 해시 함수에서 리턴받은 버킷 주소로 찾아가 해시 체인을 스캔하면서 데이터를 찾는다
* 해시 조인은 NL 조인처럼 조인 과정에서 발생하는 Random 액세스 부하가 없고, 소트 머지 조인처럼 조인 전에 미리 양쪽 집합을 정렬하는 부담도 없다
* 다만, 해시 테이블을 생성하는 비용이 수반되기 때문에, Build Input이 작을 때 효과적이다

```sql
create cluster h# ( bucket number ) hashkeys 16
hash is mod(bucket, 16);

create table dept_hashtable ( bucket number, deptno number(2), dname varchar2(14) )
cluster h# (bucket);

insert into dept_hashtable
select mod(deptno, 16) bucket, deptno, dname from dept;

declare
  l_bucket number;
begin
  for outer in (select deptno, empno, rpad(ename, 10) ename from emp)
  loop -- outer 루프
    l_bucket := mod(outer.deptno, 16);
    for inner in (select deptno, dname from dept_hashtable
                  where  bucket = l_bucket
                  and    deptno = outer.deptno)
    loop
      dbms_output.put_line(outer.empno||' : '||outer.ename||inner.dname);
    end loop
  end loop;
end;
```

* 해시 테이블을 만드는 단계는 전체범위처리가 불가피하지만 반대쪽 Probe Input을 스캔하는 단계는 NL조인처럼 부분범위처리가 가능하다
* 해시 조인이 인덱스 기반의 NL 조인보다 빠른 결정적인 이유는, 해시 테이블이 PGA 영역에 할당된다는 데에 있다
* NL 조인은 Outer 테이블에서 읽히는 레코드마다 Inner쪽 테이블 버퍼 캐시 탐색을 위해 래치 획득을 반복하지만, 해시 조인은 래치 획득 과정 없이 PGA에서 빠르게 데이터를 탐색한다

<br>

### 힌트를 이용한 조인 순서 및 Build Input 조정
* HASH JOIN(id=1) 자식 노드 중 위쪽 (dept)이 Build Input이고, 아래쪽 (emp)이 Probe Input이다
  * 옵티마이저는 dept 테이블이 선택된 이유는 통계정보상 더 작은 테이블이기 때문
```sql
select /*+ use_hash(d e) */ d.deptno, d.dname, e.empno, e.ename
from   dept d, emp e
where  d.deptno = e.deptno;
```
```md
Id     Row Source Operation
----   -------------------------------------------
0      SELECT STATEMENT
1        HASH JOIN
2          TABLE ACCESS FULL DEPT
3          TABLE ACCESS FULL EMP
```
* Build Input을 직접 선택할 때, `swap_join_inputs` 사용; 만약, 단 2개의 테이블만 존재한다면, `ordered`나 `leading` 힌트 사용 가능
```sql
select /*+ use_hash(d e) swap_join_inputs(e) */ d.deptno, d.dname, e.empno, e.ename ...
select /*+ leading(e) use_hash(d) */ d.deptno, d.dname, e.empno, e.ename ...
```
```md
Id     Row Source Operation
----   -------------------------------------------
0      SELECT STATEMENT
1        HASH JOIN
2          TABLE ACCESS FULL EMP
3          TABLE ACCESS FULL DEPT
```

<br>

### 두 가지 해시 조인 알고리즘
* 첫 번째 알고리즘
  * HASH JOIN 결과물이 다시 Build Input이 되는 패턴
```md
Id     Row Source Operation
----   -------------------------------------------
0      SELECT STATEMENT
1        HASH JOIN
2          HASH JOIN
3            HASH JOIN
4              HASH JOIN
5                TABLE ACCESS FULL REGIONS
6                INDEX FULL SCAN COUNTRY_C_ID_PK
7              TABLE ACCESS FULL LOCATIONS
8            TABLE ACCESS FULL DEPARTMENTS
9          TABLE ACCESS FULL EMPLOYEES
```
 
* 두 번째 알고리즘
  * HASH JOIN 결과물이 Probe Input이 되고, 다음 HASH JOIN 대상 테이블이 Build Input이 되는 패턴
```md
Id     Row Source Operation
----   -------------------------------------------
0      SELECT STATEMENT
1        HASH JOIN
2          TABLE ACCESS FULL EMPLOYEES
3            HASH JOIN
4              TABLE ACCESS FULL DEPARTMENTS
5                HASH JOIN
6                  TABLE ACCESS FULL LOCATIONS
7                  HASH JOIN
8                    TABLE ACCESS FULL REGIONS
9                    INDEX FULL SCAN COUNTRY_C_ID_PK
```

<br>

### Build Input이 Hash Area를 초과할 때 처리 방식
* 해시 조인은 해시 테이블이 Hash Area에 담을 수 있을 정도 크기의 Build Input일 때 효과적이다
* 하지만, In-Memory 해시 조인이 불가능할 때, 오라클은 다음의 조인 알고리즘을 사용한다
* Grace 해시 조인 (분할, 정복 - Divide & Conquer 방식)
  * 파티션 단계
  * 조인 단계 
* Hybrid 해시 조인
* Recursive 해시 조인(=Nested-loops 해시 조인)
* 비트-벡터 필터링

<br>

### Build Input 해시 키 값에 중복이 많을 때 발생하는 비효율
* Build Input의 해시 키 칼럼에는 중복 값이 (거의) 없어야 해시 조인이 빠르게 수행될 수 있다
  * 해시 버킷을 아무리 빨리 찾더라도 해시 버킷을 스캔하는 단계에서 많은 시간을 허비하기 때문에 탐색 속도가 현저히 저하된다
* 해시 조인 해시 키는 = 조인 칼럼인 (상품번호, 체결일자)이다
  * 입력값으로 받았기 때문에 해시 버킷은 단 하나만 생성되고, 체인으로 연결될 특정상품의 하루 체결건수는 평균적으로 수 천 건이다
  * `o.주문접수번호 in (t.매도주문접수번호, t.매수주문접수번호);`이 부분이 = 조인 칼럼이 아니기 때문에, 두 값 (상품번호, 체결일자)으로만 해시 버킷이 생기면서, 체인으로 연결된 엔트리 개수가 매우 많아지게 된 상황
  * 따라서, 동일 버킷 내에 너무 많은 엔트리가 체이닝되지 않도록 분배할 수 있는 쿼리로 튜닝 필요

```sql
select /*+ use_hash(t o) index(t) index(o) */
       o.상품번호, o.주문접수번호, o.회원번호
     , o.매도매수구분, o.주문유형코드
     , o.주문수량, o.주문가격
     , t.체결가격, t.체결수량, (t.체결가격 * t.체결수량) 체결금액
from   주문체결 t, 주문 o
where  t.상품번호 = :상품번호
and    t.체결일자 = :체결일자
and    o.상품번호 = t.상품번호
and    o.주문일자 = t.주문일자
-- 해시 키 값으로 사용 불가능
and    o.주문접수번호 in (t.매도주문접수번호, t.매수주문접수번호);
```
```sql
-- 해시 키 값으로 사용 불가능
and    o.주문접수번호 in decode(o.매도매수구분, '1', t.매도주문접수번호, t.매수주문접수번호);
```
```sql
select /*+ use_hash(t o) index(o) */
       o.상품번호, o.주문접수번호, o.회원번호, o.매도매수구분, o.주문유형코드
     , o.주문수량, o.주문가격, t.체결가격
     , t.체결수량, (t.체결가격 * t.체결수량) 체결금액
from   (select /*+ index(t) */
               상품번호, 체결일자, 체결가격, 체결수량, 매도주문접수번호 주문접수번호
        from   주문체결 t
        union all
        select /*+ index(t) */
               상품번호, 체결일자, 체결가격, 체결수량, 매수주문접수번호 주문접수번호
        from   주문체결 t) t, 주문 o
where   t.상품번호     = :상품번호
and     t.체결일자     = :체결일자
and     o.상품번호     = t.상품번호
and     o.주문일자     = t.체결일자
--해시 키 값으로 사용 가능
and     o.주문접수번호  = t.주문접수번호; 
```

<br>

### 해시 조인 사용기준
* 해시 조인 성능 좌우 키 포인트
  * 한 쪽 테이블이 Hash Area에 담길 정도로 충분히 작아야 함
  * Build Input 해시 키 칼럼에 중복 값이 거의 없어야 함
* 해시 조인 선택 기준
  * 조인 칼럼에 적당한 인덱스가 없어 NL조인이 비효율적일 때
  * 조인 칼럼에 인덱스가 있더라도 NL 조인 드라이빙 집합에서 Inner 쪽 집합으로의 조인 액세스량이 많아 Random 액세스 부하가 심할 때
  * 소트 머지 조인하기에는 두 테이블이 너무 커 소트 부하가 심할 때
  * 수행빈도가 낮고 쿼리 수행 시간이 오래 걸리는 대용량 테이블을 조인할 때
* 수행시간이 짧으면서 수행빈도가 매우 높은 쿼리 (OLTP성 쿼리)
  * NL조인 : 조인에 사용되는 인덱스는 (Drop하지 않는 한) 영구적으로 유지되면서 다양한 쿼리르 위해 공유 및 재사용되는 자료구조
  * 해시조인 : 해시 테이블은 단 하나의 쿼리를 위해 생성하고 조인이 끝나면 곧바로 소멸하는 자료구조
    * 따라서, 수행빈도가 높은 쿼리에 해시 조인을 사용하면 CPU/메모리 사용률이 크게 증가하고, SQL memory manager workarea, row cache objects, simulator hash latch, cache buffers chains 같은 래치 경합이 발생하여 시스템 동시성이 떨어진다
* 해시조인이 주로 사용되는 환경
  * 수행 빈도가 낮고
  * 쿼리 수행 시간이 오래 걸리는
  * 대용량 테이블을 조인할 때
  * ex: 배치 프로그램, DW, OLAP성 쿼리의 특징
* OLTP환경에서 1초 걸리는 쿼리를 0.1초로 단축시킬 목적으로 해시 조인을 사용하는 것은 가급적 자제해야 한다
  * 보통, 빈도수가 높기 때문에, 시간 단축을 원하기 때문
 
<br>
<hr>
<br>

## 조인 순서의 중요성
#### 조인 순서에 따라서 쿼리 수행 성능이 달라질 수 있다

<br>

```sql
select /*+ use_nl(a b) */ a.납입방법명, b.*
from   납입방법 a, 고객 b
where  b.납입방법코드 = a.납입방법코드;
```

### 필터 조건이 없을 때
* NL 조인에서는 무엇보다 Random 액세스 방생량에 의해 성능이 좌우
* 결론
  * 필터 조건이 없는 상황에서는 작은 쪽 집합을 드라이빙하는 것이 유리 

```sql
select /*+ leading(b) use_nl(a) */ a.납입방법명, b.*
from   납입방법 a, 고객 b
where  b.납입방법코드 = a.납입방법코드;
```

* 드라이빙 테이블 : 고객 케이스)
  * 20만 번 Random 액세스 발생

<div align="center">
 <img width="50%" src="https://github.com/PoSungKim/development_study/assets/37537227/a800b4b8-6dce-44fe-9df6-8aaf877aed23" >
</div>

```sql
select /*+ leading(a) use_nl(b) */ a.납입방법명, b.*
from   납입방법 a, 고객 b
where  b.납입방법코드 = a.납입방법코드;
```

* 드라이빙 테이블 : 납입방법 케이스)
  * 10만 3번 Random 액세스 발생

<div align="center">
 <img width="50%" src="https://github.com/PoSungKim/development_study/assets/37537227/635b3c59-803f-4df7-9c86-7fed876afccf" >
</div>

<br>

### 필터 조건이 있을 때
* 결론
  * 조인 조건 외에 필터 조건이 있을 때는 인덱스 구성에 따라 유불리가 결정되며, 비효율이 없게끔 인덱스를 잘 구성해 주기만 한다면 역시 작은 집합을 드라이빙하는 것이 유리
  * NL 조인에서는 Random 액세스 발생량 외에도 Inner 쪽 인덱스 구성 및 조건절 연산자 형태에 따라 성능이 크게 좌우

```sql
select /*+ leading(b) use_nl(a) */ a.납입방법명, b.*
from   납입방법 a, 고객 b
where  b.납입방법코드 = a.납입방법코드
and    b.거주지역 = '부산';
```

* 드라이빙 테이블 : 고객 케이스)
  * 3만 번 Random 액세스 발생

<div align="center">
 <img width="50%" src="https://github.com/PoSungKim/development_study/assets/37537227/2f193232-6deb-45cb-9fe8-d80c12659fc0" >
</div>

```sql
select /*+ leading(a) use_nl(b) */ a.납입방법명, b.*
from   납입방법 a, 고객 b
where  b.납입방법코드 = a.납입방법코드
and    b.거주지역 = '부산';
```

* 드라이빙 테이블 : 납입방법 케이스)
  * 10만 3번 Random 액세스 발생

<div align="center">
 <img width="50%" src="https://github.com/PoSungKim/development_study/assets/37537227/0af8fd94-7c77-4993-9a68-6b487bb62b89" >
</div>

* 드라이빙 테이블 : 납입방법 케이스)
  * 1만 3번 Random 액세스 발생

<div align="center">
 <img width="50%" src="https://github.com/PoSungKim/development_study/assets/37537227/5b8ac75c-71ed-4111-beaf-71c0f05d176b" >
</div>

<br>

### 소트 머지 조인과 해시 조인의 경우
* 소트 머지 조인 및 해시 조인도 순서 중요
* 소트 머지 조인
  * PGA 상에 정렬된 집합을 통해 조인 액세스가 일어나기 때문에 Random 액세스 발생량보다는 소트 부하로 인해 성능이 감소
  * 즉, 디스크 소트(to-disk sort)가 발생할 정도의 큰 테이블을 포함할 때는 큰 테이블을 드라이빙하는 것이 더 효율적
  * 다만, 메모리 소트(in-memory sort) 방식으로 조인할 때는 작은 쪽 테이블을 드라이빙하는 것이 조금 더 빠름
* 해시 조인
  * Hash Area에 Build Input을 모두 채울 수 있는가가 관건이므로, 작은 족 테이블을 드라이빙하는 것이 유리

<br>

### 3개 이상 테이블에 대한 조인문 기술할 때 주의사항
* 조인 칼럼에 대한 상수나 변수 조건은 조인문을 타고 다른 쪽 테이블 조건으로도 전이된다
* 하지만 조인문 자체는 그런 작용이 일어나지 않으므로 3개 이상 테이블에 대한 조인문을 기술할 때 세심한 주의 필요
  * A와 B간의 조인 조건, B와 C간의 조인 조건을 이용해 A와 C간의 조인 조건이 내부적으로 생성된다면 (조인 칼럼이 동일할 때) 조인 순서가 어떻게 결정되더라도 효과적으로 수행될 수 있다
  * 하지만 조인 조건은 그런 식의 전이가 이루어지지 않으므로 사용자가 최적의 조인순서를 결정하고 그 순서에 따라 조인문을 기술해 주는 것이 매우 중요

```sql
select *
from 고객 a, 주문 b, 주문상세 c
where 1=1
-- (조인문 자체) 전이가 안되는 케이스
and c.고객번호 = a.고객번호
and c.고객번호 = b.고객번호

-- (사용자가 최적의 조인순서를 결정) 전이가 되는 케이스
and c.고객번호 = a.고객번호
and c.고객번호 = b.고객번호
and a.고객번호 = b.고객번호

-- (상수나 변수 조건) 전이가 되는 케이스
and b.고객번호 = a.고객번호
and c.고객번호 = b.고객번호
```

<br>
<hr>
<br>

## Outer 조인
#### 

<br>

### Outer NL 조인 
* NL 조인은 Outer 조인할 때 방향이 한쪽으로 고정된다
  * Outer 기호(+)가 붙지 않은 테이블이 항상 드라이빙 테이블로 선택
  * leading 힌트는 효과가 없다
```sql
select /*+ use_nl(d e) */ *
from   dept d, emp e
where  e.deptno(+) = d.deptno;
```
* dept 테이블이 드라이빙 테이블이되어, FULL SCAN 되었다
```md
Execution Plan
------------------------------------------------
0    SELECT STATEMENT Optimizier=ALLP_ROWS
1      NESTED LOOPS (OUTER)
2        TABLE ACCESS (FULL) OF 'DEPT' (TABLE)
3        TABLE ACCESS (BY INDEX ROWID) OF 'EMP' (TABLE)
4          INDEX (RANGE SCAN) OF 'EMP_DEPTNO_IDX' (INDEX)
```

* ERD 표기를 따르는 SQL 개발의 필요성
  * ERD 표기법에 대한 정확한 이해가 필수
    * 각 속성의 Null 값 허용 여부 확인 필요
    * 엔티티 간 관계 (relationship)을 해석할 때 Cardinality (crows's foot, 1:1, 1:M, M:M)에 더불어 Optionality도 확인 필요
* 배정된 사원이 없는 부서가 존재 가능한 ERD
  * 따라서, 사원 유무와 상관없이 모든 부서가 출력되려면 사원 테이블 쪽 모든 조건절에 Outer 기호(+)를 붙여야 한다

<div align="center">
 <img width="50%" src="https://github.com/PoSungKim/development_study/assets/37537227/328fee31-4fb8-4142-82fc-5ebdf211f1cb" >
</div>

* 배정된 사원이 반드시 필요한 부서가 존재하는 ERD
  * 따라서, 모든 부서가 출력되려면 사원 테이블 쪽 모든 조건절에 Outer 기호(+)를 붙일 필요가 없다
    * 오히려 ERD를 이해하지 못하고, Outer 기호 (+)를 붙이면, 성능이 나빠질 수 있다
  
<div align="center">
 <img width="50%" src="https://github.com/PoSungKim/development_study/assets/37537227/f2c3cad2-772a-42f4-af2b-299feb9ee7ac" >
</div>

* 공통적으로 두 ERD는 모두 사원 쪽 부서번호가 필수 (Mandatory) 칼럼이다
  * 즉, 소속 부서가 없는 사원은 존재하지 않는다
  * 따라서, 테이블 생성시, Not Null 제약을 두어야 한다
  * 혹시 모를 Null 값으로 인해 Outer 기호 (+)를 붙이는 습관이 생기면 불이익이 생길 수 있다

<br>

### Outer 소트 머지 조인
* 소트 머지 조인은 소트된 중간 집합을 이용한다는 점만 다를 뿐 처리루틴은 NL 조인과 다르지 않다
* Outer 소트 머지 조인도 처리 방향이 한쪽으로 고정된다
  * Outer 기호(+)가 붙지 않는 테이블(Outer 테이블)이 항상 First 테이블로 선택
  * leading 힌트는 효과가 없다
  ```sql
  select /*+ use_merge(d e) */ *
  from   dept d, emp e
  where  e.deptno(+) = d.deptno;
  ```
  * dept 테이블이 드라이빙 테이블이되어, FULL SCAN 되었다
  ```md
  Execution Plan
  ------------------------------------------------
  0    SELECT STATEMENT Optimizier=ALL_ROWS
  1      MERGE JOIN (OUTER)
  2        SORT (JOIN)
  3          TABLE ACCESS (FULL) OF 'DEPT' (TABLE)
  4        SORT (JOIN)
  5          TABLE ACCESS (FULL) OF 'EMP' (TABLE)
  ```

<br>

### Outer 해시 조인
* Outer 해시 조인도 처리 방향이 한쪽으로 고정된다
  * Outer 기호(+)가 붙지 않는 테이블(Outer 테이블)이 항상 Build Input으로 선택

  ```sql
  select /*+ use_hash(d e) */ d.dname, e.ename
  from   dept d, emp e
  where  e.deptno(+) = d.deptno;
  ```
  
  ```md
  Execution Plan
  ------------------------------------------------
  0    SELECT STATEMENT Optimizier=ALL_ROWS
  1      HASH JOIN (OUTER)
  2        TABLE ACCESS (FULL) OF 'DEPT' (TABLE)
  3        TABLE ACCESS (FULL) OF 'EMP' (TABLE)
  ```

  * 절차
    * Outer 집합인 dept 테이블로 해시 테이블을 빌드(build)
    * Inner 집합인 emp 테이블을 읽으면서 해시 테이블을 탐색(probe)
    * 조인에 성공한 레코드는 곧바로 결과집합에 삽입 후 해시 엔트리에 표시
    * Probe 단계가 끝난 이후에 완성된 Inner 조인 결과집합에 아직 표시가 안된 남은 해시 엔트리들을 결과집합에 삽입
  * 고정 순서에 따른 부작용 존재
    * Hash Area가 부족해 디스크 쓰기와 읽기 발생
    * 해시 버킷 당 엔트리 개수가 너무 많이 증가

<div align="center">
  <img width="80%" src="https://github.com/PoSungKim/development_study/assets/37537227/b7f91081-f8b9-41e2-af55-aab1fefa7664" >
</div>

* Right Outer 해시 조인 탄생 배경

  ```sql
  select /*+ use_hash(d e) swap_join_inputs(d) */ d.dname, e.ename
  from   dept d, emp e
  where  e.deptno = d.deptno(+);
  ```
  
  ```md
  Execution Plan
  ------------------------------------------------
  0    SELECT STATEMENT Optimizier=ALL_ROWS
  1      HASH JOIN (RIGHT OUTER)
  2        TABLE ACCESS (FULL) OF 'DEPT' (TABLE)
  3        TABLE ACCESS (FULL) OF 'EMP' (TABLE)
  ```

  * 절차
    * Inner 집합인 dept 테이블로 해시 테이블을 빌드(build)
    * Outer 집합인 emp 테이블을 읽으면서 해시 테이블을 탐색(probe)
    * Outer 조인이므로 조인 성공 여부에 상관없이 결과집합에 삽입

* 9i 이전 버전에서 Outer 해시 조인 튜닝

  ```sql
  select /*+ ordered index_ffs(o) full(c) full(o2) use_hash(o c) use_hash(o2)
             parallel_index(o) parallel(c) parallel(o2) */ c.*, o2.*
  from   주문 o, 고객 c, 주문 o2
  where  c.고객번호(+) = o.고객번호
  and    o2.고객번호 = o.고객번호
  and    o2.상품번호 = o.상품번호
  and    o2.주문일시 = o.주문일시
  ```
  * 주문(o)과 고객(c) 테이블을 Outer조인할 때, 대용량인 주문 테이블에서 PK 인덱스만 빠르게 읽어서 Build Input 크기를 줄임으로써, In-Memory 해시 조인을 불가능하겠지만, 디스크 쓰기와 읽기 작업을 최소화하려는 아이디어
    * 다만, 해시 버킷 당 엔트리 개수가 많아서 생기는 문제는 피할 수 없다
  * 만약, 조인 성능이 느리다면 주문일시 구간을 나눠 쿼리를 여러 번 수행하는 방법 고려 가능
    * `주문일시`로 Range 파티셔닝 고려 가능

<br>

### Full Outer 조인
```sql
exec dbms_random.seed(150);

create table 입금
as
select rownum 일련번호
     , round(dbms_random.value(1,20)) 고객ID
     , round(dbms_random.value(1000, 100000), -2) 입금액
from   dual connect by level <= 10;

create table 출금
as
select rownum 일련번호
     , round(dbms_random.value(1,20)) 고객ID
     , round(dbms_random.value(1000, 100000), -2) 입금액
from   dual connect by level <= 10;

exec dbms_stats.gather_table_stats(user, '입금');
exec dbms_stats.gather_table_stats(user, '출금');
```
* Left Outer 조인 + Union All + Anti 조인 (Not Exists 필터) 이용
  * 입금과 출금 테이블을 Full Outer 조인해 고객별 입금액과 출금액을 같이 집계한다
  ```sql
  select a.고객ID, a.입금액, b.출금액
  from   (select 고객ID, sum(입금액) 입금액 from 입금 group by 고객ID) a
       , (select 고객ID, sum(출금액) 출금액 from 츨금 group by 고객ID) b
  where  b.고객ID(+), a.고객ID
  
  union all
  
  select 고객ID, null, 출금액
  from   (select 고객ID, sum(출금액) 출금액 from 츨금 group by 고객ID) a
  where  not exists (select 'x' from 입금 where 고객ID = a.고객ID);
  ```
  ```md
  Id     Operation
  ----   -------------------------------------------
  0      SELECT STATEMENT
  1        UNION-ALL
  2          HASH JOIN OUTER
  3            VIEW
  4              HASH GROUP BY
  5                TABLE ACCESS FULL 입금
  6            VIEW
  7              HASH GROUP BY
  8                TABLE ACCESS FULL 출금
  9          HASH GROUP BY
  10           HASH JOIN ANTI
  11             TABLE ACCESS FULL 출금
  12             TABLE ACCESS FULL 입금
  ```
* ANSI Full Outer 조인
  ```sql
  select nvl(a.고객ID, b.고객ID) 고객ID, a.입금액, b.출금액
  from   (select 고객ID, sum(입금액) 입금액 from 입금 group by 고객ID) a
         full  outer join
         (select 고객ID, sum(출금액) 출금액 from 출금 group by 고객ID) b
         on a.고객ID = b.고객ID;
  ```
  ```md
  Id     Operation
  ----   -------------------------------------------
  0      SELECT STATEMENT
  1        VIEW
  2          UNION-ALL
  3            HASH JOIN OUTER
  4              VIEW
  5                HASH GROUP BY
  6                  TABLE ACCESS FULL 입금
  7              VIEW
  8                HASH GROUP BY
  9                  TABLE ACCESS FULL 출금
  10           HASH GROUP BY
  11             FILTER
  12               TABLE ACCESS FULL 출금
  13               SORT GROUP BY NOSORT
  14                 TABLE ACCESS FULL 입금
  ```
* Native Hash Full Outer 조인
  * 입금 및 출금 테이블을 한 번만 액세스하도록 튜닝
  ```sql
  select /*+ opt_param('_optimizer_native_full_outer_join', 'force') */
         nvl(a.고객ID, b.고객ID) 고객ID, a.입금액, b.출금액
  from   (select 고객ID, sum(입금액) 입금액 from 입금 group by 고객ID) a
         full  outer join
         (select 고객ID, sum(출금액) 출금액 from 출금 group by 고객ID) b
         on a.고객ID = b.고객ID;
  ```
  ```md
  Id     Operation
  ----   -------------------------------------------
  0      SELECT STATEMENT
  1        VIEW VW_FOJ_0
  2          HASH JOIN FULL OUTER 
  3            VIEW
  4              HASH GROUP BY
  5                TABLE ACCESS FULL 출금
  9            VIEW
  10             HASH GROUP BY
  11               TABLE ACCESS FULL 입금
  ```
* Native Hash Full Outer 조인
  * ㅇㅇ
  ```sql
  select 고객ID, sum(입금액) 입금액, sum(출금액) 출금액
  from   (
      select 고객ID, 입금액, to_number(null) 출금액
      from   입금
      union all
      select 고객ID, 입금액, to_number(null) 입금액, 출금액
      from   출금
  )
  group by 고객ID;
  ```
  ```md
  Id     Operation
  ----   -------------------------------------------
  0      SELECT STATEMENT
  1        HASH GROUP BY
  2          VIEW
  3            UNION-ALL
  4              TABLE ACCESS FULL 입금
  5              TABLE ACCESS FULL 출금
  ```
  
<br>
<hr>
<br>
