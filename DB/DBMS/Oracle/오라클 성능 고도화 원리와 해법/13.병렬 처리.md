# 병렬 처리
> SQL문이 수행해야 하는 작업 범위를 여러 개의 작은 단위로 나누어 여러 프로세스 (또는 쓰레드)가 동시에 처리하는 것을 말한다
* 

<hr>
<br>

## 기본 개념
#### 

<br>

<div align="center">
  <img width="80%"  src="https://github.com/PoSungKim/development_study/assets/37537227/13296f66-1646-4d48-a974-1be8209eafb5">
</div>

### (1) Query Coordinator와 병렬 서버 프로세스
* Query Coordinator (QC)는 병렬 SQL문을 발행한 사용자 세션 자신 
* 병렬 서버 프로세스는 실제 작업을 수행하는 개별 세션들
```sql
select /*+ ordered use_hash(d) full(d) full(e) nonparallel(d) parallel(e 4) */
       count(*), min(sal), max(sal), avg(sal), sum(sal)
from   dept d, emp e
where  d.loc = 'CHICAGO'
and    e.deptno = d.deptno;
```
```
Id     Operation                             Name      TQ        IN-OUT    PQ Distrib      
----   -----------------------------------   -------   -------   -------   -----------
0      SELECT STATEMENT
1        SORT AGGREGATE
2          PX COORDINATOR
3            PX SEND QC (RANDOM)             :TQ10002  Q1,02     P->S      QC (RAND)
4              SORT AGGREGATE                          Q1,02     PCWP
5                HASH JOIN                             Q1,02
6                  BUFFER SORT                         Q1,02
7                    PX RECEIVE                        Q1,02
8                      PX SEND HASH          :TQ10000            S->P      HASH
9                        TABLE ACCESS FULL   DEPT
10               PX RECEIVE                            Q1,02     PCWP
11                 PX SEND HASH              :TQ10001  Q1,01     P->P      HASH
12                    PX BLOCK ITERATOR                Q1,01     PCWP
13                      TABLE ACCESS FULL    EMP       Q1,01     PCWP
```

<br>

### (2) Intra-Operation Parallelism과 Inter-Operation Parallelism
```sql
select /*+ full(고객) parallel(고객 4) */ *
from   고객
order by 고객명;
```

<div align="center">
  <img width="80%"  src="https://github.com/PoSungKim/development_study/assets/37537227/cbf21faa-b50b-4442-9d3b-9cc8c3ccb9d5">
</div>

* 병렬서버집합 1 : 배분 역할
* 병렬서버집합 2 : 정렬 역할
* QC : 머지 (merge) 역할

<br>

### (3) 테이블 큐
* 테이블 큐
  * 쿼리 서버 집합 간 (P->P) 또는 QC와 쿼리 서버 집합 간 (P->S,S->P) 데이터 전송을 위해 연결된 파이프 라인
* 테이블 큐 식별자 (TQ Identifier)
  * ex) :TQ10000, :TQ10001, :TQ10002

```sql
select /*+ ordered use_hash(e) full(d) noparallel(d) full(e) parallel(e 2) pq_distribute(e broadcast none) */ *
from   dept d, emp e
where  d.deptno = e.deptno
order by e.ename;
```

<div align="center">
  <img width="80%"  src="https://github.com/PoSungKim/development_study/assets/37537227/530c3f4c-9d1c-4cce-9e88-0a4d96520c73">
</div>

* 그림 해설
  * 필요 서버 프로세스 개수 : 병렬도 * 2
  * P->P 필요 파이프라인 개수 : 병렬도 ^ 2
* 생산자/소비자 모델
  * 테이블 큐 마다 생산자 (Producer)와 소비자 (Consumer)가 있다
  * Inter-Operation Parallelism 마다 소비자 서버 집합은 from에 테이블 큐를 참조하는 서브 (Sub) SQL 작업을 수행한다
* 병렬 실행계획에서 생산자와 소비자 식별
  * 생산자 : PX_SEND
  * 소비자 : PX_RECEIVE
  
  ```
  Id     Operation                             Name      TQ        IN-OUT    PQ Distrib      
  ----   -----------------------------------   -------   -------   -------   -----------
  0      SELECT STATEMENT
  1        PX COORDINATOR
  2          PX SEND QC (ORDER)                :TQ10002  Q1,02     P->S      QC (ORDER)
  3            SORT ORDER BY                             Q1,02     PCWP
  4              PX RECEIVE                              Q1,02     PCWP
  5                PX SEND RANGE               :TQ10001  Q1,02     P->P      RANGE
  6                  HASH JOIN                           Q1,01     PCWP
  7                    BUFFER SORT                       Q1,01     PCWC
  8                      PX RECEIVE                      Q1,01     PCWP 
  9                        PX SEND BROADCAST   :TQ10000            S->P      BROADCAST
  10                         TABLE ACCESS FULL DEPT      
  11                     PX BLOCK ITERATOR               Q1,01     PCWC
  12                       TABLE ACCESS FULL   EMP       Q1,Q1     PCWP      
  ```

<br>

### (4) IN-OUT 오퍼레이션 

<div align="center">
  <img width="80%"  src="https://github.com/PoSungKim/development_study/assets/37537227/36e3b25c-4b5d-4b37-8ad8-2f347a47a101">
</div>

* S->P : PARALLEL_FROM_SERIAL
  * 9번) 오퍼레이션
  * QC가 읽은 데이터를 테이블 큐를 통해 병렬 서버 프로세스에게 전송하는 것을 의미
  * Inter 혹은 Intra Operation Parallelism이 아니다 (병렬 프로세스가 아니라서)
  * BROADCAST
* P->S : PARALLEL_TO_SERIAL
  * 1번) 오퍼레이션
  * 각 병렬 서버 프로세스가 처리한 데이터를 QC에게 전송하는 것을 의미
  * Inter-Operation Parallelism
  * QC (ORDER) : QC에게 결과 데이터를 전송할 때 첫 번째부터 마지막 병렬 프로세스까지 순서대로 진행함을 의미 (SQL Order By)
  * QC (RANDOM) : QC에게 결과 데이터를 전송할 때 병렬 프로세스들임 무순위로 진행함을 의미 (SQL X Order By)
* P->P : PRARALLEL_TO_PARALLEL
  * 2번) 오퍼레이션
  * 데이터를 재분배 (Redistribution)하는 오퍼레이션을 의미
    * 해당 오퍼레이션을 두 개의 서버 집합 (Server Set)이 처리한다
    * 데이터를 정렬 (order by) 또는 그룹핑 (group by)하거나 조인을 위해 동적으로 파티셔닝할 때 사용
  * Inter-Operation Parallelism
  * RANGE
* PCWP : PARALLEL_COMBINED_WITH_PARENT
  * 4~8번) 오퍼레이션
  * 한 서버 집합이 현재 스텝과 그 부모 (Parent) 스텝을 모두 처리함을 의미
    * 즉, 한 서버 집합에 속한 서버 프로세스들이 각자 맡은 범위 내에서 두 스텝 이상의 오퍼레이션을 처리하는 것
  * Intra-Operation Parallelism
* PCWC : PARALLEL_COMBINED_WITH_CHILD
  * 3번) 오퍼레이션
  * 한 서버 집합이 현재 스텝과 그 자식(Child) 스텝을 모두 처리함을 의미
  * Intra-Operation Parallelism

<br>

### (5) 데이터 재분배
* RANGE
  * order by 또는 sort group by
  * P->P
* HASH
  * 조인 또는 hash group by
  * P->P 혹은 S->P
* BROADCAST
  * QC 또는 첫 번째 서버 집합에 속한 프로세스들이 각각 읽은 데이터를 두 번째 서버 집합에 속한 모든 병렬 프로세스에게 전송하는 방식
  * P->P 혹은 S->P
* KEY
  * 특정 칼럼(들)을 기준으로 테이블 또는 인덱스를 파티셔닝할 때 사용하는 분배 방식
  * PARTITION (KEY)
    * Partial Partition-Wise 조인
    * CTAS (Create Table As Select) 문장으로 파티션 테이블을 만들 때
    * 병렬로 글로벌 파티션 인덱스를 만들 때
* ROUND-ROBIN
  * 파티션 키, 정렬 키, 해시 함수 등에 의존하지 않고 반대편 병렬 서버에 무작위로 데이터를 분배
  ```sql
  alter session enable parallel dml;
  
  explain plan for
  insert /*+ parallel(t1 2) */ into t1
  select /*+ parallel(t2 2) full(t2) */ * from t2;
  ```

  <div align="center">
    <img width="80%"  src="https://github.com/PoSungKim/development_study/assets/37537227/5ca2db04-29e9-43f7-92ed-cf166daf9373">
  </div>

<br>

### (6) Granule
* Granule
  * 데이터를 병렬로 처리할 때 일의 최소 단위
  * 병렬 서버는 한 번에 하나의 Granule씩만 처리한다
* 블록 기반 Granule(=블록 범위 Granule)
  * 파티션 테이블 여부와 상관없이 대부분의 병렬 오퍼레이션에 적용되는 기본 작업 단위
  * PX BLOCK ITERATOR
    ```sql
    SORT AGGREGATE
      PX BLOCK ITERATOR
        TABLE ACCESS FULL T
    ```
* 파티션 기반 Granule(=파티션 Granule)
  * 각 병렬 서버 프로세스는 할당받은 테이블(또는 인덱스) 파티션 전체를 처리할 책임을 진다
  * PX PARTITION RANGE ALL or PX PARTITION RANGE ITERATOR
    ```sql
    SORT AGGREGATE
      PX PARTITION RANGE ITERATOR
        TABLE ACCESS BY LOCAL INDEX ROWID T
          INDEX RANGE SCAN T_NO_IDX
    ```
  * 파티션 Granule 사용 되는 작업 유형
    * Partition-Wise 조인 시
    * 파티션 인덱스를 병렬로 스캔할 때
    * 파티션 인덱스를 병렬로 갱신할 때
    * 9iR1 이전에서의 병렬 DML
    * 파티션 테이블 또는 파티션 인덱스를 병렬로 생성할 때
* 블록 기반 Granule vs 파티션 기반 Granule
  * 파티션 기반일 때는 Granule 개수가 테이블과 인덱스의 파티션 구조에 의해 정적으로 결정되므로 블록 기반 Granule처럼 유연하지 못하다

<br>

### (7) 병렬 처리 과정에서 발생하는 대기 이벤트

| 이벤트명                   | 클래스명 | 설명                                                                                                                                                                                                                                  |
|----------------------------|----------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| PX DEQ: Execute Reply      | Idle     | QC가 각 병렬 서버에게 작업을 배분하고서 작업이 완료되기를 기다리는 상태                                                                                                                                                               |
| PX Deq: Execution Msg      | Idle     | 병렬 서버가 자신의 임무를 완수하고서 다른 병렬 서버가 일을 마치기를 기다리는 상태. <br>QC 또는 소비자 병렬 서버에게 데이터 전송을 완료했을 때 나타남                                                                                  |
| PX Deq: Table Q Normal     | Idle     | 메시지 수신 대기. 메시지 큐에 데이터가 쌓이기를 기다리는 상태                                                                                                                                                                         |
| PX Deq Credit: send blkd   | Other    | 메시지 송신 대기. QC 또는 소비자 병렬 서버에게 전송할 데이터가 있는데 블로킹 된 상태.<br>생산자 프로세스가 메시지 큐를 통해 데이터를 전송하려고 하는데 어떤 이유에서건 소비자 프로세스가 버퍼에서 데이터를 빨리 꺼내가지 않을 때 발생 |
| PX Deq Credit: need buffer | Idle     | 데이터를 전송하기 전에 상태편 병렬 서버 또는 QC로부터 credit 비트를 얻으려고 대기하는 상태.                                                                                                                                           |
* 대기 이벤트 모니터링
  * 병렬 쿼리
    ```sql
    select /*+ parallel(고객 2) */ * from 고객 order by 고객명;

    select decode(a.qcserial#, null, 'PARENT', 'CHILD') ST_LVL
         , a.server_set "SET", a.sid, a.serial#, status, event, wait_class
    from   V$PX_SESSION a, V$SESSION b
    where  a.sid = b.sid
    and    a.qcsid = 5284
    order by a.qcsid, ST_LVL desc, a.server_group, a.server_set
    ;
    ```
* 대기 이벤트 해소
  * 병렬 쿼리는 Idle 대기 이벤트가 많이 발생한다
  * insert (직렬) && select (병렬)문 - insert가 직렬이기 때문에 QC에게 전송하는 4개의 병렬서버들이 PX Deq Credit: send blkd 이벤트에서 자주 대기하게 된다
    ```sql
    insert /*+ append */ into t1 
    select /*+ full(t2) parallel(t2 4) */ * from t2;
    ```
  * insert (병렬) && select (병렬)문
    ```sql
    alter session enable parallel dml;

    insert /*+ append parallel (t1 4) */ into t1 
    select /*+ full(t2) parallel(t2 4) */ from t2;
    ```

<br>
<hr>
<br>

## 병렬 Order By와 Group By
#### P->P 데이터 재분배는 주로 병렬 order by, 병렬 group by, 병렬 조인을 포함한 SQL에서 나타난다
#### 대부분의 쿼리로 P->P 유형이 발생하기 때문에 Inter-Operation Parallelism이 일어난다고 볼 수 있다

<br>

### (1) 병렬 Order By
* 테스트 환경 세팅 쿼리
  ```sql
  create table 고객
  as
  select rownum 고객ID
       , dbms_random.STRING('U', 10) 고객명
       , mod(rownum, 10) + 1 고객등급
       , to_char(to_date('20090101', 'yyyymmdd') + (rownum-1), 'yyyymmdd') 가입일
  from   dual
  connect by level <= 1000;
  ```
* 병렬 Order By 쿼리
  ```sql
  set autotrace traceonly exp
  
  select /*+ full(고객) parallel(고객 2) */
         고객ID, 고객명, 고객등급
  from   고객
  order by 고객명;
  ```
  
  <div align="center">
    <img width="80%"  src="https://github.com/PoSungKim/development_study/assets/37537227/7576596d-5243-4296-8383-0859ba7d0552">
  </div>
  
  ```sql
  select tq_id, server_type, process, num_rows, bytes, waits 
  from   V$PQ_TQSTAT
  order by 
          DFO_NUMBER
          , TQ_ID
          , decode(substr(server_type, 1, 4),'Rang',1,'Prod',2,'Cons',3)
          , process;
  ```

  <div align="center">
    <img width="80%"  src="https://github.com/PoSungKim/development_study/assets/37537227/e531f9c8-74ba-4ff6-854f-297206b15744">
  </div>

<br>

### (2) 병렬 Group By
* 병렬 Group By 쿼리
  ```sql
  select /*+ full(고객) parallel(고객 2) */
          고객명,
          count(*)
  from   고객
  group by 고객명;
  ```
  
  <div align="center">
    <img width="80%"  src="https://github.com/PoSungKim/development_study/assets/37537227/bce21b92-6797-4d64-b78d-3697d26cdde5">
  </div>
  
* 병렬 Group By + Order By 쿼리
  ```sql
  select /*+ full(고객) parallel(고객 2) */
        고객명,
        count(*)
  from   고객
  group by 고객명
  order by 고객명;
  ```
* Sort Group By와 Hash Group By 부분만 연산이 달라진건 내부적으로 Order By와 Group By를 병렬로 처리하는 내부 수행원리는 기본적으로 같다는 것을 의미한다  
  <div align="center">
    <img width="80%"  src="https://github.com/PoSungKim/development_study/assets/37537227/f35731a4-a773-4d05-baa6-5535163a9eb0">
  </div>

  <div align="center">
    <img width="80%"  src="https://github.com/PoSungKim/development_study/assets/37537227/f9c335ab-ae2b-4c37-8915-883d83a7d574">
  </div>

<br>
<hr>
<br>

