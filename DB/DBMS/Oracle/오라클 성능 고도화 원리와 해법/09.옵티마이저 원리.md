# 옵티마이저 원리
> 
* 

<hr>
<br>

## 옵티마이저
#### 

<br>

### 옵티마이저란?
* 옵티마이저
  * 사용자가 요청한 SQL을 가장 효율적이고 빠르게 수행할 수 있는 최적(최저비용)의 처리경로를 선택해 주는 DBMS의 핵심엔진
  * 구조화된 질의언어(SQL)로 사용자가 원하는 결과집합을 정의하면 이를 얻는 데 필요한 처리절차 (프로시저)는 DBMS에 내장된 옵티마이저가 자동으로 생성
* 유형
  * 규칙기반 옵티마이저 (Rule-Based Optimizer, RBO)
  * 비용기반 옵티마지어 (Cost-Based Optimizer, CBO)

<br>

### 규칙기반 옵티마이저
* 규칙기반 혹은 휴리스틱 (Heuristic) 옵티마이저
  * 미리 정해 놓은 우선순위에 따라 액세스 경로 (Access Path)를 평가하고 실행계획을 선택한다
  * 데이터 특성 (데이터량, 값의 수, 칼럼 값 분포, 인덱스 높이, 클러스터링 팩터...)을 고려하지 않기 때문에 RBO는 대용량 데이터를 처리하는 데 있어 합리지 못할 경우가 많다
    * 예) 조건절 칼럼에 인덱스가 있으면 무조건 인덱스 사용; 항상 인덱스를 신뢰하며, Full Table Scan과의 손익을 따지지 않는다
  * 즉, RBO는 어떻게 동작할지 예상이 가는 옵티마이저

<br>

### 비용기반 옵티마이저
* 비용기반 옵티마이저
  * 비용을 기반으로 최적화를 수행한다
* 실행계획을 수립할 때 판단 기준이 되는 비용은 어디까지나 예상치
  * 데이터 딕셔너리 (Data Dictionary)에 미리 구해놓은 테이블과 인덱스에 대한 여러 통계정보를 기초로 각 오퍼레이션 단계별 예상 비용을 산정하고, 이를 합산한 총비용이 가장 낮은 실행계획 하나를 선택
* 동적 샘플링 (Dynamic Sampling)
  * 쿼리를 최적화할 때 미리 구해놓은 통계정보를 이용한다
  * 다만, 만약 테이블과 인덱스에 대한 통계정보가 없거나 너무 오래돼 신뢰할 수 없을 때 옵티마이저가 동적으로 샘플링 수행

<div align="center">
  <img src="https://github.com/PoSungKim/development_study/assets/37537227/b0eb6d84-1e03-4879-9e8b-870dd920412a">
</div>

* Optimizer
  * Query Transformer
    * 사용자가 던진 SQL을 우선 최적화하기 쉬운 형태로 변환을 시도한다
  * Estimator
    * 쿼리 오퍼레이션 각 단계의 선택도(Selectity), 카디널리티 (Cardinality), 비용 (Cost)을 계산하고, 궁극적으로는 실행계획 전체에 대한 총 비용을 계산
  * Plan Generator
    * 하나의 쿼리를 수행하는 데 있어, 후보군이 될만한 실행계획들을 생성해내는 역할
* 스스로 학습하는 옵티마이저(Self-Learning Optimizer)
  * v$sql, v$sql_plan_statistics, v$sql_plan_statistics_all, v$sql_workarea 등에 SQL 별로 저장된 수많은 런타임 수행 통계를 보면 앞으로 옵티마이저의 발전 방향을 예상 가능
  * 옵티마이저는 지금까지 오브젝트 통계와 시스템 통계로부터 산정한 '예상' 비용만으로 실행계획을 수립했지만 앞으로는 예상치가 빗나갔을 때 이들 런타임 수행 통계를 보고 실행계획을 조정할 수도 있음

<br>

### 옵티마이저 모드 
* 모드 변경 가능 레벨
  * 시스템, 세션, 쿼리
  ```sql
  alter system set optimizer_mode = all_rows; -- 시스템 레벨 변경
  alter session set optmizer_mode = all_rows; -- 세션 레벨 변경
  select /*+ all_rows */ * from t where ...;  -- 쿼리 레벨 변경
  ```
* 모드
  * rule --> RBO
    * RBO 모드
  * all_rows --> CBO
    * 쿼리 최종 결과집합을 끝까지 Fetch하는 것을 전제로, 시스템 리소스 (I/O, CPU, 메모리 등)를 가장 적게 사용하는 실행계획 선택
    * DML 문장은 일부 데이터만 가공하고 멈출 수 없으므로 옵티마이저 모드에 상관없이 항상 all_rows 모드로 작동
      * select 문장도 union, minus 같은 집합(set) 연산자나 for update절을 사용하면 all_rows 모드로 작동
  * first_rows --> RBO + CBO
    * 전체 결과집합 중 일부 로우만 Fetch하다가 멈추는 것을 전제로, 가장 빠른 응답 속도를 낼 수 있는 실행계획을 선택
    * 사용자가 만약 끝까지 Fetch한다면, 오히려 더 많은 리소스를 사용하고 전체 수행 속도도 느려질 수 있다
    * 비용과 규칙을 혼합한 옵티마이저이기 때문에, 규칙에 따르다보면, 손익분기점 (Table Full Scan vs Index Full Scan)을 고려하지 못하고, 무조건 Index Full Scan을 탈 수가 있다
    ```sql
    -- TABLE ACCESS FULL
    select /*+ all_rows */ * from t_emp
    where  sal >= 5000
    order by empno, no;
    ```
    ```sql
    -- INDEX FULL SCAN > TABLE ACCESS BY INDEX ROWID
    select /*+ first_rows */ * from t_emp
    where  sal >= 5000
    order by empno, no;
    ```
  * first_rows_n --> CBO
    * 사용자가 처음 n개 로우만 Fetch하는 것을 전제로, 가장 빠른 응답 속도를 낼 수 있는 실행계획을 선택
    * 세팅 방법
      ```sql
      alter session set optimizer_mode = first_rows_100 -- first_rows_1, first_rows_10, first_rows_100, first_rows_1000
      ``` 
      ```sql
      select /*+ first_rows(100) */ * from t where ...;
      ```
    * CBO이기 때문에, 읽을 데이터가 적을 때는 인덱스, 읽을 데이터가 많을 때는 테이블
      ```sql
      -- Index Full Scan > Table Access By Index Rowid
      select /*+ first_rows(10) */ * from t_emp
      where  sal >= 2000
      order by empno, no;
      ```
      ```sql
      -- Table Access Full > Sort Order By
      select /*+ first_rows(100) */ * from t_emp
      where  sal >= 2000
      order by empno, no;
      ```  
  * CHOOSE
    * 액세스되는 테이블 중 적어도 하나에 통계정보가 있다면 CBO, 그중에서도 all_rows 모드를 선택; 어느 테이블에도 통계정보가 없으면 RBO 선택
* 옵티마이저 모드 선택
  * 과거의 컨벤션 
    * OLTP : first_rows
    * OLAP : all_rows
  * 요즘의 컨벤션
    * OLTP : all_rows
    * OLAP : all_rows
  * OLTP가 all_rows로 바뀐 이유
    * 요즘은 오픈 커서를 사용하지 않고, rownum 등을 활용하여 페이징처리 한다
    * 페이징처리는 전체 결과집합에서 특정 건수만 fetch하는게 아니라, 전체결과집합 자체를 작게 만들어서 모두 fetch하는 형태이기 때문에 all_rows가 적합하다

<br>
<hr>
<br>

## 옵티마이저 행동에 영향을 미치는 요소
#### 

<br>

### SQL과 연산자 형태
* 동일한 결과집합을 갖는 SQL이더라도, 작성된 형태 또는 사용한 연산자 (=, in, like, between, 부등호 등)를 사용했는지에 따라 영향도가 있을 수 있다

<br>

### 인덱스, IOT, 클러스터링, 파티셔닝, MV 등 옵티마이징 팩터
* 동일한 쿼리더라도, 구성도에 따라 실행계획과 성능이 크게 달라진다

<br>

### 제약 설정 : PK, FK, Not Null, Check
* 데이터베이스가 논리적으로 의미 있는 자료만을 포함하도록 하는 데이터 무결성 규칙
  * 개체 무결성 (Entity Integrity)
  * 참조 무결성 (Referential Integrity)
  * 도메인 무결성 (Domain Integrity)
  * 사용자 정의 무결성 (또는 업무 제약 조건) 
* PK 제약과 옵티마이저

  ```sql
  select sum(주문수량), sum(주문금액), count(*), count(distinct 고객번호)
  from   주문
  where  고객번호 in (select 고객번호 from 고객
                    where  가입일자 >= trunc(add_months(sysdate, -12))
  and    주문일자 <= trunc(add_months(sysdate, -1));  
  ```
  
  * 서브쿼리 Unnesting, 수정 가능 조인 뷰 (Updatable Join View)
* FK 제약과 옵티마이저
  * 조인 제거 (Join Elimination), Reference 파티셔닝
* Not Null 제약과 옵티마이저

  ```sql
  select deptno, count(*) from emp group by deptno;
  ```
  
  * deptno 칼럼이 Not Null이고 Index가 있다면, Index Full Scan 혹은 Index Fast Full Scan
  * deptno 칼럼이 Not Null이 아니면, Table Full Scan
* Check 제약과 옵티마이저

  ```sql
  alter table emp modify sal check (sal <= 5000);
  ```
  ```sql
  select * from emp where sal > 5000;
  ```
  ```
  Rows   Row Source Operation
  ----   -------------------------------------------
  0      FILTER
  1        TABLE ACCESS FULL EMP
  ```

<br>

### 옵티마이저 힌트
* 옵티마이저는 아래와 같은 경우가 아니면 힌트를 가장 우선적으로 따른다
  * 문법적으로 맞지 않게 힌트를 기술
  * 잘못된 참조 사용 (없는 테이블이나 별칭)
  * 의미적으로 맞지 않게 힌트를 기술 (unnest와 push_subq 함께 사용)
  * 논리적으로 불가능한 액세스 경로 (등치조건인데 Hash Join 유도, Nullable 칼럼에 인덱스를 통한 전체 건수 count 유도)
  * 버그
* 옵티마지어는 기본적으로 힌트의 내용을 먼저 따르고 남은 부분만을 자신의 판단에 따라 최적화한다

  ```sql
  select /*+ ordered */ count(*)
  from   t1, t2, t3, t4, t5
  where  t1.a = ...;
  ```

<br>

### 통계정보 : 오브젝트 통계, 시스템 통계
* CBO의 모든 판단 기준은 통계정보

<br>

### 옵티마이저 관련 파라미터
* 모든 조건이 동일하나, 오라클 버전을 업그레이드하면 옵티마이저가 다르게 작동할 수 있다
* 옵티마지어 관련 파라미터 

  ```sql
  select name, value, isdefault, default_value
  from   v$sys_optimizer_env;
  ```
  
  ```sql
  alter system set optimizer_features_enable = "9.2.0.4";
  ```

<br>

### DBMS 버전과 종류
* 같은 SQL도 DBMS 종류 (Oracle, SQL Server, Sybase, DB2)에 따라 내부적으로 처리하는 방식이 다르다

  ```sql
  select max(empno) from emp;
  ```
  
  ```sql
  select min(empno) mn, max(empno) mx from emp;
  ```

* M쪽 집합을 기준으로 1쪽 집합과 Outer조인하면 결과 건수는 M쪽 힙합으로 고정된다
  * 조인 조인 외에 어디에도 1쪽 집합을 참조하지 않는다면 1쪽 집합과는 조인 액세스를 하지 않아도 된다
    * 1쪽 테이블 조인 칼럼에 PK가 설정돼 있어야 하는 조건이 붙는다
  * 이런 기능이 Join Elimination, Table Elimination

  ```sql
  select e.empno, e.ename, e.sal, e.hiredate
  from   emp e, dept d
  where  d.deptno(+) = e.deptno;
  ```

  ```
  Rows   Row Source Operation
  ----   -------------------------------------------
  14     TABLE ACCESS FULL EMP
  ```
  
<br>
<hr>
<br>
