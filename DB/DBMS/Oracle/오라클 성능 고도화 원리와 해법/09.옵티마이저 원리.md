# 옵티마이저 원리
> 
* 

<hr>
<br>

## 옵티마이저
#### 

<br>

### 옵티마이저란?
* 옵티마이저
  * 사용자가 요청한 SQL을 가장 효율적이고 빠르게 수행할 수 있는 최적(최저비용)의 처리경로를 선택해 주는 DBMS의 핵심엔진
  * 구조화된 질의언어(SQL)로 사용자가 원하는 결과집합을 정의하면 이를 얻는 데 필요한 처리절차 (프로시저)는 DBMS에 내장된 옵티마이저가 자동으로 생성
* 유형
  * 규칙기반 옵티마이저 (Rule-Based Optimizer, RBO)
  * 비용기반 옵티마지어 (Cost-Based Optimizer, CBO)

<br>

### 규칙기반 옵티마이저
* 규칙기반 혹은 휴리스틱 (Heuristic) 옵티마이저
  * 미리 정해 놓은 우선순위에 따라 액세스 경로 (Access Path)를 평가하고 실행계획을 선택한다
  * 데이터 특성 (데이터량, 값의 수, 칼럼 값 분포, 인덱스 높이, 클러스터링 팩터...)을 고려하지 않기 때문에 RBO는 대용량 데이터를 처리하는 데 있어 합리지 못할 경우가 많다
    * 예) 조건절 칼럼에 인덱스가 있으면 무조건 인덱스 사용; 항상 인덱스를 신뢰하며, Full Table Scan과의 손익을 따지지 않는다
  * 즉, RBO는 어떻게 동작할지 예상이 가는 옵티마이저

<br>

### 비용기반 옵티마이저
* 비용기반 옵티마이저
  * 비용을 기반으로 최적화를 수행한다
* 실행계획을 수립할 때 판단 기준이 되는 비용은 어디까지나 예상치
  * 데이터 딕셔너리 (Data Dictionary)에 미리 구해놓은 테이블과 인덱스에 대한 여러 통계정보를 기초로 각 오퍼레이션 단계별 예상 비용을 산정하고, 이를 합산한 총비용이 가장 낮은 실행계획 하나를 선택
* 동적 샘플링 (Dynamic Sampling)
  * 쿼리를 최적화할 때 미리 구해놓은 통계정보를 이용한다
  * 다만, 만약 테이블과 인덱스에 대한 통계정보가 없거나 너무 오래돼 신뢰할 수 없을 때 옵티마이저가 동적으로 샘플링 수행

<div align="center">
  <img src="https://github.com/PoSungKim/development_study/assets/37537227/b0eb6d84-1e03-4879-9e8b-870dd920412a">
</div>

* Optimizer
  * Query Transformer
    * 사용자가 던진 SQL을 우선 최적화하기 쉬운 형태로 변환을 시도한다
  * Estimator
    * 쿼리 오퍼레이션 각 단계의 선택도(Selectity), 카디널리티 (Cardinality), 비용 (Cost)을 계산하고, 궁극적으로는 실행계획 전체에 대한 총 비용을 계산
  * Plan Generator
    * 하나의 쿼리를 수행하는 데 있어, 후보군이 될만한 실행계획들을 생성해내는 역할
* 스스로 학습하는 옵티마이저(Self-Learning Optimizer)
  * v$sql, v$sql_plan_statistics, v$sql_plan_statistics_all, v$sql_workarea 등에 SQL 별로 저장된 수많은 런타임 수행 통계를 보면 앞으로 옵티마이저의 발전 방향을 예상 가능
  * 옵티마이저는 지금까지 오브젝트 통계와 시스템 통계로부터 산정한 '예상' 비용만으로 실행계획을 수립했지만 앞으로는 예상치가 빗나갔을 때 이들 런타임 수행 통계를 보고 실행계획을 조정할 수도 있음

<br>

### 옵티마이저 모드 
* 모드 변경 가능 레벨
  * 시스템, 세션, 쿼리
  ```sql
  alter system set optimizer_mode = all_rows; -- 시스템 레벨 변경
  alter session set optmizer_mode = all_rows; -- 세션 레벨 변경
  select /*+ all_rows */ * from t where ...;  -- 쿼리 레벨 변경
  ```
* 모드
  * rule --> RBO
    * RBO 모드
  * all_rows --> CBO
    * 쿼리 최종 결과집합을 끝까지 Fetch하는 것을 전제로, 시스템 리소스 (I/O, CPU, 메모리 등)를 가장 적게 사용하는 실행계획 선택
    * DML 문장은 일부 데이터만 가공하고 멈출 수 없으므로 옵티마이저 모드에 상관없이 항상 all_rows 모드로 작동
      * select 문장도 union, minus 같은 집합(set) 연산자나 for update절을 사용하면 all_rows 모드로 작동
  * first_rows --> RBO + CBO
    * 전체 결과집합 중 일부 로우만 Fetch하다가 멈추는 것을 전제로, 가장 빠른 응답 속도를 낼 수 있는 실행계획을 선택
    * 사용자가 만약 끝까지 Fetch한다면, 오히려 더 많은 리소스를 사용하고 전체 수행 속도도 느려질 수 있다
    * 비용과 규칙을 혼합한 옵티마이저이기 때문에, 규칙에 따르다보면, 손익분기점 (Table Full Scan vs Index Full Scan)을 고려하지 못하고, 무조건 Index Full Scan을 탈 수가 있다
    ```sql
    -- TABLE ACCESS FULL
    select /*+ all_rows */ * from t_emp
    where  sal >= 5000
    order by empno, no;
    ```
    ```sql
    -- INDEX FULL SCAN > TABLE ACCESS BY INDEX ROWID
    select /*+ first_rows */ * from t_emp
    where  sal >= 5000
    order by empno, no;
    ```
  * first_rows_n --> CBO
    * 사용자가 처음 n개 로우만 Fetch하는 것을 전제로, 가장 빠른 응답 속도를 낼 수 있는 실행계획을 선택
    * 세팅 방법
      ```sql
      alter session set optimizer_mode = first_rows_100 -- first_rows_1, first_rows_10, first_rows_100, first_rows_1000
      ``` 
      ```sql
      select /*+ first_rows(100) */ * from t where ...;
      ```
    * CBO이기 때문에, 읽을 데이터가 적을 때는 인덱스, 읽을 데이터가 많을 때는 테이블
      ```sql
      -- Index Full Scan > Table Access By Index Rowid
      select /*+ first_rows(10) */ * from t_emp
      where  sal >= 2000
      order by empno, no;
      ```
      ```sql
      -- Table Access Full > Sort Order By
      select /*+ first_rows(100) */ * from t_emp
      where  sal >= 2000
      order by empno, no;
      ```  
  * CHOOSE
    * 액세스되는 테이블 중 적어도 하나에 통계정보가 있다면 CBO, 그중에서도 all_rows 모드를 선택; 어느 테이블에도 통계정보가 없으면 RBO 선택
* 옵티마이저 모드 선택
  * 과거의 컨벤션 
    * OLTP : first_rows
    * OLAP : all_rows
  * 요즘의 컨벤션
    * OLTP : all_rows
    * OLAP : all_rows
  * OLTP가 all_rows로 바뀐 이유
    * 요즘은 오픈 커서를 사용하지 않고, rownum 등을 활용하여 페이징처리 한다
    * 페이징처리는 전체 결과집합에서 특정 건수만 fetch하는게 아니라, 전체결과집합 자체를 작게 만들어서 모두 fetch하는 형태이기 때문에 all_rows가 적합하다

<br>
<hr>
<br>

## 옵티마이저 행동에 영향을 미치는 요소
#### 

<br>

### SQL과 연산자 형태

<br>
<hr>
<br>
