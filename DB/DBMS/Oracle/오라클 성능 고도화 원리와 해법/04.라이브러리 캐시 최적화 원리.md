# 라이브러리 캐시 최적화 원리
> DBMS가 SQL을 처리하는 과정 (SQL 파싱과 최적화 단계)
* Parse Call을 일으키지 않고 SQL을 처리하는 방법
* Static SQL과 Dynamic SQL의 의미

<hr>
<br>

## SQL과 옵티마이저
#### 사용자 - (SQL) - 옵티마지어 - (실행계획) - 프로시저

<br>

### 옵티마이저의 최적화 수행단계

<div align="center">
  <img width="50%" src="https://github.com/PoSungKim/development_study/assets/37537227/e8101259-bb19-4e70-b47b-2efa518b7a45" />
</div>

* 사용자가 던진 쿼리수행을 위해, 후보군이 될만한 실행계획들을 찾아낸다
* 데이터 딕셔너리 (Data Dictionary)에 미리 수집해 놓은 (Dynamic Sampling 기능은 논외로 함) 오브젝트 통계 및 시스템 통계정보를 이용해 각 실행계획의 예상비용을 산정한다
* 각 실행계획의 비용을 비교해서 최소비용을 갖는 하나를 선택한다

<br>
<hr>
<br>

## SQL 처리 과정
#### 사용자가 SQL문을 던지면 오라클은 SQL 파싱을 거친 후 해당 SQL이 메모리에 캐싱 되어 있는지 먼저 확인
#### 만약, 메모리에서 찾으면 바로 실행; 아니면, 최적화 단계를 거친다

<br>

### SQL 처리 과정

<div align="center">
  <img width="50%" src="https://github.com/PoSungKim/development_study/assets/37537227/2124b7b7-ac71-42a1-a687-82eef12985fc" />
</div>

* 파싱 단계에서 SQL 커서를 메모리에서 찾아서 바로 실행단계로 넘어가는 것을 소프트 파싱 (Soft Parsing)
* 못 찾아서 (라이브러리 캐시 Miss) 최적화 및 Row-Source 생성 단계를 거치는 것을 하드 파싱 (Hard Parsing)
  * Hard 하다고 표현하는 이유는 최적화 (Optimization)이 그만큼 무거운 처리과정을 거치기 때문

<br>

### SQL 파싱
* SQL Parser
  * Syntax 체크
    * 파싱 트리 생성 (SQL 문장을 이루는 개별 구성요소를 분석하고 파싱 (Totenize)하여)
  * Semantic 체크
    * 존재하지 않거나 권한이 없는 오브젝트를 사용하거나 존재하지 않는 칼럼을 참조하거나
  * Shared Pool에 SQL 커서 캐싱여부 체크
    * 해싱 알고리즘
    * Shared Pool에 있더라도 파싱 요청한 사용자가 다르거나 옵티마지어 관련 파라미터 설정이 다르다면 새로운 SQL 커서 생성 필요

<br>

### SQL 최적화
* Optimizer
  * 시스템 통계 및 오브젝트 통계정보를 판단기준으로 삼아 다양한 액세스 경로 (Access Path)를 비교하고 그 중 가장 효율적인 실행계획을 선택해주는 DBMS의 핵심 엔진
    * Query Transformer 
      * 사용자가 던진 SQL을 그대로 둔 채 최적화하는게 아니라 우선 최적화하기 쉬운 형태로 변환을 시도한다
    * Plan Generator 
      * 하나의 쿼리를 수행하는데 있어, 후보군이 될만한 실행계획들을 생성해 내는 역할을 한다
    * Estimator
      * 쿼리 오퍼레이션 각 단계의 선택도 (Selectivity), 카디널리티 (Cardinality), 비용 (Cost)을 계산하고, 실행계획 전체에 대한 총 비용을 계산한다
      * 각 단계를 수행하는데 필요한 I/O, CPU, 메모리 사용량 등을 예측하기 위해 데이터베이스 오브젝트 (테이블, 인덱스 등) 통계정보와 하드웨어적인 시스템 성능 통계정보 (CPU 속도, Single Block Read Time, Multiblock Read Time 등)를 이용한다
* 실행계획의 어려움
  * 실행계획 경우의 수 = (액세스 경로) x (조인 방식) x (조인 순서)
  * 적응적 탐색 전략 (Adaptive Search Strategy)
  * Multiple Initial Orderings Heuristic

<br>

### Row-Source Generation 
* Row-Source Generator
  * 옵티마이저의 최적화 과정을 거치면 SQL 처리과정을 개념적으로 표현한 실행계획이 생성됨
  * 실행 가능한 코드 또는 프로시저 형태로 포맷팅하는 작업이 필요
* Row-Source
  * 레코드 집합을 반복 처리하면서 사용자가 요구한 최종 결과집합을 실제적으로 생성하는데 사용되는 제어 구조를 말함
* Hard Parsing
  * DBMS는 대부분 DB I/O작업이지만, Hard Parsing은 CPU를 많이 소비하는 작업
  * Shared Pool과 라이브러리 캐시에 대해 발생하는 래치 경합도 CPU를 많이 소비하는 작업
  * Shared Pool에서 데이터 딕셔너리 조회를 하는 것도 CPU를 많이 소비하는 작업
* 이렇게 무거운 작업이기 때문에, 한 번 얻은 SQL 실행계획 재활용 필요
  * 파싱 과정을 거친 SQL 커서를 재사용할 수 있게 캐싱해두는 공간이 라이브러리 캐시

<br>
<hr>
<br>

## 라이브러리 캐시 구조
#### 라이브러리 캐시는 Shared Pool 내에 위치하며, SQL 공유 커서 및 데이터베이스 오브젝트 (테이블, 인덱스 등)에 대한 정보를 관리한다
#### 정보의 단위를 라이브러리 캐시 오브젝트 (LCO)라고 부른다

<br>

### 라이브러리 캐시 구조
* SQL 커서
  * 하드 파싱 과정을 거쳐 메모리에 적재된 SQL과 Parse Tree, 실행계획, 그리고 그것을 실행하는데 필요한 정보를 담은 SQL Area
* 실행가능 LCO
  * SQL 커서, PL/SQL 오브젝트 등등
* 오브젝트 LCO
  * 참조하는 테이블, 인덱스, 클러스터 같은 데이터베이스 오브젝트 정보들도 동등하게 하나의 오브젝트로서 관리
* 생성 후 Drop까지 영구적인 오브젝트 정보 (Stored Object)
  * 테이블, 인덱스, 클러스터, 뷰, 트리거, 패키지, 사용자 정의 함수/프로시저
  * 생성될 때 이름을 갖는다
* 일시적인 오브젝트 정보 (Transient Object)
  * 커서, Anonymous PL/SQL
  * 전체 문자열 그대로가 이름이 된다
* 라이브러리 캐시는 데이터 딕셔너리 캐시와 함께 Shared Pool에 할당된 메모리 공간을 사용한다
  * Shared Pool은 DB 버퍼 캐시처럼 LRU 알고리즘으로 관리 (재사용 빈도가 낮은 SQL부터 없앤다)
* Shared Pool 래치
  * Shared Pool에서 특정 오브젝트 정보 혹은 SQL 커서를 위한 Free Chunk를 할당 받을 때 래치 필요

<div align="center">
  <img width="50%" src="https://github.com/PoSungKim/development_study/assets/37537227/5a79dbf1-152a-47da-9790-1bc445f967a0" />
</div>

* 오브젝트 LCO
  * emp 테이블 정보
* 실행가능 LCO
  * SQL 커서
* Parent 커서 밑에 다중 Child 커서가 연결되는 구조
  * SQL문은 동일하나, 별도의 커서가 생성되어야 할 때 생성되는 구조
* library cache 래치
  * cache buffers chains 래치처럼, 라이브러리 캐시 체인을 탐색하고 변경할 때 획득 필요
* library cache lock, library cache pin 대기이벤트
  * 버터 Lock처럼, LCO에 접근할 때는 LCO 핸들에 대한 Lock을 획득한 이후에 LCO의 실제 내용이 담긴 힙에서 정보를 읽거나 변경할 때는 Pin을 걸어야 한다
* SQL 튜닝 기법 3가지
  * 커서를 공유할 수 있는 형태로 SQL을 작성한다 (바인드 변수 사용하여 하드파싱 발생 예방)
  * 세션 커서 캐싱 기능을 통해 라이브러리 캐시에서 SQL을 찾는 비용을 줄인다
  * 애플리케이션 커서 캐싱을 이용해 Parse Call 발생량을 줄인다

<br>
<hr>
<br>
