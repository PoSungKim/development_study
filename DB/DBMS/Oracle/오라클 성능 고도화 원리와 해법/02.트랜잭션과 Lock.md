# 트랜잭션과 Lock
> 오라클은 읽기 일관성을 구현할 때 Lock이 아닌, Undo 데이터를 이용해 구현한다는 것이 핵심
* DB2, SQL Server, Sybase 등은 Lock을 통해 읽기 일관성 구현

<hr>
<br>

## 트랜잭션 동시성 제어
#### 

<br>

### 동시성 제어 (Concurrency Control)
* 동시성 (Concurrency)과 일관성 (Consistency)은 Trade-off 관계
  * 동시성 : 다중 사용자가 같은 데이터를 동시에 엑세스
  * 일관성 : 자신이 발생시킨 변경 사항과 다른 트랜잭션의 변경 사항을 포함해 일관성 있는 상태로 데이터를 제공

<br>

### 트랜잭션이란? 
* 여러 개의 수정작업이 하나의 작업처럼 전부 처리되거나 아예 전부 처리가 안 되도록 (All or Nothing)하는 것
  * 이러한 일의 최소 단위가 트랜잭션 (원자성)

<br>

### 트랜잭션 특징 (ACID)
* 원자성 (Atomicity)
  * All or Nothing, 더 이상 분해가 불가능한 업무의 최소단위를 말한다
* 일관성 (Consistency)
  * 트랜잭션이 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환한다
* 격리성 (Isolation)
  * 트랜잭션이 실행 중에 생성하는 연산의 중간 결과는 다른 트랜잭션이 접근할 수 없다
* 영속성 (Durability)
  * 트랜잭션이 일단 그 실행을 성공적으로 완료하면 그 결과는 데이터베이스에 영속적으로 저장된다
* 데이터의 일관성을 해치지 않기 위해 DBMS가 공통적으로 사용하는 매커니즘이 Lock이며, 오라클은 읽기 일관성을 보장하기 위해 Undo 데이터를 활용한다

<br>
<hr>
<br>

## 트랜잭션 수준 읽기 일관성
#### 

<br>

### 트랜잭션 수준 읽기 일관성이란?
* 문장 수준 읽기 일관성 (Statement-Level Read Consistency)
  * 쿼리가 시작된 시점을 기준으로 데이터를 일관성 있게 읽어들이는 것
  * 오라클이 완벽히 보장한다고 한다
* 트랜잭션 수준 읽기 일관성 (Transaction-Level Read Consistency)
  * 트랜잭션이 시작된 시점을 기준으로 일관성 있게 데이터를 읽어들이는 것
  * 오라클이 기본적으로 보장하지 않아서 트랜잭션 고립화 수준을 높여야 한다

<br> 

### 트랜잭션 고립화 수준
* ANSI/ISO SQL Standard(SQL92)
  * Level 0 (Read Uncommitted)
    * 트랜잭션에서 처리 중인, 아직 커밋되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용
    * Dirty Read, Non-Repeatable Read, Phantom Read
    * Oracle 지원 X
  * Level 1 (Read Committed)
    * 트랜잭션이 커밋되어 확정된 데이터만 읽는 것을 허용
    * Non-Repeatable Read, Phantom Read
    * 대부분의 DBMS 기본모드 (Oracle 포함)
      * DB2, SQL Server, Sybase
        * 하나의 레코드를 읽을 때 읽기 공유 락 (Shared Lock)을 설정하고 해당 레코드를 빠져나갈 때 Lock 해제
      * Oracle
        * Lock을 사용하지 않고, 쿼리시작 시점의 Undo 데이터 제공
  * Level 2 (Repeatable Read)
    * 선행 트랜잭션이 읽은 데이터는 트랜잭션이 종료될 때까지 후행 트랜잭션이 갱신하거나 삭제하는 것을 불허함으로써 같은 데이터를 두 번 쿼리했을 때 일관성 있는 결과를 리턴
    * Phantom Read
    * DB2, SQL Server, Sybase
      * 읽은 데이터에 걸린 공유 Lock을 커밋할 때까지 유지하는 방식으로 구현
    * Oracle 지원 X
      * SELECT FOR UPDATE절을 이용해 구현가능
  * Level 3 (Serializable)
    * 선행 트랜잭션이 읽은 데이터를 후행 트랜잭션이 갱신하거나 삭제하지 못할 뿐만 아니라 중간에 새로운 레코드를 삽입하는 것도 막아줌
    * 완벽한 읽기 일관성 모드 제공

<br>

### Dirty Read(= Uncommitted Dependency)
* 아짓 커밋되지 않은 수정 중인 데이터를 다른 트랜잭션에서 읽게 되면 (즉, Dirty Read를 허용하면), 비일관성이 발생할 수밖에 없다
  * 어떠한 이유로든, 롤백이 발생할 수 있기 때문

<br>

### Non-Repeatable Read(= Inconsistent Analysis)
* 한 트랜잭션 내에서 같은 쿼리를 2번 수행할 때, 그 사이에 다른 트랜잭션이 값을 수정 또는 삭제함으로써 두 쿼리의 결과가 상이하게 나타나는 비일관성 발생

<div align="center">
 <img width="50%" src="https://github.com/PoSungKim/development_study/assets/37537227/8367de21-73d4-4ba2-8618-6ec6067cb1ff" />
</div>

* Non-Repeatable Read가 발생하면, 중간에 TX2로 인해 당월주문금액이 변경되어서 해당 고객이 A등급이 되어도, TX1에서는 이미 `:amt` 값을 가지고 있어서 A등급이 아니라, B등급이 되어버린다
  * 즉, Lost Update 발생
* 이를 방지하기 위해서는 TX1의 SELECT절을 FOR UPDATE절로 변경해야 한다
  * TX2는 TX1이 설정한 레코드 Lock을 기다렸다가, TX1이 COMMIT 후 레코드 Lock 해제가 되면 TX2가 실행되어 결과적으로 해당 고객의 등급은 A등급이 된다
* 바로 UPDATE를 했으면, DB버퍼 캐시 블록의 Record Byte와 ITL 슬롯, UNDO 세그먼트의 트랜젝션 테이블 슬롯에 락이 걸려서 TX2가 TX1을 대기해야 했을텐데, 선 SELECT 후 UPDATE 였기 때문에 SELECT FOR UPDATE로 락을 잡아주는 것이 비즈니스적으로 그리고 시스템적으로 옳다
 
<div align="center">
 <img width="50%" src="https://github.com/PoSungKim/development_study/assets/37537227/c4439a36-484e-47b7-9c53-43d2fb7494cd" />
</div>

* TX1 t1에서 그냥 SELECT만 하면, TX t2,3에서 UPDATE 및 COMMIT 성공적으로 진행한다
  * 이후에 TX1 t4에서 UPDATE 할 때
    * CONSISTENT 모드로 쿼리 SCN과 블록 SCN을 비교하여 쿼리가 시작되었을 존재했던 갱신대상인 계좌번호(123)를 식별한 이후에,
    * CURRENT 모드로 갱신하기 때문에, 계좌번호(123)가 데이터에 접근하는 순간에 이미 COMMIT 되어서 가지고 있던 값인 (잔고 55,000 - 50,000 = 5000원)을 사용한다
    * 따라서, 5000원은 `잔고 >= 10000원` WHERE 조건문을 만족하지 않기 때문에, alert가 발생한다
* 즉, 55,000원이 중간에 5,000원이 되어서 "잔고부족" alert가 발생
  * 사용자 입장에서는 금액이 충분했는데, 갑자기 "잔고부족"이 발생하는 현상을 경험
* 만약, SELECT의 `:balance`를 사용했으면, 상단의 사례와 동일하게 Tx2의 변경사항이 아예 없어지면서 Lost Update 발생

<br>

### Phantom Read
* 한 트랜잭션 안에서 일정범위의 레코드들을 두 번 이상 읽을 때, 첫 번째 쿼리에서 없던 유령(Phantom) 레코드가 두 번째 쿼리에서 나타나는 현상
  * 트랜잭션 도중에 새로운 레코드가 삽입되는 것을 허용하기 때문에 발생

<div align="center">
 <img width="50%" src="https://github.com/PoSungKim/development_study/assets/37537227/0f3f1592-25ec-40d0-b00c-25153426429e" />
</div>

* TX1 트랜잭션이 지역별고객과 연령대별고객을 연속해서 집계하는 도중에 새로운 고객이 TX2 트랜잭션에 의해 등록된 상황
  * 결과적으로, 지역별고객 및 연령대별고객 두 집계 테이블을 통해 총고객수를 조회하면 서로 결과 값이 다른 불일치 상태 발생
* Phantom Read를 방지하기 위해서는 트랜잭션 고립화 수준을 Level3 (Serializable)로 변경 필요
  ```sql
  set transaction isolation level serializable
  ```
  * 다만, 고립화 수준이 올라가면, 데이터 일관성을 확보되지만, 동시성이 떨어진다
* 오라클은 Lock을 전혀 사용하지 않은 상태에서 (1)번과 (2)번 쿼리 모두 SCN 확인 과정을 통해 t1 시점에 존재했던 고객만으로 대상으로 집계를 수행하므로 동시성을 저하시키지 않으면서 일관성을 유지한다

<div align="center">
 <img width="50%" src="https://github.com/PoSungKim/development_study/assets/37537227/abeea036-9a41-4330-8db4-a052509350c8" />
</div>

* 원래 의도
  * TX1에서 INSERT한 로그까지만 포함해서 DELETE
* 실제 연산
  * TX2 t2,3에서 INSERT한 로그까지 모두 포함해서 DELETE
  * INSERT/UPDATE/DELETE은 `CONSISTENT 모드로 갱신대상을 식별하고, CURRENT 모드로 갱신`하기 때문
* 해결방안
  * Isolation Level을 3 (Serializable)로 변경
  * TX1 INSERT/DELETE문에 일시 조건 추가 

<div align="center">
 <img width="50%" src="https://github.com/PoSungKim/development_study/assets/37537227/88b2f325-126d-4262-870c-3160f4b528c0" />
</div>

* 보편적인 DBMS의 그래프
* 다만, 오라클은 고립화 수준 (Isolation Level)이 올라가도, Lock을 사용하지 않으므로 동시성이 저하되지는 않는다

<div align="center">
 <img width="50%" src="https://github.com/PoSungKim/development_study/assets/37537227/f17a586b-19af-4b8c-acc4-dfc4dff00ffe" />
</div>

* Serializable_aborts (ORA-08177)
  * 시작데이터 : 고객번호(5)의 잔고(1,000)
  * Serializable 미변경 : 고객번호(5)의 잔고 (2,500)
  * Serializable 변경 : 고객번호(5)의 잔고 (1,500)
    * Lost Update가 발생하면서 ORA-08177 발생

<br>

### 비관적 vs. 낙관적 동시성 제어

<br>
<hr>
<br>

