# 트랜잭션과 Lock
> 오라클은 읽기 일관성을 구현할 때 Lock이 아닌, Undo 데이터를 이용해 구현한다는 것이 핵심
* DB2, SQL Server, Sybase 등은 Lock을 통해 읽기 일관성 구현

<hr>
<br>

## 트랜잭션 동시성 제어
#### 

<br>

### 동시성 제어 (Concurrency Control)
* 동시성 (Concurrency)과 일관성 (Consistency)은 Trade-off 관계
  * 동시성 : 다중 사용자가 같은 데이터를 동시에 엑세스
  * 일관성 : 자신이 발생시킨 변경 사항과 다른 트랜잭션의 변경 사항을 포함해 일관성 있는 상태로 데이터를 제공

<br>

### 트랜잭션이란? 
* 여러 개의 수정작업이 하나의 작업처럼 전부 처리되거나 아예 전부 처리가 안 되도록 (All or Nothing)하는 것
  * 이러한 일의 최소 단위가 트랜잭션 (원자성)

<br>

### 트랜잭션 특징 (ACID)
* 원자성 (Atomicity)
  * All or Nothing, 더 이상 분해가 불가능한 업무의 최소단위를 말한다
* 일관성 (Consistency)
  * 트랜잭션이 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환한다
* 격리성 (Isolation)
  * 트랜잭션이 실행 중에 생성하는 연산의 중간 결과는 다른 트랜잭션이 접근할 수 없다
* 영속성 (Durability)
  * 트랜잭션이 일단 그 실행을 성공적으로 완료하면 그 결과는 데이터베이스에 영속적으로 저장된다
* 데이터의 일관성을 해치지 않기 위해 DBMS가 공통적으로 사용하는 매커니즘이 Lock이며, 오라클은 읽기 일관성을 보장하기 위해 Undo 데이터를 활용한다

<br>
<hr>
<br>

## 트랜잭션 수준 읽기 일관성
#### 

<br>

### 트랜잭션 수준 읽기 일관성이란?
* 문장 수준 읽기 일관성 (Statement-Level Read Consistency)
  * 쿼리가 시작된 시점을 기준으로 데이터를 일관성 있게 읽어들이는 것
  * 오라클이 완벽히 보장한다고 한다
* 트랜잭션 수준 읽기 일관성 (Transaction-Level Read Consistency)
  * 트랜잭션이 시작된 시점을 기준으로 일관성 있게 데이터를 읽어들이는 것
  * 오라클이 기본적으로 보장하지 않아서 트랜잭션 고립화 수준을 높여야 한다

<br> 

### 트랜잭션 고립화 수준
* ANSI/ISO SQL Standard(SQL92)
  * Level 0 (Read Uncommitted)
    * 트랜잭션에서 처리 중인, 아직 커밋되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용
    * Dirty Read, Non-Repeatable Read, Phantom Read
    * Oracle 지원 X
  * Level 1 (Read Committed)
    * 트랜잭션이 커밋되어 확정된 데이터만 읽는 것을 허용
    * Non-Repeatable Read, Phantom Read
    * 대부분의 DBMS 기본모드 (Oracle 포함)
      * DB2, SQL Server, Sybase
        * 하나의 레코드를 읽을 때 읽기 공유 락 (Shared Lock)을 설정하고 해당 레코드를 빠져나갈 때 Lock 해제
      * Oracle
        * Lock을 사용하지 않고, 쿼리시작 시점의 Undo 데이터 제공
  * Level 2 (Repeatable Read)
    * 선행 트랜잭션이 읽은 데이터는 트랜잭션이 종료될 때까지 후행 트랜잭션이 갱신하거나 삭제하는 것을 불허함으로써 같은 데이터를 두 번 쿼리했을 때 일관성 있는 결과를 리턴
    * Phantom Read
    * DB2, SQL Server, Sybase
      * 읽은 데이터에 걸린 공유 Lock을 커밋할 때까지 유지하는 방식으로 구현
    * Oracle 지원 X
      * SELECT FOR UPDATE절을 이용해 구현가능
  * Level 3 (Serializable)
    * 선행 트랜잭션이 읽은 데이터를 후행 트랜잭션이 갱신하거나 삭제하지 못할 뿐만 아니라 중간에 새로운 레코드를 삽입하는 것도 막아줌
    * 완벽한 읽기 일관성 모드 제공

<br>

### Dirty Read(= Uncommitted Dependency)
* 아짓 커밋되지 않은 수정 중인 데이터를 다른 트랜잭션에서 읽게 되면 (즉, Dirty Read를 허용하면), 비일관성이 발생할 수밖에 없다
  * 어떠한 이유로든, 롤백이 발생할 수 있기 때문

<br>

### Non-Repeatable Read(= Inconsistent Analysis)
* 한 트랜잭션 내에서 같은 쿼리를 2번 수행할 때, 그 사이에 다른 트랜잭션이 값을 수정 또는 삭제함으로써 두 쿼리의 결과가 상이하게 나타나는 비일관성 발생

<br>

### Phantom Read

<br>
<hr>
<br>
