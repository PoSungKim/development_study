# 트랜잭션과 Lock
> 오라클은 읽기 일관성을 구현할 때 Lock이 아닌, Undo 데이터를 이용해 구현한다는 것이 핵심
* DB2, SQL Server, Sybase 등은 Lock을 통해 읽기 일관성 구현

<hr>
<br>

## 트랜잭션 동시성 제어
#### 

<br>

### 동시성 제어 (Concurrency Control)
* 동시성 (Concurrency)과 일관성 (Consistency)은 Trade-off 관계
  * 동시성 : 다중 사용자가 같은 데이터를 동시에 엑세스
  * 일관성 : 자신이 발생시킨 변경 사항과 다른 트랜잭션의 변경 사항을 포함해 일관성 있는 상태로 데이터를 제공

<br>

### 트랜잭션이란? 
* 여러 개의 수정작업이 하나의 작업처럼 전부 처리되거나 아예 전부 처리가 안 되도록 (All or Nothing)하는 것
  * 이러한 일의 최소 단위가 트랜잭션 (원자성)

<br>

### 트랜잭션 특징 (ACID)
* 원자성 (Atomicity)
  * All or Nothing, 더 이상 분해가 불가능한 업무의 최소단위를 말한다
* 일관성 (Consistency)
  * 트랜잭션이 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환한다
* 격리성 (Isolation)
  * 트랜잭션이 실행 중에 생성하는 연산의 중간 결과는 다른 트랜잭션이 접근할 수 없다
* 영속성 (Durability)
  * 트랜잭션이 일단 그 실행을 성공적으로 완료하면 그 결과는 데이터베이스에 영속적으로 저장된다
* 데이터의 일관성을 해치지 않기 위해 DBMS가 공통적으로 사용하는 매커니즘이 Lock이며, 오라클은 읽기 일관성을 보장하기 위해 Undo 데이터를 활용한다

<br>
<hr>
<br>

## 트랜잭션 수준 읽기 일관성
#### 

<br>

### 트랜잭션 수준 읽기 일관성이란?
* 문장 수준 읽기 일관성 (Statement-Level Read Consistency)
  * 쿼리가 시작된 시점을 기준으로 데이터를 일관성 있게 읽어들이는 것
  * 오라클이 완벽히 보장한다고 한다
* 트랜잭션 수준 읽기 일관성 (Transaction-Level Read Consistency)
  * 트랜잭션이 시작된 시점을 기준으로 일관성 있게 데이터를 읽어들이는 것
  * 오라클이 기본적으로 보장하지 않아서 트랜잭션 고립화 수준을 높여야 한다

<br> 

### 트랜잭션 고립화 수준
* ANSI/ISO SQL Standard(SQL92)
  * Level 0 (Read Uncommitted)
    * 트랜잭션에서 처리 중인, 아직 커밋되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용
    * Dirty Read, Non-Repeatable Read, Phantom Read
    * Oracle 지원 X
  * Level 1 (Read Committed)
    * 트랜잭션이 커밋되어 확정된 데이터만 읽는 것을 허용
    * Non-Repeatable Read, Phantom Read
    * 대부분의 DBMS 기본모드 (Oracle 포함)
      * DB2, SQL Server, Sybase
        * 하나의 레코드를 읽을 때 읽기 공유 락 (Shared Lock)을 설정하고 해당 레코드를 빠져나갈 때 Lock 해제
      * Oracle
        * Lock을 사용하지 않고, 쿼리시작 시점의 Undo 데이터 제공
  * Level 2 (Repeatable Read)
    * 선행 트랜잭션이 읽은 데이터는 트랜잭션이 종료될 때까지 후행 트랜잭션이 갱신하거나 삭제하는 것을 불허함으로써 같은 데이터를 두 번 쿼리했을 때 일관성 있는 결과를 리턴
    * Phantom Read
    * DB2, SQL Server, Sybase
      * 읽은 데이터에 걸린 공유 Lock을 커밋할 때까지 유지하는 방식으로 구현
    * Oracle 지원 X
      * SELECT FOR UPDATE절을 이용해 구현가능
  * Level 3 (Serializable)
    * 선행 트랜잭션이 읽은 데이터를 후행 트랜잭션이 갱신하거나 삭제하지 못할 뿐만 아니라 중간에 새로운 레코드를 삽입하는 것도 막아줌
    * 완벽한 읽기 일관성 모드 제공

<br>

### Dirty Read(= Uncommitted Dependency)
* 아짓 커밋되지 않은 수정 중인 데이터를 다른 트랜잭션에서 읽게 되면 (즉, Dirty Read를 허용하면), 비일관성이 발생할 수밖에 없다
  * 어떠한 이유로든, 롤백이 발생할 수 있기 때문

<br>

### Non-Repeatable Read(= Inconsistent Analysis)
* 한 트랜잭션 내에서 같은 쿼리를 2번 수행할 때, 그 사이에 다른 트랜잭션이 값을 수정 또는 삭제함으로써 두 쿼리의 결과가 상이하게 나타나는 비일관성 발생

<div align="center">
 <img width="50%" src="https://github.com/PoSungKim/development_study/assets/37537227/8367de21-73d4-4ba2-8618-6ec6067cb1ff" />
</div>

* Non-Repeatable Read가 발생하면, 중간에 TX2로 인해 당월주문금액이 변경되어서 해당 고객이 A등급이 되어도, TX1에서는 이미 `:amt` 값을 가지고 있어서 A등급이 아니라, B등급이 되어버린다
  * 즉, Lost Update 발생
* 이를 방지하기 위해서는 TX1의 SELECT절을 FOR UPDATE절로 변경해야 한다
  * TX2는 TX1이 설정한 레코드 Lock을 기다렸다가, TX1이 COMMIT 후 레코드 Lock 해제가 되면 TX2가 실행되어 결과적으로 해당 고객의 등급은 A등급이 된다
* 바로 UPDATE를 했으면, DB버퍼 캐시 블록의 Record Byte와 ITL 슬롯, UNDO 세그먼트의 트랜젝션 테이블 슬롯에 락이 걸려서 TX2가 TX1을 대기해야 했을텐데, 선 SELECT 후 UPDATE 였기 때문에 SELECT FOR UPDATE로 락을 잡아주는 것이 비즈니스적으로 그리고 시스템적으로 옳다
 
<div align="center">
 <img width="50%" src="https://github.com/PoSungKim/development_study/assets/37537227/c4439a36-484e-47b7-9c53-43d2fb7494cd" />
</div>

* TX1 t1에서 그냥 SELECT만 하면, TX t2,3에서 UPDATE 및 COMMIT 성공적으로 진행한다
  * 이후에 TX1 t4에서 UPDATE 할 때
    * CONSISTENT 모드로 쿼리 SCN과 블록 SCN을 비교하여 쿼리가 시작되었을 존재했던 갱신대상인 계좌번호(123)를 식별한 이후에,
    * CURRENT 모드로 갱신하기 때문에, 계좌번호(123)가 데이터에 접근하는 순간에 이미 COMMIT 되어서 가지고 있던 값인 (잔고 55,000 - 50,000 = 5000원)을 사용한다
    * 따라서, 5000원은 `잔고 >= 10000원` WHERE 조건문을 만족하지 않기 때문에, alert가 발생한다
* 즉, 55,000원이 중간에 5,000원이 되어서 "잔고부족" alert가 발생
  * 사용자 입장에서는 금액이 충분했는데, 갑자기 "잔고부족"이 발생하는 현상을 경험
* 만약, SELECT의 `:balance`를 사용했으면, 상단의 사례와 동일하게 Tx2의 변경사항이 아예 없어지면서 Lost Update 발생

<br>

### Phantom Read
* 한 트랜잭션 안에서 일정범위의 레코드들을 두 번 이상 읽을 때, 첫 번째 쿼리에서 없던 유령(Phantom) 레코드가 두 번째 쿼리에서 나타나는 현상
  * 트랜잭션 도중에 새로운 레코드가 삽입되는 것을 허용하기 때문에 발생

<div align="center">
 <img width="50%" src="https://github.com/PoSungKim/development_study/assets/37537227/0f3f1592-25ec-40d0-b00c-25153426429e" />
</div>

* TX1 트랜잭션이 지역별고객과 연령대별고객을 연속해서 집계하는 도중에 새로운 고객이 TX2 트랜잭션에 의해 등록된 상황
  * 결과적으로, 지역별고객 및 연령대별고객 두 집계 테이블을 통해 총고객수를 조회하면 서로 결과 값이 다른 불일치 상태 발생
* Phantom Read를 방지하기 위해서는 트랜잭션 고립화 수준을 Level3 (Serializable)로 변경 필요
  ```sql
  set transaction isolation level serializable
  ```
  * 다만, 고립화 수준이 올라가면, 데이터 일관성을 확보되지만, 동시성이 떨어진다
* 오라클은 Lock을 전혀 사용하지 않은 상태에서 (1)번과 (2)번 쿼리 모두 SCN 확인 과정을 통해 t1 시점에 존재했던 고객만으로 대상으로 집계를 수행하므로 동시성을 저하시키지 않으면서 일관성을 유지한다

<div align="center">
 <img width="50%" src="https://github.com/PoSungKim/development_study/assets/37537227/abeea036-9a41-4330-8db4-a052509350c8" />
</div>

* 원래 의도
  * TX1에서 INSERT한 로그까지만 포함해서 DELETE
* 실제 연산
  * TX2 t2,3에서 INSERT한 로그까지 모두 포함해서 DELETE
  * INSERT/UPDATE/DELETE은 `CONSISTENT 모드로 갱신대상을 식별하고, CURRENT 모드로 갱신`하기 때문
* 해결방안
  * Isolation Level을 3 (Serializable)로 변경
  * TX1 INSERT/DELETE문에 일시 조건 추가 

<div align="center">
 <img width="50%" src="https://github.com/PoSungKim/development_study/assets/37537227/88b2f325-126d-4262-870c-3160f4b528c0" />
</div>

* 보편적인 DBMS의 그래프
* 다만, 오라클은 고립화 수준 (Isolation Level)이 올라가도, Lock을 사용하지 않으므로 동시성이 저하되지는 않는다

<div align="center">
 <img width="50%" src="https://github.com/PoSungKim/development_study/assets/37537227/f17a586b-19af-4b8c-acc4-dfc4dff00ffe" />
</div>

* Serializable_aborts (ORA-08177)
  * 시작데이터 : 고객번호(5)의 잔고(1,000)
  * Serializable 미변경 : 고객번호(5)의 잔고 (2,500)
  * Serializable 변경 : 고객번호(5)의 잔고 (1,500)
    * TX2의 UPDATE문에 대한 Lost Update가 발생하면서 ORA-08177 발생

<br>
<hr>
<br>

## 비관적 vs. 낙관적 동시성 제어
#### 동시성 제어 = {비관적 동시성 제어, 낙관적 동시성 제어}

<br>

### 비관적 vs. 낙관적 동시성 제어
* 비관적 동시성 제어 (Pessimistic Concurrency Control)
  * 사용자들이 같은 데이터를 동시에 수정할 것이라고 가정
  * 한 사용자가 데이터를 읽는 시점에 Lock을 걸고 조회 또는 갱신처리가 완료될 때까지 유지
* 낙관적 동시성 제어 (Optimistic Concurrency Control)
  * 사용자들이 같은 데이터를 동시에 수정하지 않을 것이라고 가정
  * 읽는 시점에 Lock을 사용하지는 않지만, 데이터를 수정하고자 하는 시점에 앞서 읽은 데이터가 다른 사용에 의해 변경되었는지를 반드시 검사
* 동시성 제어가 있는 낙관적 프로그램밍
  ```sql
  INSERT INTO 주문
  SELECT :상품코드, :고객ID, :주문일시, :상점번호, ...
  FROM   상품
  WHERE  상품코드 = :상품코드
  AND    가격 = :가격; -- 주문을 시작한 시점 가격
  
  if sql%rowcount = 0 then;
    alert('상품가격이 변경되었습니다.');
  else if;
  ```
  * 주문 쿼리가 시작된 시점의 가격으로 상품 조회해서 주문에 등록한다
    * 상품 조회 시에 1,000원이었던 상품이 주문을 진행하는 동안, 가격이 수정돼서 결제를 완료하는 순간에는 1,200원으로 변경되는 상황
    * INSERT 0건이 발생하고, sql%rowcount는 0건이 된다

<br>

### 비관적 동시성 제어
* 비관적 동시성 제어를 위한 기본적인 구현 패턴
* 상황
  * 우수 고객을 대상으로 적립포인트를 추가시켜주는 이벤트를 실시한다고 가정
* 일관성 문제점
  * 고객의 다양한 실적정보를 읽고 복잡한 산출공식을 이용해 적립포인트를 계산하는 동안 (SELECT문 이후와 UPDATE문 이전 사이)
  * 다른 트랜잭션이 같은 고객레코드를 변경한다면 문제 발생 가능

```sql
SELECT 적립포인트, 방문횟수, 최근방문일시, 구매실적
FROM   고객
WHERE  고객번호 = :cust_nm
FOR UPDATE

-- 새로운 적립포인트 계산

UPDATE 고객
SET    적립포인트 = :적립포인트
WHERE  고객번호  = :cust_num
```

* 일관성 해결점
  * SELECT FOR UPDATE로 해당 고객 레코드에 Lock 설정하면 데이터 일관성 유지 가능
* 동시성 우려점
  * SELECT 시점에 Lock을 거는 비관적 동시성 제어는 시스템 동시성을 떨어트림
* 동시성 해결점
  * WAIT or NOWAIT 옵션을 함께 사용

```sql
SELECT
...
FOR UPDATE NOWAIT  -- 대기없이 Exception(ORA-00054)을 던짐

FOR UPDATE WAIT 3  -- 3초 대기 후 Exception(ORA-3006)을 던짐
```
* 해당 Exception을 Catch해서 "다른 사용자에 의해 변경 중이므로 다시 시도하십시오."라는 메세지로 다시 Throw 가능
* 금융권에서는 SELECT FOR UPDATE 자주 사용

<br>

### 낙관적 동시성 제어
* Lock을 걸지 않되, 중간에 변경사항이 있으면 UPDATE 0건이 되는 패턴
* 예시1)
  * SELECT로 조회한 정보들로 UPDATE WHERE절에 모두 포함시키는 예시
```sql
SELECT 적립포인트, 방문횟수, 최근방문일시, 구매실적 INTO :a, :b, :c, :d
FROM   고객
WHERE  고객번호 = :cust_num;

-- 새로운 적립포인트 계산

UPDATE 고객 SET 적립포인트 = :적립포인트
WHERE  고객번호 = :cust_num
AND    적립포인트 = :a
AND    방문횟수 = :b
AND    최근방문일시 = :c
AND    구매실적 = :d ;

if sql%rowcount = 0 then
  alert('다른 사용자에 의해 변경되었습니다.');
end if;
```

* 예시2)
  * 테이블의 최종변경일시를 관리하는 칼럼을 활용하는 예시
```sql
SELECT 적립포인트, 방문횟수, 최근방문일시, 구매실적, 변경일시
INTO :a, :b, :c, :d, :mod_dt
FROM   고객
WHERE  고객번호 = :cust_num;

-- 새로운 적립포인트 계산

UPDATE 고객 SET 적립포인트 = :적립포인트, 변경일시 = SYSDATE
WHERE  고객번호 = :cust_num
AND    변경일시 = :mod_dt; -- 최종 변경일시가 앞서 읽은 값과 같은지 비교

if sql%rowcount = 0 then
  alert('다른 사용자에 의해 변경되었습니다.');
end if;
```

* 예시3)
  * 예시2) += 다른 트랜잭션에 의해 설정된 Lock 때문에 동시성이 저하되는 것을 예방하는 예시
  * SELECT FOR UPDATE 활용
```sql
SELECT 적립포인트, 방문횟수, 최근방문일시, 구매실적, 변경일시
INTO   :a, :b, :c, :d, :mod_dt
FROM   고객
WHERE  고객번호 = :cust_num;

-- 새로운 적립포인트 계산

SELECT 고객번호
FROM   고객
WHERE  고객번호 = :cust_num;
AND    변경일시 = :mod_dt
FOR UPDATE NOWAIT;

UPDATE 고객 SET 적립포인트 = :적립포인트, 변경일시 = SYSDATE
WHERE  고객번호 = :cust_num
AND    변경일시 = :mod_dt; -- 최종 변경일시가 앞서 읽은 값과 같은지 비교

if sql%rowcount = 0 then
  alert('다른 사용자에 의해 변경되었습니다.');
end if;
```
* 별도의 Timestamp 칼럼을 두고 관리할 때, 규칙을 제대로 지키지 않으면 Lost Update 문제가 발생할 수 있음
  * Pseudo 칼럼 ora_rowscn을 활용 가능
```sql
SELECT e.empno, e.ename, ORA_ROWSCN, SCN_TO_TIMESTAMP(ORA_ROWSCN)
FROM   emp e;
```
* 다만, ora_rowscn Pseudo 칼럼을 이용하기 위해서는 하단의 설정 필요
  * 이 옵션을 사용해야 로우 단위로 SCN 기록
    * 기본값 (NoRowDependencies)이면, 블록 단위의 SCN이 출력되고 레코드 하나만 변경해도 블록 내 모든 레코드의 ora_rowscn이 변경되기 때문에, 옵션 변경 필요
```sql
CREATE TABLE t
ROWDEPENDENCIES
AS
SELECT * FROM scoot.emp;
```
* 예시4)
  * Row 단위 SCN을 변경시점으로 활용한 예시
```sql
SELECT 적립포인트, 방문횟수, 최근방문일시, 구매실적, ora_rowscn
INTO   :a, :b, :c, :d, :rowscn
FROM   고객
WHERE  고객번호 = :cust_num;

-- 새로운 적립포인트 계산

UPDATE 고객 SET 적립포인트 = :적립포인트
WHERE  고객번호 = :cust_num
AND    ora_rowscn = :rowscn;

if sql%rowcount = 0 then
  alert('다른 사용자에 의해 변경되었습니다.');
end if;
```

<br>
<hr>
<br>

