# 쿼리 변환
> 
* 

<hr>
<br>

## 쿼리 변환이란?
#### 쿼리 옵티마이저가 SQL을 분석해 의미적으로 동일하면서도 더 나은 성능이 기대되는 형태로 재작성하는 것

<br>

### 쿼리 변환이란?
* 간단한 쿼리문도 52개의 다른 SQL로 표현 가능
  * 변환 전 쿼리 예시)
      ```sql
      SELECT DISTINCT S.SNAME
      FROM   S, SP
      WHERE  S.S#  = SP.S#
      AND    SP.P# = 'P2';
      ```
  * 상단의 쿼리가 하단의 쿼리들로 표현이 될 수 있으며, 결과집합은 동일하지만, 형태에 따라 수행 속도가 다를 수 있다
      ```sql
      SELECT DISTINCT S.SNAME FROM S
      WHERE  S.S# IN (SELECT SP.S# FROM SP WHERE SP.P# = 'P2');
    
      SELECT DISTINCT S.SNAME FROM S WHERE EXISTS
             (SELECT * FROM SP WHERE SP.S# = S.S# AND SP.P# = 'P2');
    
      SELECT DISTINCT S.SNAME FROM S, SP
      WHERE  S.S# = SP.S#
      GROUP BY S.SNAME, SP.P#
      HAVING SP.P# = 'P2';
    
      SELECT DISTINCT S.SNAME FROM S
      WHERE  S.S# = ANY (SELECT SP.S# FROM SP WHERE SP.P# = 'P2' );
    
      SELECT DISTINCT S.SNAME FROM S
      WHERE  (SELECT COUNT(*) FROM SP WHERE SP.S# = S.S# AND SP.P# = 'P2') > 0;
    
      SELECT DISTINCT S.SNAME FROM S, SP
      WHERE  SP.P# = 'P2'
      GROUP BY S.S#, S.SNAME, SP.S#
      HAVING SP.S# = S.S#;
      ```
* 최근의 비용기반 옵티마이저는 사용자 SQL을 최적화에 유리한 형태로 재작성하는 작업을 먼저 한다
  * Optimier의 서브 엔진으로서 존재하는 Query Transformer, Estimator, Plan Generator 중 Query Transformer가 쿼리 변환 역할을 수행한다
 
  <div align="center">
    <img width="80%" src="https://github.com/PoSungKim/development_study/assets/37537227/b0eb6d84-1e03-4879-9e8b-870dd920412a">
  </div>
  
  * ex) 처음에는 하단의 두 쿼리는 수행 속도가 다를 수 있지만, 쿼리 변환이 작동하면 동일한 수행 속도로 맞춰질 수 있다
      ```sql
      select *
      from   dept d
      where  not exists (select 'x'
                         from   emp
                         where  deptno = d.deptno);
    
      select d.*
      from   dept d, emp e
      where  e.deptno(+) = d.deptno
      and    e.rowid is null;
      ```
* 즉, 쿼리 변환 (Query Transformation)은, 쿼리 옵티마이저가 SQL을 분석해 의미적으로 동일하면서도 더 나은 성능이 기대되는 형태로 재작성하는 것을 말한다
* 쿼리 변환 종류
  * 서브쿼리 Unnesting
  * 뷰 Merging
  * 조건절 Pushing
  * 조건절 이행
  * 공통 표현식 제거
  * Outer 조인을 Inner 조인으로 변환
  * 실체화 뷰 쿼리로 재작성
  * Star 변환
  * Outer 조인 뷰에 대한 조인 조건 Pushdown
  * OR-expansion
* 쿼리 변환 방식
  * 휴리스틱 (Heuristic) 쿼리 변환
    * 규칙 기반 (Rule-based)으로 결과만 보장된다면 무조건 쿼리 변환 수행
    * 최소 동일한 성능이 보일 것으로 판단이 반영된 규칙이기 때문
  * 비용기반 (Cost-based) 쿼리 변환
    * 변환된 쿼리의 비용이 더 낮을 때만 쿼리 변환 수행; 아니면, 원본 쿼리 그대로 사용

<br>
<hr>
<br>

## 서브쿼리 Unnesting
#### 옵티마이저가 숲을 바라보는 시각으로 쿼리를 이해하려면 먼저 서브쿼리를 풀어내야만 한다

<br>

### 서브쿼리의 분류
* 분류
  * 인라인 뷰 (Inline View) : from 절에 나타나는 서브쿼리
  * 중첩된 서브쿼리 (Nested Subquery) : 결과집합을 한정하기 위해 where 절에 사용된 서브쿼리
  * 스칼라 서브쿼리 (Scalar Subquery) : 한 레코드당 정확히 하나의 칼럼 값만을 리턴하는 특징이 있는 보통 select-list에 위치한 서브쿼리
* 옵티마이저는 블록 단위로 액세스 경로 (Access Path), 조인 순서 (Join Order), 조인 방식 (Join Method)을 최적화하는 것을 목표로 한다

<br>

### 서브쿼리 Unnesting의 의미
* 중첩된 서브쿼리 (Nested Subquery)를 풀어내는 것을 의미한다
* 메인쿼리와 서브쿼리 간에 종속적이고 계층적인 관계가 존재한다
  * IN, EXISTS 불문하고 필터 방식의 중첩된 서브쿼리 형태이어야 함
    ```sql
    select * from emp a
    where  exists (
        select 'x' from dept
        where  deptno = a.deptno
    )
    and sal > (
        select avg(sal) from emp b
        where  exists (
            select 'x' from salgrade
            where  b.sal between losal and hisal
            and    grade = 4
        )
    );
    ```
* 서브쿼리를 처리함에 있어서 필터 방식이 항상 최적의 수행속도를 보장하지 못하므로 옵티마이저는 하단 둘 중 하나를 선택한다
  * 서브쿼리 Unnesting
    * 동일한 결과를 보장하는 조인문으로 변환하고 나서 최적화 (서브쿼리 Flattening)
    * 쿼리 변환이 이루어지고 나면 일반 조인문처럼 다양한 최적화 기법이 사용가능해진다
  * 서브쿼리 No-Unnesting
    * 원본 쿼리로 메인쿼리와 서브쿼리를 별도의 서브플랜 (Subplan)으로 구분해 각각 최적화를 수행하며, 이때 서브쿼리에 필터 (Filter) 오퍼레이션이 나타난다
    * 쿼리 블록별로 최적화하면 각각의 최적이 쿼리문 전체의 최적을 달성하지 못할 때가 많다
    * Plan Generator가 고려대상으로 삼을만한 다양한 실행계획을 생성해 내는 작업이 매우 제한적인 범위 내에서만 이루어진다
* 서브쿼리의 또 다른 최적화 기법
  * 조건
    * (1) 메인쿼리와 상관관계에 있지 않으면서 (Non-Correlated, 서브쿼리에서 메인 쿼리를 참조하지 않음)
    * (2) 단일 로우를 리턴 (single-row subquery)하는 아래와 같은 형태의 서브쿼리를 처리할 때
  * 최적화 기법
    * 변환 전의 서브쿼리는 Fetch가 아닌 Execute 시점에 먼저 수행하여, 그 결과 값을 메인 쿼리에 상수로 제공하는 방식으로 최적화를 진행한다
  * 예시
    * 변환 전) select * from tab1 where key1 = `(select avg(col1) from tab2)`;
      * 변환 후) select * from tab1 where key1 = `:value1`;
    * 변환 전) select * from tab1 where (key1, key2) = `(select col1, col2 from tab2 where col3 >= 5000 and rownum = 1)`;
      * 변환 후) select * from tab1 where (key1, key2) = `(:value1, :value2)`;

<br>

### 서브쿼리 Unnesting의 이점
* 서브쿼리를 메인쿼리와 같은 레벨로 풀어낸다면 다양한 액세스 경로와 조인 메소드를 평가할 수 있다.
  * 특히 옵티마이저는많은 조인테크닉을 가지기 때문에 조인 형태로 변환했을 때 더 나은 실행계획을 찾을 가능성이 높아진다
* unnest : 서브쿼리를 Unnesting 함으로써 조인방식으로 최적화하도록 유도한다
* no_unnest : 서브쿼리를 그대로 둔 상태에서 필터 방식으로 최적화하도록 유도한다

<br>

### 서브쿼리 Unnesting 기본 예시
* 쿼리 원본
  ```sql
  select * from emp
  where deptno in (select deptno from dept);
  ```
* No Unnesting 쿼리)
  ```sql
  select * from emp
  where deptno in (select /*+ no_unnest */ deptno from dept);
  ```
  
  ```
  Id     Operation                 Name
  ----   -----------------------   --------------
  0      SELECT STATEMENT
  1        FILTER    
  2          TABLE ACCESS FULL     EMP 
  3          INDEX RANGE SCAN      DEPT_PK
  
  Predicate Information (identified by operation id):
  -----------------------------------------------------
  1 - filter ( EXISTS (SELECT 0 FROM "DEPT" "DEPT" WHERE "DEPTNO" = :B1))
  3 - access ("DEPTNO"=:B1)
  ```
  * Unnesting하지 않은 서브쿼리를 수행할 때는 메인 쿼리에서 읽히는 레코드마다 값을 넘기면서 서브쿼리를 반복 수해한다
    * IN 서브쿼리는 내부적으로 EXISTS 서브쿼리로 변환됐다
* Unnesting 쿼리)
  ```sql
  select * from emp
  where deptno in (select /*+ unnest */ deptno from dept);
  ```
  ```sql
  -- Unnesting
  select *
  from  (select deptno from dept) a, emp b
  where b.deptno = a.deptno;
  
  -- Unnesting 후 View 머징 쿼리
  select emp.* from dept, emp
  where  emp.deptno = dept.deptno;
  ```
  ```
  Id     Operation                       Name
  ----   -----------------------------   --------------
  0      SELECT STATEMENT
  1        TABLE ACCESS BY INDEX ROWID   EMP
  2          NESTED LOOP
  3            INDEX FULL SCAN           DEPT_PK
  4            INDEX RANGE SCAN          EMP_DEPTNO_IDX
  
  Predicate Information (identified by operation id):
  -----------------------------------------------------
  4 - access ("DEPTNO"="DEPTNO")
  ```

<br>

### Unnesting된 쿼리의 조인 순서 조정
* Unnesting에 의해 일반 조인문으로 변환된 후에는 emp, dept 어느 쪽이든 드라이빙 집합으로 선택될 수 있다
  ```
  Id     Operation                       Name
  ----   -----------------------------   --------------
  0      SELECT STATEMENT
  1        NESTED LOOP
  2          TABLE ACCESS FULL           EMP
  3          INDEX UNIQUE SCAN           DEPT_PK
  
  Predicate Information (identified by operation id):
  -----------------------------------------------------
  3 - access ("DEPTNO"="DEPTNO")
  ```
* 순서를 임의로 설정하는 방법
  ```sql
  select /*+ leading(emp) */ * from emp
  where deptno in (select /*+ unnest */ deptno from dept);

  select /*+ leading(dept) */ * from emp
  where deptno in (select /*+ unnest */ deptno from dept);

  -- unnesting한 서브쿼리 테이블이 from절에서 메인쿼리 테이블 보다 앞에 위치한다는 것을 알 수 있다
  select /*+ ordered */ * from emp
  where deptno in (select /*+ unnest */ deptno from dept);

  select /*+ leading(dept@qb1) */ * from emp
  where deptno in (select /*+ unnest qb_name(qb1) */ deptno from dept);
  ```
  
<br>

### 서브쿼리가 M쪽 집합이거나 Nonunique 인덱스일 때
* 메인쿼리가 M쪽 집합으로 드라이빙되어서 서브쿼리가 1쪽 집합으로 펄터링되는 원본 쿼리
  ```sql
  select * from emp
  where deptno in (select deptno from dept);
  ```
  * dept 테이블에 Unique 인덱스 및 PK/Unique 제약이 있기 때문에 옵티마이저가 쿼리변환해도 문제가 없다
* 서브쿼리가 M쪽 집합이거나 Nonunique 인덱스이면 쿼리변환이 어떻게 될지 모른다
  ```sql
  select * from dept
  where deptno in (select deptno from emp);

  -- 잘못된 쿼리변환
  select *
  from  (select deptno from emp) a, dept b
  where b.deptno = a.deptno;
  ```
  * dept 테이블이 기준테이블이기 때문에, 결과집합은 dept 테이블의 크기를 넘어가면 안되지만, 만약 쿼리변환이 잘못되면 emp 테이블이 기준테이블로 조인이 되어버리면서 결과집합이 emp 테이블의 크기가 될 수 있다
* Sort Unique 오퍼레이션 수행
  * 1쪽 집합임을 확신할 수 없는 서브쿼리 쪽 테이블이 드라이빙된다면, 먼저 sort unique 오퍼레이션을 수행함으로써 1쪽 집합으로 만든 다음에 조인한다
    ```sql
    alter table dept drop primary key;
    create index dept_deptno_idx on dept(deptno);
    ```
    ```sql
    select * from emp
    where deptno in (select deptno from dept);
    ```
    ```
    Id     Operation                       Name
    ----   -----------------------------   --------------
    0      SELECT STATEMENT
    1        TABLE ACCESS BY INDEX ROWID   EMP
    2          NESTED LOOPS
    3            SORT UNIQUE
    4              INDEX FULL SCAN         DEPT_DEPTNO_IDX
    5            INDEX RANGE SCAN          EMP_DEPTNO_IDX
    
    Predicate Information (identified by operation id):
    -----------------------------------------------------
    3 - access ("DEPTNO"="DEPTNO")
    ```
    ```sql
    -- 쿼리변환
    select b.*
    from   (select /*+ no_merge */ distinct deptno from dept order by deptno) a, emp b
    where  b.deptno = a.deptno;
    ```
* 세미 조인 방식으로 수행
  * 메인 쿼리쪽 테이블이 드라이빙된다면 세미 조인 (Semi Join)방식으로 조인한다
    ```
    Id     Operation                       Name
    ----   -----------------------------   --------------
    0      SELECT STATEMENT
    1        NESTED LOOPS SEMI
    2          TABLE ACCESS FULL           EMP
    3          INDEX RANGE SCAN            DEPT_IDX
    
    Predicate Information (identified by operation id):
    -----------------------------------------------------
    3 - access ("DEPTNO"="DEPTNO")
    ```
  * Sort Unique 오퍼레이션을 수행하지 않고, NL 세미 조인으로 결과집합이 M쪽 집합으로 확장되는 것을 방지하는 알고리즘을 사용한다
    * NL 세미 조인, 해시 세미 조인, 소트머지 세미 조인 모두 가능

<br>

### 필터 오퍼레이션과 세미조인의 캐싱 효과
* 옵티마이저가 쿼리 변환을 수행하는 이유는, 전체적인 시각에서 더 나은 실행계획을 수립할 가능성을 높이는 데에 있다
  * 서브쿼리를 Unnesting해 조인문으로 바꾸고 나면 NL조인, 해시조인, 소트 머지 조인 방식으로 선택할 수 있고, 조인 순서도 자유롭게 선택할 수 있다
* Unnesting을 못하더라도 Filter 오퍼레이션에 캐싱 효과가 있어서 오라클은 최적화하는 방법을 가지고 있다
  * 서브쿼리 수행 결과를 버리지 않고 내부 캐시에 저장하고 있다가 같은 값이 입력되면 저장된 값을 출력하는 방식을 가지고 있다
  ```sql
  select count(*) from t_emp t
  where  exists (select /*+ no_unnest */ 'x' from dept
                 where  deptno = t.deptno and loc is not null);
  ```
* 그런데 Unnesting을 하면 발생하는 NL 세미 조인도 캐싱 효과를 가지게 되면서 Filter 오퍼레이션도 설자리를 잃고 말았다
  ```sql
  select count(*) from t_emp t
  where  exists (select /*+ unnest nl_sj */ 'x' from dept
                 where  deptno = t.deptno and loc is not null);
  ```

<br>

### Anti 조인
* not exists, not in 서브쿼리도 Unnesting하지 않으면 필터 방식으로 처리된다
* exists 필터
  * 조인에 성공하는 (서브) 레코드를 만나는 순간 결과집합에 담고 다른 (메인) 레코드로 이동한다
* not exists 필터
  * 조인에 성공하는 (서브) 레코드를 만나는 순가 버리고 다음 (메인) 레코드로 이동한다. 조인에 성공하는 (서브) 레코드가 하나도 없을 때만 결과집합에 담는다
* Anti 조인 방식 예시)
  ```sql
  select * from dept d
  where  not exists
         (select /*+ unnest nl_aj */ 'x' from emp where deptno = d.deptno;
  ```
  ```
  Id     Operation                         Name
  ----   -------------------------------   --------------
  0      SELECT STATEMENT
  1        NESTED LOOPS ANTI
  2          TABLE ACCESS FULL             DEPT
  3          INDEX UNIQUE SCAN             EMP_DEPTNO_IDX
  ```
  ```sql
  select * from dept d
  where  not exists
         (select /*+ unnest merge_aj */ 'x' from emp where deptno = d.deptno;
  ```
  ```
  Id     Operation                         Name
  ----   -------------------------------   --------------
  0      SELECT STATEMENT
  1        MERGE JOIN ANTI
  2          TABLE ACCESS BY INDEX ROWID   DEPT
  3            INDEX FULL SCAN             DEPT_PK
  4          SORT UNIQUE                   
  5            INDEX FULL SCAN             EMP_DEPTNO_IDX
  ```
  ```sql
  select * from dept d
  where  not exists
         (select /*+ unnest hash_aj */ 'x' from emp where deptno = d.deptno;
  ```
  ```
  Id     Operation                         Name
  ----   -------------------------------   --------------
  0      SELECT STATEMENT
  1        HASH JOIN ANTI
  2          TABLE ACCESS FULL             DEPT
  3          INDEX UNIQUE SCAN             EMP_DEPTNO_IDX
  ```

<br>

### 집계 서브쿼리 제거
* 집계 함수 (Aggregate Function)를 포함하는 서브쿼리를 Unnesting 하고, 이를 다시 분석 함수 (Analytic Function)으로 대체하는 쿼리 변환이 10g에서 도입되었다
  ```sql
  select d.deptno, d.dname, e.empno, e.ename, e.sal
  from   emp e, dept d
  where  d.deptno = e.deptno
  and    e.sal >= (select avg(sal) from emp where deptno = d.deptno);
  ```
  ```sql
  select d.deptno, d.dname, e.empno, e.ename, e.sal
  from   (select deptno, avg(sal) avg_sal from emp group by deptno) x, emp e, dept d
  where  d.deptno = e.deptno
  and    e.deptno = x.deptno
  and    e.sal >= x.avg_sal;
  ```
  ```
  Id     Operation                             Name
  ----   -----------------------------------   --------------
  0      SELECT STATEMENT
  1        VIEW                                VW_WIF_1
  2          WINDOW BUFFER
  3            NESTED LOOPS             
  4              TABLE ACCESS BY INDEX ROWID   EMP                   
  5                INDEX FULL SCAN             EMP_DEPTNO_IDX
  6              TABLE ACCESS BY INDEX ROWID   DEPT                   
  7                INDEX UNIQUE SCAN           DEPT_PK
  ```
  
<br>

### Pushing 서브쿼리

<br>
<hr>
<br>

## 뷰 Merging
#### 

<br>

### 뷰 Merging이란?

<br>

### 단순 뷰(Simple View) Merging

<br>
<hr>
<br>
