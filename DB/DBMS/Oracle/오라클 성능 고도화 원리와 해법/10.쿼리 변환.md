# 쿼리 변환
> 
* 

<hr>
<br>

## 쿼리 변환이란?
#### 쿼리 옵티마이저가 SQL을 분석해 의미적으로 동일하면서도 더 나은 성능이 기대되는 형태로 재작성하는 것

<br>

### 쿼리 변환이란?
* 간단한 쿼리문도 52개의 다른 SQL로 표현 가능
  * 변환 전 쿼리 예시)
      ```sql
      SELECT DISTINCT S.SNAME
      FROM   S, SP
      WHERE  S.S#  = SP.S#
      AND    SP.P# = 'P2';
      ```
  * 상단의 쿼리가 하단의 쿼리들로 표현이 될 수 있으며, 결과집합은 동일하지만, 형태에 따라 수행 속도가 다를 수 있다
      ```sql
      SELECT DISTINCT S.SNAME FROM S
      WHERE  S.S# IN (SELECT SP.S# FROM SP WHERE SP.P# = 'P2');
    
      SELECT DISTINCT S.SNAME FROM S WHERE EXISTS
             (SELECT * FROM SP WHERE SP.S# = S.S# AND SP.P# = 'P2');
    
      SELECT DISTINCT S.SNAME FROM S, SP
      WHERE  S.S# = SP.S#
      GROUP BY S.SNAME, SP.P#
      HAVING SP.P# = 'P2';
    
      SELECT DISTINCT S.SNAME FROM S
      WHERE  S.S# = ANY (SELECT SP.S# FROM SP WHERE SP.P# = 'P2' );
    
      SELECT DISTINCT S.SNAME FROM S
      WHERE  (SELECT COUNT(*) FROM SP WHERE SP.S# = S.S# AND SP.P# = 'P2') > 0;
    
      SELECT DISTINCT S.SNAME FROM S, SP
      WHERE  SP.P# = 'P2'
      GROUP BY S.S#, S.SNAME, SP.S#
      HAVING SP.S# = S.S#;
      ```
* 최근의 비용기반 옵티마이저는 사용자 SQL을 최적화에 유리한 형태로 재작성하는 작업을 먼저 한다
  * Optimier의 서브 엔진으로서 존재하는 Query Transformer, Estimator, Plan Generator 중 Query Transformer가 쿼리 변환 역할을 수행한다
 
  <div align="center">
    <img width="80%" src="https://github.com/PoSungKim/development_study/assets/37537227/b0eb6d84-1e03-4879-9e8b-870dd920412a">
  </div>
  
  * ex) 처음에는 하단의 두 쿼리는 수행 속도가 다를 수 있지만, 쿼리 변환이 작동하면 동일한 수행 속도로 맞춰질 수 있다
      ```sql
      select *
      from   dept d
      where  not exists (select 'x'
                         from   emp
                         where  deptno = d.deptno);
    
      select d.*
      from   dept d, emp e
      where  e.deptno(+) = d.deptno
      and    e.rowid is null;
      ```
* 즉, 쿼리 변환 (Query Transformation)은, 쿼리 옵티마이저가 SQL을 분석해 의미적으로 동일하면서도 더 나은 성능이 기대되는 형태로 재작성하는 것을 말한다
* 쿼리 변환 종류
  * 서브쿼리 Unnesting
  * 뷰 Merging
  * 조건절 Pushing
  * 조건절 이행
  * 공통 표현식 제거
  * Outer 조인을 Inner 조인으로 변환
  * 실체화 뷰 쿼리로 재작성
  * Star 변환
  * Outer 조인 뷰에 대한 조인 조건 Pushdown
  * OR-expansion
* 쿼리 변환 방식
  * 휴리스틱 (Heuristic) 쿼리 변환
    * 규칙 기반 (Rule-based)으로 결과만 보장된다면 무조건 쿼리 변환 수행
    * 최소 동일한 성능이 보일 것으로 판단이 반영된 규칙이기 때문
  * 비용기반 (Cost-based) 쿼리 변환
    * 변환된 쿼리의 비용이 더 낮을 때만 쿼리 변환 수행; 아니면, 원본 쿼리 그대로 사용

<br>
<hr>
<br>

## 서브쿼리 Unnesting
#### 옵티마이저가 숲을 바라보는 시각으로 쿼리를 이해하려면 먼저 서브쿼리를 풀어내야만 한다

<br>

### 서브쿼리의 분류
* 분류
  * 인라인 뷰 (Inline View) : from 절에 나타나는 서브쿼리
  * 중첩된 서브쿼리 (Nested Subquery) : 결과집합을 한정하기 위해 where 절에 사용된 서브쿼리
  * 스칼라 서브쿼리 (Scalar Subquery) : 한 레코드당 정확히 하나의 칼럼 값만을 리턴하는 특징이 있는 보통 select-list에 위치한 서브쿼리
* 옵티마이저는 블록 단위로 액세스 경로 (Access Path), 조인 순서 (Join Order), 조인 방식 (Join Method)을 최적화하는 것을 목표로 한다

<br>

### 서브쿼리 Unnesting의 의미
* 중첩된 서브쿼리 (Nested Subquery)를 풀어내는 것을 의미한다
* 메인쿼리와 서브쿼리 간에 종속적이고 계층적인 관계가 존재한다
  * IN, EXISTS 불문하고 필터 방식의 중첩된 서브쿼리 형태이어야 함
    ```sql
    select * from emp a
    where  exists (
        select 'x' from dept
        where  deptno = a.deptno
    )
    and sal > (
        select avg(sal) from emp b
        where  exists (
            select 'x' from salgrade
            where  b.sal between losal and hisal
            and    grade = 4
        )
    );
    ```
* 서브쿼리를 처리함에 있어서 필터 방식이 항상 최적의 수행속도를 보장하지 못하므로 옵티마이저는 하단 둘 중 하나를 선택한다
  * 서브쿼리 Unnesting
    * 동일한 결과를 보장하는 조인문으로 변환하고 나서 최적화 (서브쿼리 Flattening)
    * 쿼리 변환이 이루어지고 나면 일반 조인문처럼 다양한 최적화 기법이 사용가능해진다
  * 서브쿼리 No-Unnesting
    * 원본 쿼리로 메인쿼리와 서브쿼리를 별도의 서브플랜 (Subplan)으로 구분해 각각 최적화를 수행하며, 이때 서브쿼리에 필터 (Filter) 오퍼레이션이 나타난다
    * 쿼리 블록별로 최적화하면 각각의 최적이 쿼리문 전체의 최적을 달성하지 못할 때가 많다
    * Plan Generator가 고려대상으로 삼을만한 다양한 실행계획을 생성해 내는 작업이 매우 제한적인 범위 내에서만 이루어진다
* 서브쿼리의 또 다른 최적화 기법
  * 조건
    * (1) 메인쿼리와 상관관계에 있지 않으면서 (Non-Correlated, 서브쿼리에서 메인 쿼리를 참조하지 않음)
    * (2) 단일 로우를 리턴 (single-row subquery)하는 아래와 같은 형태의 서브쿼리를 처리할 때
  * 최적화 기법
    * 변환 전의 서브쿼리는 Fetch가 아닌 Execute 시점에 먼저 수행하여, 그 결과 값을 메인 쿼리에 상수로 제공하는 방식으로 최적화를 진행한다
  * 예시
    * 변환 전) select * from tab1 where key1 = `(select avg(col1) from tab2)`;
      * 변환 후) select * from tab1 where key1 = `:value1`;
    * 변환 전) select * from tab1 where (key1, key2) = `(select col1, col2 from tab2 where col3 >= 5000 and rownum = 1)`;
      * 변환 후) select * from tab1 where (key1, key2) = `(:value1, :value2)`;

<br>

### 서브쿼리 Unnesting의 이점
* 서브쿼리를 메인쿼리와 같은 레벨로 풀어낸다면 다양한 액세스 경로와 조인 메소드를 평가할 수 있다.
  * 특히 옵티마이저는많은 조인테크닉을 가지기 때문에 조인 형태로 변환했을 때 더 나은 실행계획을 찾을 가능성이 높아진다
* unnest : 서브쿼리를 Unnesting 함으로써 조인방식으로 최적화하도록 유도한다
* no_unnest : 서브쿼리를 그대로 둔 상태에서 필터 방식으로 최적화하도록 유도한다

<br>

### 서브쿼리 Unnesting 기본 예시

<br>

### Unnesting된 쿼리의 조인 순서 조정

<br>

### 서브쿼리가 M쪽 집합이거나 Nonunique 인덱스일 때
* Sort Unique 오퍼레이션 수행
* 세미 조인 방식으로 수행

<br>

### 필터 오퍼레이션과 세미조인의 캐싱 효과

<br>

### Anti 조인
* exists 필터
* not exists 필터

<br>

### 집계 서브쿼리 제거

<br>

### Pushing 서브쿼리

<br>
<hr>
<br>

## 뷰 Merging
#### 

<br>

### 뷰 Merging이란?

<br>

### 단순 뷰(Simple View) Merging

<br>
<hr>
<br>
