# 파티셔닝
> 파티셔닝 (Partitioning)은 테이블과 인덱스 데이터를 파티션 (Partition) 단위로 나누어 저장하는 것
* 관리적 측면 : 파티션 단위 백업, 추가, 삭제, 변경
* 성능적 측면 : 파티션 단위 조회 및 DML 수행

<hr>
<br>

## 테이블 파티셔닝
#### 테이블과 인덱스에서 파티션 키에 따라 물리적으로 별도의 세그먼트에 데이터가 저장된다

<br>

### (1) 파티션 기본 구조
* 수동 파티셔닝
  * p1, p2, p3 테이블을 union-all로 묶어서 파티션 뷰를 생성하는 패턴
    ```sql
    -- 파티션 뷰를 정의할 때 사용할 Base 테이블을 만든다
    create table p1 as select * from scott.emp where deptno = 10;
    create table p2 as select * from scott.emp where deptno = 20;
    create table p3 as select * from scott.emp where deptno = 30;
  
    -- 체크 제약을 반드시 설정해야 함
    alter table p1 add constraint c_deptno_10 check(deptno < 20);
    alter table p2 add constraint c_deptno_20 check(deptno >= 20 and deptno < 30);
    alter table p3 add constraint c_deptno_30 check(deptno >= 30 and deptno < 40);
  
    create index p1_empno_idx on p1(empno);
    create index p2_empno_idx on p2(empno);
    create index p3_empno_idx on p3(empno);
  
    analyze table p1 compute statistics;
    analyze table p2 compute statistics;
    analyze table p3 compute statistics;
  
    -- 파티션 뷰를 정의한다
    create or replace view partition_view
    as
    select * from p1
    union all
    select * from p2
    union all
    select * from p3
    ```
  * 파티션 뷰의 핵심 기능은 뷰 쿼리에 사용된 조건절에 부합하는 테이블만 읽는다는 점이다 (파티션 Pruning)
    ```sql
    select * from partition_view
    where  deptno = :deptno;
    ```
    ```
    Execution Plan
    -----------------------------------------------------------
    SELECT STATEMENT Optimizer=CHOOSE
      VIEW OF 'PARTITION_VIEW'
        UNION-ALL (PARTITION)
          FILTER -- :deptno < 20
            TABLE ACCESS (FULL) OF 'P1'
          FILTER -- 20 <= :deptno < 30
            TABLE ACCESS (FULL) OF 'P2'
          FILTER -- 30 <= :deptno < 40
            TABLE ACCESS (FULL) OF 'P3'
    ```
  * 체크 제약 (check constraint)을 통해 파티션 Pruning을 하여, 3개의 인덱스 중 하나만을 해당 인덱스와 연결된 테이블을 액세스한다 (p1_empno_idx > p1)
    ```sql
    select * from partition_view
    where  deptno = :deptno
    and    empno = :empno;
    ```
    ```
    Execution Plan
    -----------------------------------------------------------
    SELECT STATEMENT Optimizer=CHOOSE
      VIEW OF 'PARTITION_VIEW'
        UNION-ALL (PARTITION)
          FILTER -- :deptno < 20
            TABLE ACCESS (FULL) OF 'P1'
              INDEX (RANGE SCAN) OF 'P1_EMPNO_IDX'
          FILTER -- 20 <= :deptno < 30
            TABLE ACCESS (FULL) OF 'P2'
              INDEX (RANGE SCAN) OF 'P2_EMPNO_IDX'
          FILTER -- 30 <= :deptno < 40
            TABLE ACCESS (FULL) OF 'P3'
              INDEX (RANGE SCAN) OF 'P3_EMPNO_IDX'
    ```
* 파티션 테이블
  ```sql
  -- sql 2개로 
  
  create table partition_table
  -- 파티션 뷰의 Base 테이블에 체크 제약을 설정하는 것과 같은 역할을 수행한다
  partition by range(deptno) ( 
    partition p1 values less than(20)
  , partition p2 values less than(30)
  , partition p3 values less than(40)
  )
  as
  select * from emp;

  -- 인덱스를 만들 때도 local 옵션을 지정했으므로 각 파티션별로 개별적인 인덱스가 만들어져, 파티션 뷰 Base 테이블에 각각 인덱스를 만든 것과 같다
  create index ptable_empno_idx on partition_table(empno) LOCAL;
  ```
  * 테이블 파티션 유형 
    * Range 파티셔닝
    * 해시 파티셔닝
    * 리스트 파티셔닝
    * Range-해시 파티셔닝
    * Range-리스트 파티셔닝
    * Range-Range 파티셔닝
    * 리스트-해시 파티셔닝
    * 리스트-리스트 파티셔닝
    * 리스트-Range 파티셔닝

<br>

### (2) Range 파티셔닝

<div align="center">
 <img width="50%" src="https://github.com/PoSungKim/development_study/assets/37537227/56058f79-c027-46e0-8ea2-520eb06b267f">
</div>

```sql
create table 주문 ( 주문번호 number, 주문일자 varchar2(8), 고객id varchar2(5), ...)
partition by range(주문일자) (
  partition p2009_q1 values less than ('20090401')
, partition p2009_q2 values less than ('20090701')
, partition p2009_q3 values less than ('20091001')
, partition p2009_q4 values less than ('20100101')
, partition p2010_q1 values less than ('20100401')
, partition p9999_mx values less than ( MAXVALUE )
```

<br>

### (3) 해시 파티셔닝
  * 병렬 쿼리 성능 향상
  * DML 경합 분산

<br>

### (4) 리스트 파티셔닝

<br>

### (5) 결합 파티셔닝
* (Range + 해시) 결합 파티셔닝
* (Range + 리스트) 결합 파티셔닝
* 기타 결합 파티셔닝

<br>

### (6) 11g에 추가된 파티션 유형
* Reference 파티셔닝
* Interval 파티셔닝

<br>
<hr>
<br>

## 파티션 Pruning
#### 

<br>

### (1) 기본 파티션 Pruning
* 파티션 Pruning 기능에 따른 실행계획 비교
* 파티션 Pruning 기능에 따른 I/O 수행량 비교
* 동적 파티션 Pruning 시 테이블 레벨 통계 사용

<br>

### (2) 서브쿼리 Pruning

<br>
<hr>
<br>

## 인덱스 파티셔닝
#### 

<br>
<hr>
<br>
