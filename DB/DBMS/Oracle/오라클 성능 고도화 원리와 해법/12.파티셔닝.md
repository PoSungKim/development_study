# 파티셔닝
> 파티셔닝 (Partitioning)은 테이블과 인덱스 데이터를 파티션 (Partition) 단위로 나누어 저장하는 것
* 관리적 측면 : 파티션 단위 백업, 추가, 삭제, 변경
* 성능적 측면 : 파티션 단위 조회 및 DML 수행

<hr>
<br>

## 테이블 파티셔닝
#### 테이블과 인덱스에서 파티션 키에 따라 물리적으로 별도의 세그먼트에 데이터가 저장된다

<br>

### (1) 파티션 기본 구조
* 수동 파티셔닝
  * p1, p2, p3 테이블을 union-all로 묶어서 파티션 뷰를 생성하는 패턴
    ```sql
    -- 파티션 뷰를 정의할 때 사용할 Base 테이블을 만든다
    create table p1 as select * from scott.emp where deptno = 10;
    create table p2 as select * from scott.emp where deptno = 20;
    create table p3 as select * from scott.emp where deptno = 30;
  
    -- 체크 제약을 반드시 설정해야 함
    alter table p1 add constraint c_deptno_10 check(deptno < 20);
    alter table p2 add constraint c_deptno_20 check(deptno >= 20 and deptno < 30);
    alter table p3 add constraint c_deptno_30 check(deptno >= 30 and deptno < 40);
  
    create index p1_empno_idx on p1(empno);
    create index p2_empno_idx on p2(empno);
    create index p3_empno_idx on p3(empno);
  
    analyze table p1 compute statistics;
    analyze table p2 compute statistics;
    analyze table p3 compute statistics;
  
    -- 파티션 뷰를 정의한다
    create or replace view partition_view
    as
    select * from p1
    union all
    select * from p2
    union all
    select * from p3
    ```
  * 파티션 뷰의 핵심 기능은 뷰 쿼리에 사용된 조건절에 부합하는 테이블만 읽는다는 점이다 (파티션 Pruning)
    ```sql
    select * from partition_view
    where  deptno = :deptno;
    ```
    ```
    Execution Plan
    -----------------------------------------------------------
    SELECT STATEMENT Optimizer=CHOOSE
      VIEW OF 'PARTITION_VIEW'
        UNION-ALL (PARTITION)
          FILTER -- :deptno < 20
            TABLE ACCESS (FULL) OF 'P1'
          FILTER -- 20 <= :deptno < 30
            TABLE ACCESS (FULL) OF 'P2'
          FILTER -- 30 <= :deptno < 40
            TABLE ACCESS (FULL) OF 'P3'
    ```
  * 체크 제약 (check constraint)을 통해 파티션 Pruning을 하여, 3개의 인덱스 중 하나만을 해당 인덱스와 연결된 테이블을 액세스한다 (p1_empno_idx > p1)
    ```sql
    select * from partition_view
    where  deptno = :deptno
    and    empno = :empno;
    ```
    ```
    Execution Plan
    -----------------------------------------------------------
    SELECT STATEMENT Optimizer=CHOOSE
      VIEW OF 'PARTITION_VIEW'
        UNION-ALL (PARTITION)
          FILTER -- :deptno < 20
            TABLE ACCESS (FULL) OF 'P1'
              INDEX (RANGE SCAN) OF 'P1_EMPNO_IDX'
          FILTER -- 20 <= :deptno < 30
            TABLE ACCESS (FULL) OF 'P2'
              INDEX (RANGE SCAN) OF 'P2_EMPNO_IDX'
          FILTER -- 30 <= :deptno < 40
            TABLE ACCESS (FULL) OF 'P3'
              INDEX (RANGE SCAN) OF 'P3_EMPNO_IDX'
    ```
* 파티션 테이블
  ```sql
  -- sql 2개로 
  
  create table partition_table
  -- 파티션 뷰의 Base 테이블에 체크 제약을 설정하는 것과 같은 역할을 수행한다
  partition by range(deptno) ( 
    partition p1 values less than(20)
  , partition p2 values less than(30)
  , partition p3 values less than(40)
  )
  as
  select * from emp;

  -- 인덱스를 만들 때도 local 옵션을 지정했으므로 각 파티션별로 개별적인 인덱스가 만들어져, 파티션 뷰 Base 테이블에 각각 인덱스를 만든 것과 같다
  create index ptable_empno_idx on partition_table(empno) LOCAL;
  ```
  * 테이블 파티션 유형 
    * Range 파티셔닝
    * 해시 파티셔닝
    * 리스트 파티셔닝
    * Range-해시 파티셔닝
    * Range-리스트 파티셔닝
    * Range-Range 파티셔닝
    * 리스트-해시 파티셔닝
    * 리스트-리스트 파티셔닝
    * 리스트-Range 파티셔닝

<br>

### (2) Range 파티셔닝
* 각 레코드를 파티션 키 칼럼 값에 따라 분할 저장하고 및 읽는다
* 파티션 키로는 최대 16개까지 가능하다
* 11g부터는 interval 기준을 정의함으로써 정해진 간격으로 파티션이 자동 추가된다
* 자동 추가 기능을 사용하지 않으면, MAXVALUE 파티션을 반드시 생성하는 것이 좋다
* Range 파티션에선 값의 순서에 따라 저장할 파티션이 결정된다

<div align="center">
 <img width="50%" src="https://github.com/PoSungKim/development_study/assets/37537227/56058f79-c027-46e0-8ea2-520eb06b267f">
</div>

```sql
create table 주문 ( 주문번호 number, 주문일자 varchar2(8), 고객id varchar2(5), ...)
partition by range(주문일자) (
  partition p2009_q1 values less than ('20090401')
, partition p2009_q2 values less than ('20090701')
, partition p2009_q3 values less than ('20091001')
, partition p2009_q4 values less than ('20100101')
, partition p2010_q1 values less than ('20100401')
, partition p9999_mx values less than ( MAXVALUE )
```

<br>

### (3) 해시 파티셔닝
* 파티션 키에 해시 함수를 적용한 결과 값이 같은 레코드를 같은 파티션 세그먼트에 저장해 두는 방식이다
* 데이터 분포가 고르고 distinct value 개수가 많은 칼럼을 해시 파티션 기준 칼럼을 선정하는 것이 좋다
  * Range 및 리스트 파티셔닝과 다르게 해시 파티셔닝은 파티션 개수만 사용자가 결정하고 데이터를 분산시키는 해싱 알고리즘은 오라클이 결정하기 때문
* 등치(=) 조건 또는 IN-LIST 조건으로 검색할 때만 파티션 Pruning이 작동한다

<div align="center">
 <img width="50%" src="https://github.com/PoSungKim/development_study/assets/37537227/cec014c7-53a7-4526-9d73-87f71ff96248">
</div>

```sql
create table 고객 ( 고객id varchar2(5), 고객명 varchar2(10), ...)
partition by hash( 고객id ) partitions 4;
```

* 병렬 쿼리 성능 향상
* DML 경합 분산
  * 데이터 입력되는 테이블 블록에도 경합이 발생한다
  * 입력할 블록을 할당받기 위한 Freelist 조회 때문에 세그먼트 헤더 블록에 대한 경합이 더 자주 발생한다
  * Right Growing 인덱스도 해시 파티셔닝한 인덱스로 경합 발생 가능성을 낮출 수 있다
* 모두 트랜잭션이 많이 발생하는 대용량 거래 테이블일 때 효과가 극대화된다
  * 보통, Range와 해시 파티셔닝을 조합한 결합 인덱스를 주로 사용한다

<br>

### (4) 리스트 파티셔닝
* 사용자에 의해 미리 정해진 그룹핑 기준에 따라 데이터를 분할 저장하는 방식

<div align="center">
 <img width="50%" src="https://github.com/PoSungKim/development_study/assets/37537227/ab98d055-d0c2-4790-9042-b07d7d68647d">
</div>

```sql
create table 인터넷매물 ( 물건코드 varchar2(5), 지역분류 varchar2(4), ...)
partition by list( 지역분류 ) (
  partition p_지역1 values ('서울')
, partition p_지역2 values ('경기', '인천')
, partition p_지역3 values ('부산', '대구', '대전', '광주')
, partition p_기타 values (DEFAULT) -- 기타 지역
);
```

* 리스트 파티션에서는 순서와 상관없이 불연속적인 값의 목록으로써 결정된다
* 리스트 파티션에서는 사용자가 정의한 논리적인 그룹에 따라 분할한다
* default 파티션을 생성해 두어야 안전하다

<br>

### (5) 결합 파티셔닝
* 결합 파티셔닝 (Composite Partitioning)
  * 서브 파티션마다 세그먼트를 하나씩 할당하고, 서브 파티션 단위로 데이터를 저장한다
* (Range + 해시) 결합 파티셔닝
  * 주문 테이블 > 주문일자 > 고객ID
  ```sql
  create table 주문 ( 주분번호 number, 주문일자 varchar2(8), 고객id varchar2(5), ...)
  partition by range(주문일자)
  subpartition by hash(고객id) subpartitions 8
  ( partition p2009_q1 values less than ('20090401')
  , partition p2009_q2 values less than ('20090701')
  , partition p2009_q3 values less than ('20091001')
  , partition p2009_q4 values less than ('20100101')
  , partition p2010_q1 values less than ('20100401')
  , partition p9999_mx values less than ( MAXVALUE )
  );
  ```
  * p2009_q3 파티션에 속한 8개의 서브 파티션을 탐색하는 쿼리
  ```sql
  select * from 주문 where 주문일자 between '20090701' and '20090930';
  ```
  * 주문일자 없이 고객id로만 조회해서 각 Range별로 하나씩, 총 6개의 서브 파티션을 탐색하는 쿼리
  ```sql
  select * from 주문 where 고객id = :custid;
  ```
* (Range + 리스트) 결합 파티셔닝
  * 판매 테이블 > 판매일자 > 판매점
  * 초대형 이력성 테이블을 Range 파티셔닝하고, 각 파티션을 업무적으로 다시 분할하고자 할 때 주로 사용된다
  ```sql
  create table 판매 ( 판매점 varchar2(10), 판매일자 varchar2(8), ... )
  partition by range( 판매일자 )
  subpartition by list( 판매점 )
  subpartition template
  ( subpartition lst_01 values ('강남지점', '강북지점', '강서지점', '강동지점')
  , subpartition lst_02 values ('부산지점', '대전지점')
  , subpartition lst_03 values ('인천지점', '제주지점', '의정부지점')
  , subpartition lst_99 values ( DEFAULT ))
  ( partition p2009_q1 values less than('20090401')
  , partition p2009_q2 values less than('20090701')
  , partition p2009_q3 values less than('20091001')
  , partition 20009_q4 values less than('20100101') );
  ```
* 기타 결합 파티셔닝
  * Range-Range
  * 리시트-해시
  * 리스트-리스트
  * 리스트-Range

<br>

### (6) 11g에 추가된 파티션 유형
* Reference 파티셔닝

  <div align="center">
   <img width="50%" src="https://github.com/PoSungKim/development_study/assets/37537227/213b1eff-9f9c-4af2-acd2-0e39061585fd">
  </div>

  * 부모 테이블 파티션 키를 이용해 자식 테이블을 파티셔닝하는 기능
    * Reference 파티셔닝 기능이 없을 때는, 상품 테이블의 상품대분류 칼럼을 일별상품거래 테이블에 반정규화해야만 했다
      * 상품번호에 졷속적인 칼럼이므로 2차 정규형을 위배하게 된다

    ```sql
    create table 상품 (
      상품번호   number NOT NULL PRIMARY KEY
    , 상품명    varchar2(50)  not null
    , 현재가격   number  not null
    , 상품대분류  varchar2(4)  not null
    , 등록일시   date  not null
    )
    partition by list (상품대분류) (
      partition p1 values ('의류')
    , partition p2 values ('식품')
    , partition p2 values ('가전')
    , partition p2 values ('컴퓨터')
    );
  
    create table 일별상품거래 (
      상품번호 number NOT NULL
    , 거래일자 varchar2(8)
    , 판매가격 number
    , 판매수량 number
    , 판매금액 number
    , constraint 일별상품거래_fk foreign key (상품번호) references 상품
    )
    partition by reference (일별상품거래_fk); -- Refernce 파티셔닝
    ```

* Interval 파티셔닝
  * Range 파티션을 생성할 때 interval 기준을 정의함으로써 정해진 가격으로 파티션이 자동 추가되는 기능
  * 1 Month Interval
    ```sql
    create table 주문일자 (주문번호 number, 주문일시 date, ...)
    partition by range(주문일시) INTERVAL(NUMTOYMINTERVAL(1, 'MONTH'))
    (
    , ...
    , partition p200908 values less than(to_date('2009/09/01', 'yyyy/mm/dd'))
    , partition p200909 values less than(to_date('2009/10/01', 'yyyy/mm/dd'))
    , partition p200910 values less than(to_date('2009/11/01', 'yyyy/mm/dd'))
    );
    ```
  * 100000 Interval
    ```sql
    create table 고객 (고객번호 number, 고객명 varchar2(20), ...)
    partition by range(고객번호) INTERVAL(100000)
    (
    , partition p_cust1 values less than(100001)
    , partition p_cust1 values less than(200001)
    , partition p_cust1 values less than(300001)
    );
    ```
  
<br>
<hr>
<br>

## 파티션 Pruning
#### 하드파싱이나 실행 시점에 SQL 조건절을 분석하여 읽지 않아도 되는 파티션 세그먼트를 액세스 대상에서 제외시키는 기능

<br>

### (1) 기본 파티션 Pruning
* 기본 파티션 Pruning 유형
  * 정적 (Static) 파티션 Pruning
    * 파티션 키 칼럼을 상수 조건으로 조회하는 경우에 작동
    * 쿼리 최적화 시점에 미리 결정된다
    * Pstart(partition start), Pstop(partition stop) 칼럼에는 파티션 번호가 출력
  * 동적 (Dynamic) 파티션 Pruning
    * 파티션 키 칼럼을 바인드 변수로 조회하는 경우에 작동
    * 실행 시점에 입력값에 따라 결정된다
    * Pstart(partition start), Pstop(partition stop) 칼럼에는 KEY가 출력
    * NL 조인에서 Inner 테이블이 조인 칼럼 기준으로 파티셔닝 되어 있다면 동적 Pruning 작동된다
* 파티션 Pruning 기능에 따른 실행계획 비교
  * 파티션 Pruning 테스트 환경 세팅
    ```sql
    create table t ( key, no, data )
    partition by range(no) (
      partition p01 values less than(11)
    , partition p02 values less than(21)
    , partition p03 values less than(31)
    , partition p04 values less than(41)
    , partition p05 values less than(51)
    , partition p06 values less than(61)
    , partition p07 values less than(71)
    , partition p08 values less than(81)
    , partition p09 values less than(91)
    , partition p10 values less than(maxvalue)
    )
    as
    select lpad(rownum, 6, '0'), mod(rownum, 100) + 1, lpad(rownum, 10, '0')
    from   dual
    connect by level <= 999999
    ```
  * 상수 조건을 통한 정적 파티션 Prunning
    ```sql
    -- 파티션 10개 중 (3~5), 즉 3,4,5 번째 파티션만 사용하는 케이스
    select count(*) from t where no between 30 and 50;
    ```
    ```
    Id     Operation                             Name             Pstart           Pstop
    ----   -----------------------------------   --------------   --------------   --------------
    0      SELECT STATEMENT
    1        SORT AGGREGATE
    2          PARTITION RANGE ITERATOR                           3                5
    3            TABLE ACCESS FULL               T                3                5
    ```
  * 바인딩 변수를 통한 동적 파티션 Pruning
    ```sql
    -- 하드파싱 시점에서 액세스할 파티션을 결정할 수 없기 때문에 KEY 값으로 세팅되어 있다
    select count(*) from t where no between :a and :b;
    ```
    ```
    Id     Operation                             Name             Pstart           Pstop
    ----   -----------------------------------   --------------   --------------   --------------
    0      SELECT STATEMENT
    1        SORT AGGREGATE
    2          FILTER
    3            PARTITION RANGE ITERATOR        T                KEY              KEY
    4              TABLE ACCESS FULL             T                KEY              KEY
    ```
  * 상수 및 IN-List 조건을 통한 파티션 Pruning
    ```sql
    select count(*) from t where no in (30, 50);
    ```
    ```
    Id     Operation                             Name             Pstart           Pstop
    ----   -----------------------------------   --------------   --------------   --------------
    0      SELECT STATEMENT
    1        SORT AGGREGATE
    2          PARTITION RANGE INLIST                             KEY(I)           KEY(I)
    3            TABLE ACCESS FULL               T                KEY(I)           KEY(I)
    ```
  * NL 조인 테스트 환경 세팅
    ```sql
    create table n
    as
    select level no from dual connect by level <= 100;
    ```
  * NL조인에서 inner table을 통한 동적 파티션 Pruning
    ```sql
    select /*+ leading(n) use_nl(t) */ *
    from   n, t
    where  t.no = n.no;
    ```
    ```
    Id     Operation                             Name             Pstart           Pstop
    ----   -----------------------------------   --------------   --------------   --------------
    0      SELECT STATEMENT
    1        NESTED LOOPS
    2          TABLE ACCESS FULL                 N                
    3          PARTITION RANGE ITERATOR                           KEY              KEY
    4            TABLE ACCESS FULL               T                KEY              KEY
    ```
  * 결합 파티션 테스트 환경 세팅
    ```sql
    create table t ( key, no, data )
    partition by range(no) subpartition by hash(key) subpartitions 16 (
      partition p01 values less than(11)
    , partition p02 values less than(21)
    , partition p03 values less than(31)
    , partition p04 values less than(41)
    , partition p05 values less than(51)
    , partition p06 values less than(61)
    , partition p07 values less than(71)
    , partition p08 values less than(81)
    , partition p09 values less than(91)
    , partition p10 values less than(maxvalue)
    )
    as
    select lpad(rownum, 6, '0'), mod(rownum, 100) + 1, lpad(rownum, 10, '0')
    from   dual
    connect by level <= 999999
    ```
  * 상수 조건을 통한 정적 파티션 Prunning
    ```sql
    -- 파티션 10개 중 (3~5), 즉 3,4,5 번째 파티션을 읽었고, 각 파티션에서 (1~16) 서브파티션을 읽어서, 총 48(16*3) 파티션을 읽은 케이스
    select count(*) from t where no between 30 and 50;
    ```
    ```
    Id     Operation                             Name             Pstart           Pstop
    ----   -----------------------------------   --------------   --------------   --------------
    0      SELECT STATEMENT
    1        SORT AGGREGATE
    2          PARTITION RANGE ITERATOR                           3                5
    3            PARTITION HASH ALL                               1                16
    4              TABLE ACCESS FULL             T                33               80
    ```
  * 바인딩 변수를 통한 동적 파티션 Pruning
    ```sql
    -- 하드파싱 시점에서 액세스할 파티션을 결정할 수 없기 때문
    select count(*) from t where no between :a and :b;
    ```
    ```
    Id     Operation                             Name             Pstart           Pstop
    ----   -----------------------------------   --------------   --------------   --------------
    0      SELECT STATEMENT
    1        SORT AGGREGATE
    2          FILTER
    3            PARTITION RANGE ITERATOR                         KEY              KEY
    4              PARTITION HASH ALL                             1                16
    5                TABLE ACCESS FULL           T                KEY              KEY
    ```
* 파티션 Pruning 기능에 따른 I/O 수행량 비교
  * 주 파티션과 서브 파티션에 대한 칼럼 가공 혹은 묵시적 형변환 없이 정상적으로 파티션 Pruning이 작동한 예시)
    ```sql
    select * from t where no = 1 and key = '000100';
    ```
    ```
    call       count  cpu    elapsed  disk   query  current  rows
    --------   -----  -----  -------  -----  -----  -------  -----
    Parse          1  0.000    0.000      0      0        0      0
    Execute        1  0.000    0.000      0      0        0      0
    Fetch          2  0.016    0.007      0     49        0      1
    --------   -----  -----  -------  -----  -----  -------  -----
    total          4  0.016    0.007      0     49        0      1
  
    Rows     Row Source Operation                  
    ------   ----------------------------------------------------------------------------
         1   PARTITION RANGE SINGLE PARTITION: 1 1 (cr=49 pr=0 pw=0 time=5915 us)
         1     PARTITION HASH SINGLE PARTITION: 6 6 (cr=49 pr=0 pw=0 time=5859 us)
         1       TABLE ACCESS FULL T PARTITION: 6 6 (cr=49 pr=0 pw=0 time=5724 us)
    ```
  * 서브 파티션 키 칼럼을 가공했을 때의 예시)
    * 즉, 파티션 키 칼럼도 함부로 가공하면 안 된다
    ```sql
    select * from t where no = 1 and to_number(key) = 100;
    ```
    ```
    call       count  cpu    elapsed  disk   query  current  rows
    --------   -----  -----  -------  -----  -----  -------  -----
    Parse          1  0.000    0.000      0      0        0      0
    Execute        1  0.000    0.000      0      0        0      0
    Fetch          2  0.063    1.056    528    776        0      1
    --------   -----  -----  -------  -----  -----  -------  -----
    total          4  0.063    1.056    528    776        0      1
  
    Rows     Row Source Operation                  
    ------   ----------------------------------------------------------------------------
         1   PARTITION RANGE SINGLE PARTITION: 1 1 (cr=776 pr=528 pw=0 time=1056056 us)
         1     PARTITION HASH ALL PARTITION: 1 16 (cr=776 pr=528 pw=0 time=1056027 us)
         1       TABLE ACCESS FULL T PARTITION: 1 16 (cr=776 pr=528 pw=0 time=1055868 us)
    ```
  * 서브 파티션 키 칼럼에 묵시적 형변환이 발생했을 때의 예시)
    ```sql
    select * from t where no = 1 and key = 100;
    ```
    ```
    call       count  cpu    elapsed  disk   query  current  rows
    --------   -----  -----  -------  -----  -----  -------  -----
    Parse          1  0.000    0.000      0      0        0      0
    Execute        1  0.000    0.000      0      0        0      0
    Fetch          2  0.078    0.955    528    776        0      1
    --------   -----  -----  -------  -----  -----  -------  -----
    total          4  0.078    0.955    528    776        0      1
  
    Rows     Row Source Operation                  
    ------   ------------------------------------------------------------------------------
         1   PARTITION RANGE SINGLE PARTITION: 1 1 (cr=776 pr=528 pw=0 time=954975 us)
         1     PARTITION HASH ALL PARTITION: 1 16 (cr=776 pr=528 pw=0 time=954945 us)
         1       TABLE ACCESS FULL T PARTITION: 1 16 (cr=776 pr=528 pw=0 time=954780 us)
    ```
    ```
    Predicate Information (identified by operation id) :
    ------------------------------------------------------
    3 - filter("NO"=1 AND TO_NUMBER("KEY")=100)
    ```
  * 주 파티션 키 칼럼은 가공하고, 서브 파티션 키 칼럼에는 묵시적 형변환이 발생했을 때의 예시)
    ```sql
    select * from t where to_char(no) = '1' and key = 100;
    ```
    ```
    call       count  cpu    elapsed  disk   query  current  rows
    --------   -----  -----  -------  -----  -----  -------  -----
    Parse          1  0.000    0.000      0      0        0      0
    Execute        1  0.000    0.000      0      0        0      0
    Fetch          2  1.297    7.119   3588   4114        0      1
    --------   -----  -----  -------  -----  -----  -------  -----
    total          4  1.297    7.119   3588   4114        0      1
  
    Rows     Row Source Operation                  
    ------   ----------------------------------------------------------------------------
         1   PARTITION RANGE ALL PARTITION: 1 10 (cr=4114 pr=3588 pw=0 time=7118551 us)
         1     PARTITION HASH ALL PARTITION: 1 16 (cr=4114 pr=3588 pw=0 time=7118551 us)
         1       TABLE ACCESS FULL T PARTITION: 1 160 (cr=4114 pr=3588 pw=0 time=7118551 us)
    ```
* 동적 파티션 Pruning 시 테이블 레벨 통계 사용
  * 통계 레벨
    * 동적 파티션 Pruning : 테이블 레벨 통계
    * 정적 파티션 Pruning : 파티션 레벨 통계
  * 테이블 레벨 통계는 파티션 레벨 통계보다 다소 부정확하다
    * 테이블 레벨 통계를 사용하는 동적 파티션 Pruning의 부작용이다

<br>

### (2) 조인에 사용되는 고급 파티션 Pruning 기법 - 서브쿼리 Pruning (8i~)
* NL 조인할 때 Inner 테이블이 조인 칼럼 기준으로 파티셔닝 되어 있다면 동적 Pruning이 작동한다
  ```sql
  select d.분기, o.주문일자, o.고객ID, o.상품ID, o.주문수량, o.주문금액
  from   일자 d, 주문 o
  where  o.주문일자 = d.일자
  and    d.분기 >= 'Q20071';
  ```
* 다만, 대용량 주문 테이블을 Random 액세스 위주의 NL 방식으로 조인한다면 결코 좋은 성능을 기대할 수 없다
  * 해시 조인 혹은 소트 머지 조인으로 처리하기 부담된다
* 문제점 (모든 파티션을 모두 읽고 조인하고나서 필터링)
  * 2007년 1분기 이후 주문 데이터만 필요한데도 주문 테이블로부터 모든 파티션을 읽어 조인하고서 나중에 분기 조건을 필터링해야 하기 때문이다
* 해결점 (정말 필요한 파티션만 읽기)
  * 바로, 이런 상황에 오라클은 Recursive 서브쿼리를 이용한 동적 파티션 Pruning을 고려한다
    * 딱 필요한 파티션만 스캔할 수 있게 액세스해야 할 파티션 번호 목록을 구하는 쿼리
      ```sql
      select distinct TBL$OR$IDX$PART$SUM(주문, 0, 1, 0, a.일자)
      from   (select 일자 from 일자 where 분기 >= 'Q20071') a
      order by 1;
      ```
  * 서브쿼리 Pruning이 작동할 때의 실행계획
    ```
    Id     Operation                             Name             Pstart           Pstop
    ----   -----------------------------------   --------------   --------------   --------------
    0      SELECT STATEMENT
    1        HASH JOIN
    2          TABLE ACCESS FULL                 일자              
    3          PARTITION RANGE SUBQUERY                           KEY(SQ)          KEY(SQ)
    4            TABLE ACCESS FULL               주문              KEY(SQ)          KEY(SQ)
    ```
    ```
    Predicate Information (identified by operation id) :
    ------------------------------------------------------
    1 - access("O"."주문일자"="D"."일자")
    2 - filter("D"."분기"='Q20074')
    ```
* 우려점
  * KEY(SQ) 방식으로 파티션을 Pruning하려면 드라이빙 테이블을 한 번 더 읽게 되므로 경우에 따라 총 비용이 증가할 수 있다
* 파라미터
  * _subquery_pruning_cost_factor (default: 20)
  * _subquery_pruning_reduction (default: 50)
  * _subquery_pruning_enabled (default: true)
* 파라미터 의미
  * where 조건절을 가진 드라이빙 테이블이 파티션 테이블에 비해 상당히 (적어도 20배 이상) 작을 때
  * 제거될 것으로 예상되는 파티션 개수가 상당히 (최대 전체의 50%) 많을 때
  * 서브쿼리 Pruning이 작동한다
 
<br>

### (3) 조인에 사용되는 고급 파티션 Pruning 기법 - 조인필터 Pruning (11g~)
* 조인필터 Pruning 도입 배경
  * 서브쿼리 Pruning은 드라이빙 테이블을 한 번 더 액세스하는 추가비용이 발생한다
  * 따라서, 블룸 필터(Bloom Filter) 알고리즘 기반 조인필터 Pruning 방식을 도입했다
* 블룸 필터 (Bloom Filter) 알고리즘
  * Hash 함수를 통해 교집합이 아닌 것이 확실한 원소를 찾는 것에 목적이 있는 알고리즘
  * 특정 Array를 만들고, Array 크기만큼의 인덱스 번호를 리턴하는 Hash 함수를 다건 만들어서 특정 집합의 각 요소별로 수행하고, 다른 집합의 각 요소별로 수행하면서 Array 인덱스 번호가 모두 겹치는 요소는 교집합에 포함될 확률이 높은 요소이니 교집합 연산에 포함시킨다
* 블룸 필터 알고리즘에서 false positive를 줄이는 방법
  * Array 사이즈를 증가시킨다
* 조인 필터(=블룸 필터) Pruning
  * 오라클은 성능 향상을 위해 여러 곳에 이 알고리즘을 사용하는데, 그 중 대표적인 예시가 파티션 Pruning이다
  * 즉, 파티션 테이블과 조인할 때, 읽지 않아도 되는 파티션을 제거해주는 알고리즘으로 사용된다
* 조인필터 Pruning이 작동할 때의 실행계획
  ```
  Rows     Row Source Operation                  
  ------   ----------------------------------------------------------------------------
  480591   HASH JOIN (cr=3827 pr=0 pw=0 time=4946 us ...)
      12     PART JOIN FILTER CREATE :BF0000 (cr=4 pr=0 pw=0 time=18 us ...)
      12       TABLE ACCESS FULL 일자 (cr=4 pr=0 pw=0 time=6 us ...)
  480591     PARTITION RANGE JOIN-FILTER PARTITION: :BF0000 :BF0000 (cr=3827 pr=0 ...)
  480591       TABLE ACCESS FULL 주문 PARTITION: :BF0000 :BF0000 (cr=4 pr=0 pw=0 time=6 us ...)
  ```
  * PART JOIN FILTER CREATE
    * 블룸 필터를 생성하는 단계
  * PARTITION RANGE JOIN-FILTER
    * 블룸 필터를 이용해 파티션 Pruning하는 단계

<br>

### (4) SQL 조건절 작성 시 주의사항
* 테스트 환경 세팅
  ```sql
  create table 고객
  partition by range(가입)
  ( partition m01 values less than ('20090201')
  , partition m02 values less than ('20090301')
  , partition m03 values less than ('20090401')
  , partition m04 values less than ('20090501')
  , partition m05 values less than ('20090601')
  , partition m06 values less than ('20090701')
  , partition m07 values less than ('20090801')
  , partition m08 values less than ('20090901')
  , partition m09 values less than ('20091001')
  , partition m10 values less than ('20091101')
  , partition m11 values less than ('20091201')
  , partition m12 values less than ('20100101'))
  as
  select rownum 고객ID
       , dbms_random.string('a', 20) 고객명
       , to_char(to_date('20090101', 'yyyymmdd') + (rownum - 1), 'yyyymmdd') 가입일
  from   dual
  connect by level <= 365;
  ```
* like절을 사용하면 의도했던 m10에 더불어 m9까지 조회한다
  * like절이면, '2009100+',2009100-','2009100%' 등 무궁무진하게 많으면서 `20091001`보다 작은 값들을 고려하기 때문
  ```sql
  select * from 고객
  where  가입일 like '200910%';
  ```
  ```
  Id     Operation                             Name             Pstart           Pstop
  ----   -----------------------------------   --------------   --------------   --------------
  0      SELECT STATEMENT
  1        PARTITION RANGE ITERATOR                              9               10
  2          TABLE ACCESS FULL                 주문               9               10
  ```
* like 보다는 between절을 사용하는 것이 좋다
  ```sql
  select * from 고객
  where  가입일 between '20091001' and '20091031';
  ```
  ```
  Id     Operation                             Name             Pstart           Pstop
  ----   -----------------------------------   --------------   --------------   --------------
  0      SELECT STATEMENT
  1        PARTITION RANGE SINGLE                               10               10
  2          TABLE ACCESS FULL                 고객              10               10
  ```
* 쿼리 수정이 어렵다면, 파티션 키를 변경해줄 수도 있다
  ```sql
  create table 고객
  partition by range(가입)
  ( partition m01 values less than ('200902')
  , partition m02 values less than ('200903')
  ...
  , partition m11 values less than ('200912')
  , partition m12 values less than ('201001'))
  as
  select rownum 고객ID
       , dbms_random.string('a', 20) 고객명
       , to_char(to_date('20090101', 'yyyymmdd') + (rownum - 1), 'yyyymmdd') 가입일
  from   dual
  connect by level <= 365;
  ```
  ```sql
  select * from 고객
  where  가입일 like '200910%';
  ```
  ```
  Id     Operation                             Name             Pstart           Pstop
  ----   -----------------------------------   --------------   --------------   --------------
  0      SELECT STATEMENT
  1        PARTITION RANGE SINGLE                               10               10
  2          TABLE ACCESS FULL                 주문              10               10
  ```

<br>
<hr>
<br>

## 인덱스 파티셔닝
#### 

<br>

### (1) 인덱스 파티션 유형
* 테이블 파티셔닝
  * 비파티션 테이블 (Non-partitioned Table)
  * 파티션 테이블 (Partitioned Table)
* 인덱스 파티셔닝
  * 비파티션 인덱스 (Non-partitioned Index)
  * 글로벌 파티션 인덱스 (Global Partitioned Index) : 로컬 파티션이 아닌 파티션 인덱스이며, 테이블 파티션과 독립적인 구성 (파티션 키, 파티션 기준 값)을 갖는 인덱스
  * 로컬 파티션 인덱스 (Local Partitioned Index) : 각 테이블 파티션과 인덱스 파티션이 서로 1:1 대응 관계가 되도록 오라클이 자동으로 관리하는 파티션 인덱스

<div align="center">
 <img width="50%" src="https://github.com/PoSungKim/development_study/assets/37537227/f8b8c424-2793-492c-85d5-1539e5333e39">
</div>

<br>

### (2) 로컬 파티션 인덱스
* 각 인덱스 파티션이 테이블 파티션과 1:1 대응 관계를 가진다
  * Index Equipartitioned with Table
* 파티션 키를 사용자가 따로 정의하지 않아도 오라클이 자동으로 관리한다는 것이 특정
  * 테이블 파티션 구성에 변경 (drop, exchange, split 등)이 생기더라도 인덱스를 재생성할 필요가 없다

<div align="center">
 <img width="50%" src="https://github.com/PoSungKim/development_study/assets/37537227/10dc35b3-e772-4991-a901-251d7d0d6d9d">
</div>

<br>

### (3) 비파티션 인덱스
* 파티셔닝하지 않은 인덱스
  * 인덱스 : 테이블 = 1 : M 관계

<div align="center">
 <img width="50%" src="https://github.com/PoSungKim/development_study/assets/37537227/a16f666e-f86b-42de-8856-ba7c4ba7ef0f">
</div>

<br>

### (4) 글로벌 파티션 인덱스
* 인덱스가 테이블 구성과 독립적인 구성을 갖는다
* 제약사항 때문에 오히려 효용성이 낮은 편
  * 기준 테이블의 파티션 구성에 변경 (drop, exchange, split 등)이 생길 때마다 인덱스가 unusable 상태로 바뀌고 그때마다 인덱스를 재생성해야 한다
  * 단, 9i부터 아래의 옵션을 주면 파티션 DDL 작업에 의해 영향받는 인덱스 레코드를 자동으로 갱신하여 인덱스가 unusable 상태로 빠지지 않는다
    ```sql
    alter table ...
    split partition ...
    update global indexes;
    ```
  * 참고로, 파티션 DDL로 인해 영향 받는 레코드 5% 미만이여야 한다; 이상이면, 인덱스 재생성보다 느릴 수 있다
  
<div align="center">
 <img width="50%" src="https://github.com/PoSungKim/development_study/assets/37537227/2c3d627f-a28e-444f-bf3f-6e84c1e02ff2">
</div>

* 테이블 파티션과의 관계
  * 기본적으로 M:M 관계
  * 1:1 관계로 수동으로 구성하더라도 기준 테이블 구성에 변경사항 발생하면 인덱스 재생성 필요
* 글로벌 해시 파티션 인덱스
  * Range 파티션 및 해시 파티션 가능
  * 글로벌 결합 (Composite) 인덱스 파티셔닝은 불가능

<br>

### (5) Prefixed vs. Nonprefixed
* 인덱스 파티션 키 칼럼이 인덱스 구성상 왼쪽 선두 칼럼에 위치하는지에 따른 구분이다
  * Prefixed : 파티션 인덱스를 생성할 때, 파티션 키 칼럼을 인덱스 키 칼럼 왼쪽 선두에 두는 것을 말한다
  * Nonprefixed : 파티션 인덱스를 생성할 때, 파티션 키 칼럼을 인덱스 키 칼럼 왼쪽 선두에 두지 않는 것을 말한다

<div align="center">
 
  |                      | Prefixed | Nonprefixed |
  |----------------------|----------|-------------|
  | 로컬 파티션 인덱스   | 1        | 2           |
  | 글로벌 파티션 인덱스 | 3        |  4 (Not Support) |

</div>

* 총 4가지 유형으로 정리된다
  * 비파티션 인덱스
  * 글로벌 Prefixed 파티션 인덱스
  * 로컬 Prefixed 파티션 인덱스
  * 로컬 Nonprefixed 파티션 인덱스

<br>

### (6) 파티션 인덱스 구성 예시
<div align="center">
 <img width="80%" src="https://github.com/PoSungKim/development_study/assets/37537227/b8c3599f-7737-4277-b5da-2ad170f8de3a" >
</div>

<br>
<hr>
<br>
