# 파티셔닝
> 파티셔닝 (Partitioning)은 테이블과 인덱스 데이터를 파티션 (Partition) 단위로 나누어 저장하는 것
* 관리적 측면 : 파티션 단위 백업, 추가, 삭제, 변경
* 성능적 측면 : 파티션 단위 조회 및 DML 수행

<hr>
<br>

## 테이블 파티셔닝
#### 테이블과 인덱스에서 파티션 키에 따라 물리적으로 별도의 세그먼트에 데이터가 저장된다

<br>

### (1) 파티션 기본 구조
* 수동 파티셔닝
  * p1, p2, p3 테이블을 union-all로 묶어서 파티션 뷰를 생성하는 패턴
    ```sql
    -- 파티션 뷰를 정의할 때 사용할 Base 테이블을 만든다
    create table p1 as select * from scott.emp where deptno = 10;
    create table p2 as select * from scott.emp where deptno = 20;
    create table p3 as select * from scott.emp where deptno = 30;
  
    -- 체크 제약을 반드시 설정해야 함
    alter table p1 add constraint c_deptno_10 check(deptno < 20);
    alter table p2 add constraint c_deptno_20 check(deptno >= 20 and deptno < 30);
    alter table p3 add constraint c_deptno_30 check(deptno >= 30 and deptno < 40);
  
    create index p1_empno_idx on p1(empno);
    create index p2_empno_idx on p2(empno);
    create index p3_empno_idx on p3(empno);
  
    analyze table p1 compute statistics;
    analyze table p2 compute statistics;
    analyze table p3 compute statistics;
  
    -- 파티션 뷰를 정의한다
    create or replace view partition_view
    as
    select * from p1
    union all
    select * from p2
    union all
    select * from p3
    ```
  * 파티션 뷰의 핵심 기능은 뷰 쿼리에 사용된 조건절에 부합하는 테이블만 읽는다는 점이다 (파티션 Pruning)
    ```sql
    select * from partition_view
    where  deptno = :deptno;
    ```
    ```
    Execution Plan
    -----------------------------------------------------------
    SELECT STATEMENT Optimizer=CHOOSE
      VIEW OF 'PARTITION_VIEW'
        UNION-ALL (PARTITION)
          FILTER -- :deptno < 20
            TABLE ACCESS (FULL) OF 'P1'
          FILTER -- 20 <= :deptno < 30
            TABLE ACCESS (FULL) OF 'P2'
          FILTER -- 30 <= :deptno < 40
            TABLE ACCESS (FULL) OF 'P3'
    ```
  * 체크 제약 (check constraint)을 통해 파티션 Pruning을 하여, 3개의 인덱스 중 하나만을 해당 인덱스와 연결된 테이블을 액세스한다 (p1_empno_idx > p1)
    ```sql
    select * from partition_view
    where  deptno = :deptno
    and    empno = :empno;
    ```
    ```
    Execution Plan
    -----------------------------------------------------------
    SELECT STATEMENT Optimizer=CHOOSE
      VIEW OF 'PARTITION_VIEW'
        UNION-ALL (PARTITION)
          FILTER -- :deptno < 20
            TABLE ACCESS (FULL) OF 'P1'
              INDEX (RANGE SCAN) OF 'P1_EMPNO_IDX'
          FILTER -- 20 <= :deptno < 30
            TABLE ACCESS (FULL) OF 'P2'
              INDEX (RANGE SCAN) OF 'P2_EMPNO_IDX'
          FILTER -- 30 <= :deptno < 40
            TABLE ACCESS (FULL) OF 'P3'
              INDEX (RANGE SCAN) OF 'P3_EMPNO_IDX'
    ```
* 파티션 테이블
  ```sql
  -- sql 2개로 
  
  create table partition_table
  -- 파티션 뷰의 Base 테이블에 체크 제약을 설정하는 것과 같은 역할을 수행한다
  partition by range(deptno) ( 
    partition p1 values less than(20)
  , partition p2 values less than(30)
  , partition p3 values less than(40)
  )
  as
  select * from emp;

  -- 인덱스를 만들 때도 local 옵션을 지정했으므로 각 파티션별로 개별적인 인덱스가 만들어져, 파티션 뷰 Base 테이블에 각각 인덱스를 만든 것과 같다
  create index ptable_empno_idx on partition_table(empno) LOCAL;
  ```
  * 테이블 파티션 유형 
    * Range 파티셔닝
    * 해시 파티셔닝
    * 리스트 파티셔닝
    * Range-해시 파티셔닝
    * Range-리스트 파티셔닝
    * Range-Range 파티셔닝
    * 리스트-해시 파티셔닝
    * 리스트-리스트 파티셔닝
    * 리스트-Range 파티셔닝

<br>

### (2) Range 파티셔닝
* 각 레코드를 파티션 키 칼럼 값에 따라 분할 저장하고 및 읽는다
* 파티션 키로는 최대 16개까지 가능하다
* 11g부터는 interval 기준을 정의함으로써 정해진 간격으로 파티션이 자동 추가된다
* 자동 추가 기능을 사용하지 않으면, MAXVALUE 파티션을 반드시 생성하는 것이 좋다
* Range 파티션에선 값의 순서에 따라 저장할 파티션이 결정된다

<div align="center">
 <img width="50%" src="https://github.com/PoSungKim/development_study/assets/37537227/56058f79-c027-46e0-8ea2-520eb06b267f">
</div>

```sql
create table 주문 ( 주문번호 number, 주문일자 varchar2(8), 고객id varchar2(5), ...)
partition by range(주문일자) (
  partition p2009_q1 values less than ('20090401')
, partition p2009_q2 values less than ('20090701')
, partition p2009_q3 values less than ('20091001')
, partition p2009_q4 values less than ('20100101')
, partition p2010_q1 values less than ('20100401')
, partition p9999_mx values less than ( MAXVALUE )
```

<br>

### (3) 해시 파티셔닝
* 파티션 키에 해시 함수를 적용한 결과 값이 같은 레코드를 같은 파티션 세그먼트에 저장해 두는 방식이다
* 데이터 분포가 고르고 distinct value 개수가 많은 칼럼을 해시 파티션 기준 칼럼을 선정하는 것이 좋다
  * Range 및 리스트 파티셔닝과 다르게 해시 파티셔닝은 파티션 개수만 사용자가 결정하고 데이터를 분산시키는 해싱 알고리즘은 오라클이 결정하기 때문
* 등치(=) 조건 또는 IN-LIST 조건으로 검색할 때만 파티션 Pruning이 작동한다

<div align="center">
 <img width="50%" src="https://github.com/PoSungKim/development_study/assets/37537227/cec014c7-53a7-4526-9d73-87f71ff96248">
</div>

```sql
create table 고객 ( 고객id varchar2(5), 고객명 varchar2(10), ...)
partition by hash( 고객id ) partitions 4;
```

* 병렬 쿼리 성능 향상
* DML 경합 분산
  * 데이터 입력되는 테이블 블록에도 경합이 발생한다
  * 입력할 블록을 할당받기 위한 Freelist 조회 때문에 세그먼트 헤더 블록에 대한 경합이 더 자주 발생한다
  * Right Growing 인덱스도 해시 파티셔닝한 인덱스로 경합 발생 가능성을 낮출 수 있다
* 모두 트랜잭션이 많이 발생하는 대용량 거래 테이블일 때 효과가 극대화된다
  * 보통, Range와 해시 파티셔닝을 조합한 결합 인덱스를 주로 사용한다

<br>

### (4) 리스트 파티셔닝
* 사용자에 의해 미리 정해진 그룹핑 기준에 따라 데이터를 분할 저장하는 방식

<div align="center">
 <img width="50%" src="https://github.com/PoSungKim/development_study/assets/37537227/ab98d055-d0c2-4790-9042-b07d7d68647d">
</div>

```sql
create table 인터넷매물 ( 물건코드 varchar2(5), 지역분류 varchar2(4), ...)
partition by list( 지역분류 ) (
  partition p_지역1 values ('서울')
, partition p_지역2 values ('경기', '인천')
, partition p_지역3 values ('부산', '대구', '대전', '광주')
, partition p_기타 values (DEFAULT) -- 기타 지역
);
```

* 리스트 파티션에서는 순서와 상관없이 불연속적인 값의 목록으로써 결정된다
* 리스트 파티션에서는 사용자가 정의한 논리적인 그룹에 따라 분할한다
* default 파티션을 생성해 두어야 안전하다

<br>

### (5) 결합 파티셔닝
* 결합 파티셔닝 (Composite Partitioning)
  * 서브 파티션마다 세그먼트를 하나씩 할당하고, 서브 파티션 단위로 데이터를 저장한다
* (Range + 해시) 결합 파티셔닝
  * 주문 테이블 > 주문일자 > 고객ID
  ```sql
  create table 주문 ( 주분번호 number, 주문일자 varchar2(8), 고객id varchar2(5), ...)
  partition by range(주문일자)
  subpartition by hash(고객id) subpartitions 8
  ( partition p2009_q1 values less than ('20090401')
  , partition p2009_q2 values less than ('20090701')
  , partition p2009_q3 values less than ('20091001')
  , partition p2009_q4 values less than ('20100101')
  , partition p2010_q1 values less than ('20100401')
  , partition p9999_mx values less than ( MAXVALUE )
  );
  ```
  * p2009_q3 파티션에 속한 8개의 서브 파티션을 탐색하는 쿼리
  ```sql
  select * from 주문 where 주문일자 between '20090701' and '20090930';
  ```
  * 주문일자 없이 고객id로만 조회해서 각 Range별로 하나씩, 총 6개의 서브 파티션을 탐색하는 쿼리
  ```sql
  select * from 주문 where 고객id = :custid;
  ```
* (Range + 리스트) 결합 파티셔닝
  * 판매 테이블 > 판매일자 > 판매점
  * 초대형 이력성 테이블을 Range 파티셔닝하고, 각 파티션을 업무적으로 다시 분할하고자 할 때 주로 사용된다
  ```sql
  create table 판매 ( 판매점 varchar2(10), 판매일자 varchar2(8), ... )
  partition by range( 판매일자 )
  subpartition by list( 판매점 )
  subpartition template
  ( subpartition lst_01 values ('강남지점', '강북지점', '강서지점', '강동지점')
  , subpartition lst_02 values ('부산지점', '대전지점')
  , subpartition lst_03 values ('인천지점', '제주지점', '의정부지점')
  , subpartition lst_99 values ( DEFAULT ))
  ( partition p2009_q1 values less than('20090401')
  , partition p2009_q2 values less than('20090701')
  , partition p2009_q3 values less than('20091001')
  , partition 20009_q4 values less than('20100101') );
  ```
* 기타 결합 파티셔닝
  * Range-Range
  * 리시트-해시
  * 리스트-리스트
  * 리스트-Range

<br>

### (6) 11g에 추가된 파티션 유형
* Reference 파티셔닝

  <div align="center">
   <img width="50%" src="https://github.com/PoSungKim/development_study/assets/37537227/213b1eff-9f9c-4af2-acd2-0e39061585fd">
  </div>

  * 부모 테이블 파티션 키를 이용해 자식 테이블을 파티셔닝하는 기능
    * Reference 파티셔닝 기능이 없을 때는, 상품 테이블의 상품대분류 칼럼을 일별상품거래 테이블에 반정규화해야만 했다
      * 상품번호에 졷속적인 칼럼이므로 2차 정규형을 위배하게 된다

    ```sql
    create table 상품 (
      상품번호   number NOT NULL PRIMARY KEY
    , 상품명    varchar2(50)  not null
    , 현재가격   number  not null
    , 상품대분류  varchar2(4)  not null
    , 등록일시   date  not null
    )
    partition by list (상품대분류) (
      partition p1 values ('의류')
    , partitino p2 values ('식품')
    , partitino p2 values ('가전')
    , partitino p2 values ('컴퓨터')
    );
  
    create table 일별상품거래 (
      상품번호 number NOT NULL
    , 거래일자 varchar2(8)
    , 판매가격 number
    , 판매수량 number
    , 판매금액 number
    , constraint 일별상품거래_fk foreign key (상품번호) references 상품
    )
    partition by reference (일별상품거래_fk); -- Refernce 파티셔닝
    ```

* Interval 파티셔닝
  * Range 파티션을 생성할 때 interval 기준을 정의함으로써 정해진 가격으로 파티션이 자동 추가되는 기능
 
  ```sql
  create table 주문일자 (주문번호 number, 주문일시 date, ...)
  partition by range(주문일시) INTERVAL(NUMTOYMINTERVAL(1, 'MONTH'))
  (
  , ...
  , partition p200908 values less than(to_date('2009/09/01', 'yyyy/mm/dd'))
  , partition p200909 values less than(to_date('2009/10/01', 'yyyy/mm/dd'))
  , partition p200910 values less than(to_date('2009/11/01', 'yyyy/mm/dd'))
  );
  ```
  
  ```sql
  create table 고객 (고객번호 number, 고객명 varchar2(20), ...)
  partition by range(고객번호) INTERVAL(100000)
  (
  , partition p_cust1 values less than(100001)
  , partition p_cust1 values less than(200001)
  , partition p_cust1 values less than(300001)
  );
  ```
  
<br>
<hr>
<br>

## 파티션 Pruning
#### 

<br>

### (1) 기본 파티션 Pruning
* 파티션 Pruning 기능에 따른 실행계획 비교
* 파티션 Pruning 기능에 따른 I/O 수행량 비교
* 동적 파티션 Pruning 시 테이블 레벨 통계 사용

<br>

### (2) 서브쿼리 Pruning

<br>
<hr>
<br>

## 인덱스 파티셔닝
#### 

<br>
<hr>
<br>
