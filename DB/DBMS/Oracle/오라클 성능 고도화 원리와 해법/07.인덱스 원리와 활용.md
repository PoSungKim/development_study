# 인덱스 원리와 활용
> 
* 

<hr>
<br>

## 인덱스 구조
#### 

<br>

### 범위 스캔
* 인덱스는 키 칼럼 순으로 정렬돼 있기 때문에 특정 위치에서 스캔을 시작해 검색 조건에 일치하지 않는 값을 만나는 순간 멈출 수 있다
* 테이블은 일반적으로 힙 구조 테이블 (Heap-organized table)이기 때문에 범위 스캔이 있을 수 없다
  * IOT (index-organized table)는 특정 칼럼 순으로 정렬 상태를 유지하기 때문에 범위 스캔 가능

<br>

### 인덱스 기본 구조
* B*tree 인덱스
* LeftMost Child
* 요약
  * 리프 노드상의 인덱스 레코드와 테이블 레코드 간에는 1:1 관계
  * 리프 노드상의 키 값과 테이블 레코드 키 값은 서로 일치
  * 브랜치 노드상의 레코드 개수는 하위 렙레 블록 개수와 일치
  * 브랜치 노드상의 키 값은 하위 노드가 갖는 값의 범위를 의미

<br>

### 인덱스 탐색
* 수평적 탐색 : 범위 스캔 (Range Scan)
* 수직적 탐색 : 수평적 탐색을 위한 시작 지점을 찾는 과정
* 브랜치 블록 스캔
* 결합 인덱스 구조와 탐색
* ROWID 탐색
  * 파티션되지 않은 일반 테이블에 생성한 인덱스, 파티션된 테이블에 생성한 로컬 파티션 (Local Partitioned) 인덱스
    * 6 Byte
  * 파티션 테이블에 생성한 글로벌 파티션 (Global Partitioned) 인덱스, 비파티션 (Non Partitioned) 인덱스
    * 10 Byte
  * 제한 Rowid 포맷 (18자리)
    * 데이터파일 번호 (4자리) : 로우가 속한 데이터파일 번호로서, 데이터베이스 내에서 유일한 값
    * 블록 번호 (8자리) : 해당 로우가 저장된 데이터 블록 번호, (테이블스페이스가 아니라) 데이터파일 내에서의 상대적 번호
    * 로우 번호 (4자리) : 블록 내에서 각 로우에 붙여진 일련번호로서, 0부터 시작
  * 확장 Rowid 포맷 (18자리)
    * 데이터 오브젝트 번호 (6자리) : 데이터베이스 세그먼트를 식별하기 위해 사용되는 데이터 오브젝트 번호
    * 데이터퍄일 번호 (3자리)
    * 블록 번호 (6자리)
    * 로우 번호 (3자리)

<br>
<hr>
<br>

## 인덱스 기본 원리
#### B*Tree 인덱스를 정상적으로 사용하려면 범위 스캔 시작지점을 찾기 위해 루트 블록부터 리프 블록까지의 수직적 탐색 과정 필요
#### 인덱스 선두 칼럼이 조건절에 사용되지 않으면 범위 스캔을 위한 시작점을 찾을 수 없어 옵티마이저는 인덱스 전체를 스캔하거나 테이블 전체를 스캔하는 방식을 선택

<br>

### 인덱스 사용이 불가능하거나 범위 스캔이 불가능한 경우
* Index Range Scan은 불가능하지만, Index Full Scan은 가능한 경우
  ```sql
  select *
  from   업체
  where  substr(업체명, 1 2) = '대한';
  ```
  ```sql
  select *
  from   고객
  where  직업 <> '학생';
  ```
  ```sql
  select *
  from   사원
  where  부서코드 is not null; 
  ```
  * 단일 칼럼 인덱스는 null 값을 저장하지 않고, 결합 인덱스는 구성 칼럼 중 하나라도 null이 아닌 레코드는 인덱스에 포함시키기 때문에 필터링을 통해 is not null 만족 가능 
* Index 사용이 불가능한 경우
  * is null 조건만으로 검색할 때
    * 단일 칼럼 인덱스에는 not null인 레코드들만 있고, 결합 칼럼 인덱스는 모든 칼럼이 null인 레코드는 없어서 완전한 결과집합을 얻을 수 없기 때문
  ```sql
  select *
  from   사원
  where  연락처 is null;
  ```
  * not null인 칼럼은 is null 조건으로 조회하면, 옵티마이저는 Full Table Scan을 피하기 위해서 Index Range Scan을 한다
* not null 조건을 사용하지만 Index Range Scan이 가능한 경우
  * 결합 인덱스가 있고, 선두 칼럼들 중에 not null이외의 조건식이 하나라도 있는 경우
    * 인덱스 구성 칼럼 중 하나라도 null 값이 아닌 레코드는 결합 인덱스에 저장되기 때문
    * 오라클은 null을 가장 끝에 저장
  * 결합 인덱스에 속한 칼럼들 중 하나라도 Not Null Constraint가 있다면 항상 Index Range Scan 가능
  ```sql
  create index emp_idx on emp(job, deptno);
  -- is null 조건 이외의 조건이 있는 경우고, deptno 칼럼이 not null한 칼럼인 경우이기도 해서 Index Range Scan을 타게 된다
  select * from emp where job is null and deptno = 20;
  ```
  
<br>

### 인덱스 칼럼의 가공
* 인덱스 칼럼을 가공하면 정상적인 Index Range Scan이 불가능하기에 가공 사례를 튜닝하는 방법 고려 필요

| 인덱스 칼럼 가공 사례                                                 | 튜닝 방안                                                                                                     |
|-----------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------|
| select *<br>from 업체<br>where substr(업체명,1,2) = '대한'            | select *<br>from 업체<br>where 업체명 like '대한%'                                                            |
| select *<br>from 사원<br>where 월급여 * 12 = 36000000                 | select *<br>from 사원<br>where 월급여 = 36000000/12                                                           |
| select *<br>from 주문<br>where to_char(일시, 'yyyymmdd') = :dt        | select *<br>from 주문<br>where 일시 >= to_date(:dt, 'yyyymmdd')<br>and   일시 < to_date(:dt, 'yyyymmdd')      |
| select *<br>from   고객<br>where  연령 \|\| 직업 = '30공무원'         | select *<br>from   고객<br>where  연령 = 30<br>and    직업 = '공무원'                                         |
| select *<br>from   회원사지점<br>where  회원번호 \|\| 지점번호 = :str | select *<br>from   회원사지점<br>where  회원번호 = substr(:str, 1, 2)<br>and    지점번호 = substr(:str, 3, 4) |
* null이 숫자와 비교되면 0으로 치환된다
  * 0으로 치환되도 결과집합에는 미포함되기 때문에 결과집합은 동일하며, Index에 null 값을 미포함하더라도 어차피 결과집합에 미포함되는 레코드들이기 때문에 Index를 정상적으로 탈 수 있다. 즉, 문제 없다.
  ```sql
  -- 튜닝 전 
  select *
  from   주문
  where  nvl(주문수량, 0) >= 100

  -- 튜닝 후 (어차피 null값은 0으로 치환되기 때문에 이상인 값을 찾을 때는 nvl로 초기화할 필요는 없다
  select *
  from   주문
  where  주문수량 >= 100;
  ```
* 하지만, 미만을 찾는 연산에서는 고려를 더 해줘야 한다
  * null이 0으로 치환되는데 nvl을 사용했다는 점을 보면, 100 이하거나 null이면 결과집합에 포함시키려는 의도가 보이기 때문
  ```sql
  -- 튜닝 전
  select *
  from   주문
  where  nvl(주문수량, 0) < 100;

  -- 만약 주문수량이 not null 칼럼이면,
  -- nvl을 통한 null 고려도 필요없고 null 값 자체가 없기 때문에 index 범위 스캔에도 문제없다
  select *
  from   주문
  where  주문수량 < 100;
  
  -- 만약 주문수량이 null 칼럼이고 null값을 가진 레코드들까지 조회하는 것이 의도혔다면
  -- Table Full Scan이 불가피하다
  -- nvl을 사용하나 하단의 조건절을 사용하나 다 불가피하다
  select *
  from   주문
  where  주문수량 < 100 or 주문수량 is null

  -- 만약 null인 레코드가 너무 많아서 오히려 Table Full Scan이 효율적이면 괜찮지만
  -- 만약 아니라면, 함수 기반 인덱스 FBI (Function-based Index) 생성도 고려 가능
  create index 주문_x01 on 주문 ( nvl(주문수량, 0) );
  ```

* 튜닝 사례 1)
  * 인덱스 칼럼을 가공한 것이 원인이 되어 성능 이슈 발생한 케이스
    * 인덱스 선두 칼럼인 (지수구분코드)와 (지수업종코드)을 가공하여 의도했던 PK Index를 타지 못함
    * (거래일자)만 가지고 있는 index 혹은 table full scan으로 실행계획이 풀리게 되는 상황
```sql
-- 인덱스 구성도
일별지수업종별거래및시세_PK  : (지수구분코드, 지수없종코드, 거래일자)
일별지수업종별거래및시세_X01 : 거래일자
```
```sql
-- 튜닝 전
select 거래일자
       , sum(decode(지수구분코드, '1', 지수종가, 0)) kospi200_idx
       , sum(decode(지수구분코드, '1', 누적거래량, 0)) kospi200_idx_trdvol
       , sum(decode(지수구분코드, '2', 지수종가, 0)) kosdaq_idx
       , sum(decode(지수구분코드, '2', 누적거래량, 0)) kosdaq_idx_trdvol
from     일별지수업종별거래및시세 a
where    거래일자 between :startDd and :endDd
and      지수구분코드 || 지수업종코드 in ('1001', '2003') -- 바로 여기서 인덱스 선두 칼럼 (지수구분코드, 지수업종코드)를 가공함
group by 거래일자
```
```sql
-- 튜닝 후
select 거래일자
       , sum(decode(지수구분코드, '1', 지수종가, 0)) kospi200_idx
       , sum(decode(지수구분코드, '1', 누적거래량, 0)) kospi200_idx_trdvol
       , sum(decode(지수구분코드, '2', 지수종가, 0)) kosdaq_idx
       , sum(decode(지수구분코드, '2', 누적거래량, 0)) kosdaq_idx_trdvol
from     일별지수업종별거래및시세 a
where    거래일자 between :startDd and :endDd
and      (지수구분코드, 지수업종코드) in ( ('1', '001'), ('2', '003') ) -- IN-List 형태로 튜닝
group by 거래일자
```
* 튜닝 사례 2)
  * decode로 인덱스 선두 칼럼인 (정정대상접수번호, 금감원접수번호)를 모두 가공해버리기 때문에, decode문을 논리적으로 동일한 결과를 리턴하도록 리팩토링
```sql
-- 인덱스 구성도
접수정보파일_PK  : 수신번호
접수정보파일_X01 : (정정대상접수번호, 금감원접수번호)
```
```sql
-- 튜닝 전
select *
from   접수정보파일
where  decode( 정정대상접수번호, lpad(' ', 14), 금감원접수번호, 정정대상접수번호 ) = :접수번호 -- 리팩토링 대상
```
```sql
-- 튜닝 후
select *
from   접수정보파일
where  정정대상접수번호 in (:접수번호, lpad(' ', 14))
and    금감원접수번호 = decode( 정정대상접수번호, lpad(' ', 14), :접수번호, 금감원접수번호 ) -- 리택토링 완료
```

<br>

### 묵시적 형변환
* 묵시적 형변환으로 인해 인덱스를 제대로 타지 못하는 부작용이 발생할 수 있다
  * NL Outer 조인 Outer Table이 Driving Table이 되기 때문에, y 테이블의 조인 칼럼을 모두 포함하고 있는 인덱스를 보고, INDEX UNIQUE SCAN으로 실행계획이 풀릴 것이라고 생각했지만, INDEX FULL SCAN으로 실행계획이 풀릴 수 있다
  * 의도하지 않은 형변환으로 인해, 조인 칼럼이 가공되었기 때문인데, 이를 해결하면 의도했던 INDEX UNIQUE SCAN으로 실행계획을 만들 수 있다
    * 문자형에 +- 연산을 가하면 내부적으로 문자형이 숫자형으로 형변환을 해버린다
  * 인덱스 칼럼과 비교되는 반대쪽을 인덱스 칼럼 데이터 타입으로 맞춰줘야 한다
  * DBMS에서 사용자의 편의성을 위해서 묵시적 형변환 기능은 제공하지만, 웬만하면 직접 찝어주는 것이 좋고 사용하지 않는 것이 좋다
    * (문자형, 숫자형) -> (숫자형)
    * (문자형, 날짜형) -> (날짜형)
  ```sql
  월별품목실적_PK : 대상연월 + 영업조직ID + 물품지원품목코드
  월별품목실적_N1 : 대상연월 + 물품지원품목코드 + 영업조직ID
  ```
  ```sql
  select count(*)
  from (
  ) x, 월별품목실적 y
  where y.물품지원품목코드(+) = x.물품지원품목코드
  and   y.영업조직id(+)     = x.물품원신청조직id
  and   y.대상연월(+)       = substr(x.파트너지원요청일자, 1, 6) - 1 -- 문자형에서 숫자형으로 묵시적 형변환 발생하여 부작용이 발생한 조건문
  -- and   to_number(y.대상연월(+)) = to_number(substr(x.파트너지원요청일자, 1, 6)) - 1 문으로 변환된 것과 같다

  -- 따라서, 하단의 조인문으로 튜닝하여, y.대상연월(+) 칼럼이 가공되지 않게 막고 인덱스를 정상적으로 태울 수 있게 된다
  and   y.대상연월(+)       = to_char(add_months(to_date(x.파트너지원요청일자, 'yyyymmdd'), -1), 'yyyymm')
  ```
* 묵시적 형변환 사용시 주의사항
  * 문자형이 숫자형과 만나면 문자형으로 형변환한다
    * 이를 막기 위해서 like 연산 사용 가능
  * decode(a,b,c,d) 연산의 출력값 타입은 c인자 타입을 따라간다
    * null 값은 varchar2 타입으로 판단하기 때문에 문자형이 아닌 숫자형으로 리턴하고자 하면 to_number() 사용 가능
  ```sql
  -- 문자형 --> 숫자형 변환 예시
  where n_col = v_col

  -- 숫자형 --> 문자형 변환 예시
  where n_col like v_col || '%'
  -- where to_char(n_col) like v_col || '%'
  ```
  ```sql
  select round(avg(sal)) avg_sal
        , min(sal) min_sal
        , max(sal) max_sal
        , max(decode(job, 'PRESIDENT', NULL, sal)) max_sal2
  from    scott.emp;

  select round(avg(sal)) avg_sal
        , min(sal) min_sal
        , max(sal) max_sal
        , max(decode(job, 'PRESIDENT', to_number(NULL), sal)) max_sal2
  from    scott.emp;
  ```
* 함수기반 인덱스 (FBI) 활용
  * 시간적으로 여유가 없다면 함수기반 인덱스를 이용해서 급하게 해결할 수는 있지만 권장되지 못하는 방법
  ```sql
  create index emp_x01 on emp(v_deptno);
  select * from emp where v_deptno = 20;
  -- Predicate Information -> filter(to_number("V_DEPTNO")=20)

  drop index emp_x01;
  create index emp_x01 on emp( to_number( v_deptno ) ); -- FBI 생성
  select * from emp where v_deptno = 20;
  -- Predicate Information -> access(to_number("V_DEPTNO")=20)
  ```

<br>
<hr>
<br>

## 다양한 인덱스 스캔 방식
#### 

<br>

### Index Range Scan
```sql
create index emp_deptno_idx on emp(deptno);
select * from emp where deptno = 20;
```
* 인덱스 루트 블록에서 리프 블록까지 수직적으로 탐색한 후에 리프 블록을 필요한 범위만 스캔하는 방식
  * B*Tree 인덱스의 가장 일반적이고 정상적인 형태의 엑세스 방식
* 튜닝 포인트
  * 인덱스를 스캔하는 범위 (Range)를 얼마만큼 줄일 수 있느냐
  * 테이블로 액세스하는 횟수를 얼마만큼 줄일 수 있느냐 
* 사용방법
  * 조건절에 인덱스를 구성하는 선두 칼럼이 조건절에 사용되어야 한다; 없으면, Index Full Scan으로 처리된다
  * 결과집합은 인덱스 칼럼 순으로 정렬되어 sort order by연산을 스킵하거나 min/max 값을 빠르게 추출 가능
 
<br>

### Index Full Scan
```sql
create index emp_dx on emp (ename, sal);
-- 선두 칼럼 (ename)이 조건절에 없다
select * from emp where sal > 2000 order by ename;
```
* 수직적 탐색없이 인덱스 리프 블록을 처음부터 끝까지 수평적으로 탐색하는 방식
  * 검색을 위한 최적의 인덱스가 없을 때 차선으로 선택되는 방식
* Index Full Scan의 효용성
  * 옵티마이저는 인덱스 선두 칼럼(ename)이 조건절에 없으면 Table Full Scan을 가장 우선적으로 고려한다
  * 하지만, 대용량 테이블이어서 Table Full Scan의 부담이 크다면 옵티마이저는 인덱스를 활용하는 방법을 고려한다
  * 테이블의 데이터 저장공간은 `가로 x 세로`, `칼럼길이 x 레코드수`에 의해서 결정되는데, 대개 인덱스가 차지하는 면적은 테이블보다 작다
  * 따라서, 테이블 전체를 스캔하는 것보다 인덱스 스캔 단계에서 대부분을 필터링하고 일부 레코드들만 테이블 액세스가 발생하도록 하면 I/O를 효율적으로 발생시킬 수 있고, 이때 옵티마이저는 Index Full Scan을 선택한다
  ```sql
  -- emp 테이블에서 연봉이 5000을 초과하는 사원이 전체에서 극히 일부라서 Table Full Scan이 아니라 Index Full Scan 하면서 조건절에 맞는 레코드들만 테이블 액세스한다
  select * from emp where sal > 5000 order by ename;
  ``` 
* 인덱스를 이용한 소트 연산 대체
  * Index Full Scan도 결과집합이 인덱스 칼럼 순으로 정렬이 되어 있어서 Sort Order By 연산을 생략할 수 있다
    * 전체를 모두 Fetch하면 Table Full Scan이 효율적이지만, /*+ first_rows */로 Sort 연산을 생략함으로써 전체 집합 중 일부만을 빠르게 리턴할 목적으로 옵티마이저가 Index Full Scan을 사용
  ```sql
  -- 대부분의 직원들의 연봉이 1000을 넘기 때문에, 힌트가 없었으면 Table Full Scan이 더 효율적
  select /*+ first_rows */ * from emp
  where  sal > 1000
  order by ename;
  ```

<br>

### Index Unique Scan
* 수직적 탐색만으로 데이터를 찾는 스캔 방식
  * Unique 인덱스를 통해 `=` 조건으로 탐색하는 경우에 작동한다
```sql
create unique index pk_emp on emp(empno);
alter table emp add constraint pk_emp primary key(empno) using index pk_emp;

select empno, ename from emp where empno = 7788;
```
* Unique 인덱스에서도 범위검색 조건 (between, 부등호, like) 사용하면 Index Range Scan 가능

<br>

### Index Skip Scan
* 인덱스 선두 칼럼이 조건절로 사용되지 않으면 옵티마이저는 기본적으로 Table Full Scan을 선택하고, 만약 I/O를 줄이거나 정렬연산을 줄일 수 있다면 Index Full Scan을 선택한다
* 하지만, 오라클은 인덱스 선두 칼럼이 조건절에 없어도 인덱스를 활용하는 Index Skip Scan 방식 사용
  * 인덱스 선두 칼럼의 Distinct Value 개수가 적고 후행 칼럼의 Distinct Value 개수가 많을 때 유용
```sql
create index 사원_IDX on 사원(성별, 연봉);

select /*+ index_ss(사원 사원_IDX) */ *
from   사원
where  연봉 between 2000 and 4000; -- 성별이 빠졌다
```
* Index Skip Scan은 루트 또는 브랜치 블록에서 읽은 칼럼 값 정보를 이용해 조건에 부합하는 레코드를 포함할 "가능성이 있는" 리프 블록만 골라서 액세스하는 방식
  * 첫 번째 리프 블록과 마지막 리프 블록은 항상 방문한다
* 버퍼 Pinning을 이용한 Skip 원리
  * 리프 블록에서만 이동하는게 아니라, 실제로는 위에 위치한 브랜치 블록을 재방문해서 다음 방문한 리프 블록에 대한 주소를 얻는다
  * 버퍼 Pinning을 통해, 루트 또는 브랜치 블록 정보를 가지고 있어서 추가적은 블록 I/O없이 다시 되돌아와서 조회가 필요한 리프 블록 정보를 얻을 수 있다
* Index Skip Scan이 작동하기 위한 조건
  * Distinct Value 개수가 적은 선두 칼럼이 조건절에서 누락됐고 후행 칼럼의 Distinct Value 개수가 많은 경우
  * 중간 인덱스 칼럼이 누락된 경우
  * Distinct Value가 적은 2개의 선두 칼럼이 모두 누락된 경우
  * 선두 칼럼이 부등호, between, like 같은 범위검색 조건인 경우 (선두칼럼이 범위 검색이면 Index Range Scan에서 비효율이 발생하기 때문)
* In-List Iterator와의 비교
  * In-List로 Iterate 돌면서 Index Range Scan을 별도로 계속 수행된다
  * Index Skip Scan과의 차이점은 성별의 분포도를 완벽히 알고 있다는 점이다
    * In-List로 성별을 모두 찝어주는 것과 반대로, Index Skip Scan은 성별 정보를 모르기 때문에, 첫번째 및 끝번째 블록을 읽는 것에서 수행 프로세스가 다르다는 것을 알 수 있다
  ```sql
  select * from 사원
  where  연봉 between 2000 and 4000
  and    성별 in ('남', '여'); -- In-List로 성별을 모두 찝어준다
  ```

<br>

### Index Fast Full Scan
* Index Fast Full Scan은 인덱스 트리 구조를 무시하고 인덱스 세그먼트 전체를 Multiblock Read 방식으로 스캔한다
  * Index Full Scan (논리적 순서): 1 -> 2 -> 3 -> ... -> 10
  * Index Fast Full Scan (물리적 순서) : 1 -> 2 -> 10 -> 3 -> 9 -> 8 -> 7 -> ... -> 6
* 오라클 10g에서의 변화
  * 10g부터는 테이블 액세스없이 인덱스 액세스만 있을 때, Index Rnage Scan 또는 Index Full Scan일 때도 Multiblock I/O 방식으로 읽는 경우가 있다
  * 다만, 
```sql
-- 초기화
create index big_table_idx on big_table( object_name );
alter system flush buffer_cache;
show parameter multiblock

-- Index Full Scan (성능 감소) -> db file sequential read
select /*+ index(b big_table_idx) */ count(object_name)
from   big_table b;

-- Index Fast Full Scan (성능 개선) -> db file scattered read
select /*+ index_ffs(b big_table_idx) */ count(object_name)
from   big_table b;
```
* Index Fast Full Scan의 특징
  * Multiblock Read 방식을 사용하므로 디스크로부터 대량의 인덱스 블록을 읽어야 하는 상황에서 큰 효과 발휘

| Index Full Scan                                           | Index Fast Full Scan                              |
|-----------------------------------------------------------|---------------------------------------------------|
| 인덱스 구조를 따라 스캔                                   | 세그먼트 전체를 스캔                              |
| 결과집합 순서 보장 O                                      | 결과집합 순서 보장 X                              |
| Single Block I/O                                          | Multiblock I/O                                    |
| 병렬스캔 불가(파티션 돼 있지 않다면)                      | 병렬스캔 가능                                     |
| 인덱스에 포함되지 않은 칼럼 조회 시에도 사용 가능         | 인덱스에 포함된 칼럼으로만 조회할 때 사용 가능    |

* Index Fast Full Scan을 활용한 튜닝 사례
  * like로 중간연산을 하면 Index Range Scan을 태울 수 없다
  * 따라서, 어차피 못 타는 상황임으로, like보다 따른 instr 연산으로 대체하고, 필터링 조건으로 건수를 줄인 이후에 rowid로 조인을 거는 형태로 튜닝 진행
```sql
-- 튜닝 전
select * from 공급업체
where  업체명 like '%네트웍스%'
```
```sql
-- 튜닝 후
select /*+ ordered use_nl(b) no_merge(b) rowid(b) */ b.*
from ( select /*+ index_ffs(공급업체 공급업체_X01) */ rowid rid
       from 공급업체
       where instr(업체명, '네트웍스') > 0) a, 공급업체 b
where  b.rowid = a.rid
```
<br>

### Index Range Scan Descending
* Index Range Scan과 기본적을 동일한 스캔 방식이며, 인덱스를 뒤에서부터 앞쪽으로 스캔하기 때문에 내림차순으로 정렬된 결과집합을 얻는다
```sql
select * from emp
where  empno > 0
order by empno desc;
```
```sql
create index emp_x02 on emp(deptno, sal);

select deptno, dname, loc
      ,(select max(sal) from emp where deptno = d.deptno)
from dept d
```
```sql
select deptno, dname, loc
      ,(select /*+ index_desc(emp emp_x02) */ sal
        from emp
        where deptno = d.deptno
        and   rownum <= 1)
from dept d
```

<br>

### And-Equi, Index Combine, Index Join
* 2 개 이상의 인덱스를 함께 사용하는 방법
```sql
create index emp_deptno_idx on emp(deptno);
create index emp_job_idx on emp(job);
```
* And-Equi
  * 단일 칼럼의 Non-Unique 인덱스여야 함과 동시에 인덱스 칼럼에 대한 조건절이 `=` 이어야 한다
  * `=` 조건을 전제로 하므로 인덱스 필터링을 거친 양쪽 집합은 rowid 순으로 정렬된 상태
  ```sql
  select /*+ and_equal(e emp_deptno_idx emp_job_idx) */ *
  from   emp e
  where  deptno = 30
  and    job = 'SALESMAN';
  ```
* Index Combine
  * 단일 칼럼의 Non-Unique 인덱스이지 않아도 되고, 조건절이 `=` 이 아니어도 된다
  ```sql
  select /*+ index_combine(e emp_deptno_idx emp_job_idx) */ *
  from   emp e
  where  deptno = 30
  and    job = 'SALESMAN';
  ```
  ```sql
  select /*+ index_combine(e emp_deptno_idx emp_job_idx) */ *
  from   emp e
  where  deptno = 30
  or    job = 'SALESMAN';
  ```
* Index Join
  * Index Join은 해시 조인 매커니즘을 그대로 사용
  ```sql
  select /*+ index_combine(e emp_deptno_idx emp_job_idx) */ *
  from   emp e
  where  deptno = 30
  or    job = 'SALESMAN';
  ```

<br>
<hr>
<br>

## 테이블 Random 액세스 부하
#### 인덱스를 효과적으로 사용하면 효율적이지만, 대량의 데이터를 인덱스를 통해 액세스할 때 쿼리 성능이 느려진다

<br>

### 인덱스 ROWID에 의한 테이블 액세스
* TABLE ACCESS (BY INDEX ROWID) OF '고객' (TABLE)
  * 쿼리에서 참조되는 칼럼이 인덱스에 모두 포함되는 경우가 아니라면 인덱스 스캔 이후 테이블 Random 액세스 발생
* 물리적 주소? 논리적 주소?
  * rowid
    * 오브젝트 번호
    * 데이터파일 번호
    * 블록 번호
  * 인덱스에서 테이블 레코드로 직접 연결되는 구조는 아니다
    * 그래서 사람들의 시각마다 물리적 혹은 논리적 주소라고 말한다
* 메인 메모리 DB와의 비교
  * 메인 메모리 DB는 인스턴스를 기동하면 디스크에 저장된 데이터를 버퍼 캐시로 로딩하고 이어서 인덱스를 실시간을 ㅗ만든다
    * 이때, 인덱스는 오라클처럼 디스크 상의 주소정보를 담는 게 아니라 메모리상의 주소정보, 즉 포인터를 담는다
  * 오라클은 테이블 블록이 수시로 버퍼 캐시에 서 밀려났다가 다시 캐싱되며, 그때마다 다른  ㅗㅇ간에 캐싱되기 때문에 인덱스에서 직접 포인터로 연결할 수 없는 구조
    * 대신 디스크 상의 블록 위치 정보, 즉 DBA (Data Block Address)를 해시 키값으로 삼아 해싱 알고리즘을 통해 버퍼 블록을 찾는다
    * 매번 위치가 달라지더라도 캐싱되는 해시 버킷만큼은 고정적
* rowid는 우편주소에 해당
  * rowid를 통해 테이블 엑세스하는 것이 독자들이 보통 생각보다 느리다는 것을 전화번호와 우편주소를 비유하여 설명함
* 인덱스 rowid에 의한 테이블 액세스 구조
  * 모든 데이터가 메모리에 캐싱돼 있더라도 테이블 레코드를 찾기 위해 매번 DBA를 해싱하고 래치 획득 과정을 반복해야 하고, 동시 액세스가 심할 때는 래치와 버퍼 Lock에 대한 경합까지 발생
  * 데이터가 메모리에 없으면, Free 버퍼 할당 > cache buffers lru chain 래치 획득 시도 > free buffer waits 대기 이벤트 > db file sequential read 대기 이벤트 > cache buffers lru chains 래치 획득 시도 > latch free 이벤트 

<br>

### 인덱스 클러스터링 팩터
* 군집성 계수(= 데이터가 모여 있는 정도)
  * 특정 칼럼을 기준으로 같은 값을 갖는 데이터가 서로 모여있는 정도를 의미
  * Clustering Factor (CF)가 좋은 칼럼에 생성한 인덱스는 검색 효율이 좋은데, 물리적으로 가까운 데이터를 조회하는 것이 당연히 더 빠르기 때문
* 클러스터링 팩터 조회

```sql
create index t_object_id_idx on t(object_id);

create index t_object_name_idx on t(object_name);

select  i.index_name, t.blocks table_blocks, i.NUM_ROWS, i.CLUSTERING_FACTOR
from    user_tables t, user_indexes i
where   t.table_name = 'T'
and     i.TABLE_NAME = t.TABLE_NAME;
```

<div align="center">
  <img width="80%" src="https://github.com/PoSungKim/development_study/assets/37537227/39db9252-9ede-46c9-a7fd-2c56e0f0d3a6">
</div>

```
비용 = blevel +                        -- 인덱스 수직적 탐색 비용
      (리프 블록 수 * 유효 인덱스 선택도) +  -- 인덱스 수평적 탐색 비용
      (클러스터링 팩터 * 유효 테이블 선택도)  -- 테이블 Random 액세스 비용
```
* blevel : 리프 블록에 도달하기전 읽게 될 브랜치 블록 개수
* 유효 인덱스 선택도 : 전체 인덱스 레코드 중에서 조건절을 만족할 레코드를 찾기 위해 스캔할 것으로 예상되는 비율(%)
* 유효 테입르 선택도 : 전체 레코드 중에서 인덱스 스캔을 완료하고서 최종적으로 테이블을 방문할 것을 예상되는 비율(%)
* 클러스터링 팩터와 물리적 I/O
  * "인덱스 CF가 좋다" : 인덱스 정렬 순서와 테이블 정렬 순서가 비슷하다
  * 물리적인 디스크 I/O 횟수를 감소시키는 효과
* 클러스터링 팩터와 논리적 I/O
  * 인덱스를 경유해 테이블 전체 로우를 액세스할 때 읽을 것으로 예상되는 논리적인 블록 개수를 의미
  * good (t_object_id_idx) : clustering_factor가 전체 테이블 블록 개수와 일치
  * bad  (t_object_name_idx) : clustering_factor가 전체 테이블 레코드 개수와 일치

```sql
select /*+ index(t t_object_id_idx) */ count(*)
from   t
where  object_name >= ' '
and    OBJECT_ID >= 0;
```

<div align="center">
  <img width="80%" src="https://github.com/PoSungKim/development_study/assets/37537227/49d11a71-d475-4d2d-8b2b-48d6f9d3f2e1">
</div>

```sql
select /*+ index(t t_object_name_idx) */ count(*)
from   t
where  object_name >= ' '
and    OBJECT_ID >= 0;
```

<div align="center">
  <img width="80%" src="https://github.com/PoSungKim/development_study/assets/37537227/291dcf21-6742-4c05-9f64-b94a6fb94573">
</div>

* 버퍼 Pinning에 의한 논리적 I/O 감소 원리
  * t_object_id_idx과 t_object_name_idx을 통했을 때, 논리적인 블록 I/O 개수에서 차이가 발생하는 이유
    * 인덱스를 통해 액세스되는 하나의 테이블 버퍼 블록을 Pinning하기 때문
      * 방금 액세스한 버퍼에 대한 Pin을 즉각 해제하지 않고 데이터베이스 Call 내에서 계속 유지하는 기능
      * 연속된 인덱스 레코드가 같은 블록을 가리킼ㄴ다면, 래치 획득 과정을 생략하고 버퍼를 Pin한 상태에서 읽기 때문에 논리적인 블록 읽기 (Logical Reads) 횟수가 증가하지 않는다
   * CF가 좋아서 버퍼 Pinning 효과를 극대화할 수 있다면 Random 블록 I/O가 단 2번 발생 vs CF가 나빠서 버퍼 Pinning 효과를 못 본다면 Random 블록 I/O가 9번 발생
     * 실선 : 해시 체인 래치를 획득하고서 블록을 액세스
     * 점선 : 래치 획득 없이 버퍼를 Pin한 상태에서 액세스

<div align="center">
  <img width="80%" src="https://github.com/PoSungKim/development_study/assets/37537227/b0182e93-30e7-4a97-97c0-dd584cf2e188">
</div>

<br>

### 인덱스 손익분기점
* Index Range Scan에 의한 테이블 액세스가 Table Full Scan보다 느려지는 지점이 인덱스 손익분기점
  * 인덱스 rowid에 의한 테이블 액세스는 Random 액세스 방식 vs Full Table Scan에 의한 테이블 액세스는 Sequential 액세스 방식
  * 인덱스 rowid에 의한 테이블 액세스는 Single Block Read 방식 vs Full Table Scan은 Multiblock Read 방식
* Full Table Scan은 읽은 레코드 개수의 영향을 덜 받으면서 비슷한 속도를 유지하지만, Good CF Index와 Bad CF Index는 읽은 레코드의 개수가 증가하면서 소요시간도 같이 증가하면서 결국 Full Table Scan보다 느려지는 분기점이 발생하게 된다
```sql
create table t
as
select * from ALL_OBJECTS
order by object_id;

create table good_cl_factor
pctfree  0
as select t.*, lpad('x', 360) x from t
order by object_id;

create table bad_cl_factor
pctfree  0
as select t.*, lpad('x', 360) x from t
order by dbms_random.value;
```
* 손익분기점을 극복하기 위한 기능들
  * IOT (Index-Organized Table)
    * 테이블을 인덱스 구조로 생성하는 방식으로, 리프 블록이 데이터 블록이라서 Random Access가 발생하지 않는다
  * Clustered Table
    * 키 값이 같은 레코드는 같은 블록에 모이도록 저장하기 때문에 클러스터 인덱스를 이용할 때는 테이블 Random 액세스가 키 값별로 한번씩만 발생한다
    * 클러스터에 도달해서는 Sequential 방식으로 스캔하기 때문에 넓은 범위를 읽더라도 비효율이 없다
  * 파티셔닝
    * 대량 범위 조건으로 자주 사용되는 칼럼 기준으로 테이블을 파티셔닝한다면 Full Table Scan 하더라도 일부 파티션만 읽고 멈추도록 할 수 있다

<div align="center">
  <img width="50%" src="https://github.com/PoSungKim/development_study/assets/37537227/d30aec17-d047-452c-8d10-341e9613df66">
</div>

<br>
<hr>
<br>

## 테이블 Random 액세스 최소화 튜닝
#### 

<br>

### (1) 인덱스 칼럼 추가
* 기존 인덱스 칼럼 구성을 변경하는 것은 기존 쿼리에 영향을 주기 때문에 함부로 수정하기 위험하다
* 이미 존재하는 인덱스도 많아서 인덱스를 추가하는 것에도 부담이 있다면, 기존 인덱스에 칼럼을 추가하는 방법도 가능하다
  * 인덱스에서 필터링을 한 차례 더 해서 테이블 Random 액세스가 필요한 건들을 줄일 수 있다

```sql
-- emp_x01 (deptno, job)
select /*+ index(emp emp_x01) */ *
from emp
where deptno = 30
and sal >= 2000

-- emp_x01 (deptno, job, sal)
select /*+ index(emp emp_x01) */ *
from emp
where deptno = 30
and sal >= 2000
```
* 조회하는 데이터 양이 많은 환경에서 서비스번호의 조건이 '010%'이기 때문에 만족하는 데이터들이 뿔뿔이 흩어져 있어서 클러스터링 팩터가 안 좋아질 수밖에 없다

```sql
select 랜탈관리번호, 고객명, 서비스관리번호, 서비스번호, 예약접수일시, 방문국가코드1, 방문국가코드2, 방문국가코드3, 로밍승인번호, 자동로밍여부
from   로밍렌탈
where  서비스번호 like '010%'
and    사용여부 = 'Y'
```

<br>

### (2) PK 인덱스 칼럼 추가
* 단일 테이블을 PK로 액세스할 때는 단 한건만 조회해서 테이블 Random 액세스는 단 1회 발생
* 하지만, NL 조인할 때 Inner쪽에서 액세스될 때는 Random 액세스 부하가 크다
  * 특히, Outer 테이블에서 Inner 테이블 쪽으로 조인 액세스가 많은 상황에서 Inner 쪽 필터 조건에 의해 버려지는 레코드가 많다면 그 비효율은 매우 심각해진다
* ordered이기에 e 테이블 액세스 후 d 테이블에 NL로 조인되는 실행계획이다
  * d 테이블은 dept_pk 인덱스 (deptno)가 있어서, 14건이 인덱스에서 조회가 됐고, 14번 테이블 Random Access가 발생한 이후에 3건이 테이블에서 필터링된다
* dept_pk 인덱스가 (deptno, loc)으로 확장되면 테이블 Random 액세스가 감소될 수 있다
 
```sql
select /*+ ordered user_nl(d) */ *
from   emp e, dept d
where  d.deptno = e.deptno
and    d.loc = 'NEW YORK';
```

* 하지만 pk 인덱스에는 칼럼을 추가할 수 없기 때문에 (PK 칼럼, 필터조건 칼럼) 형태의 새로운 Non-Unique 인덱스를 추가하는 경우도 있다
* PK 제약에는 중복 값 확인을 위한 인덱스가 반드시 필요하다
  * 인덱스가 없다면 테이블 전체를 매번 읽어서 중복 값 존재여부를 체크해야 하기 때문
  * 하지만, 중복 체크를 위해서 꼭 Unique 인덱스만 필요한 것은 아니며, Non-Unique 인덱스를 이용해 PK 제약 설정도 가능하다
* 하단처럼 Non-unique Index로도 PK 제약을 설정할 수 있으면 PK 인덱스를 하나 감소시키는 효과가 있다
  * 또한, PK 제약 칼럼 (고객번호, 상품번호, 거래일자)들이 선두에 있기만 하면 된다
    * (가능) 거래일자 + 고객번호 + 상품번호
    * (가능) 상품번호 + 거래일자 + 고객번호 + 거래구분
    * (가능) 고객번호 + 거래일자 + 상품번호 + 매체구분 + 거래구분
    * (불가능) 고객번호 + 상품번호 + `거래구분` + 거래일자

```sql
alter table dept drop primary key;

create index dept_x01 on dept(deptno, loc);

alter table dept add constraint dept_pk primary key(deptno) using index dept_x01;
```

<br>

### (3) 칼럼 추가에 따른 클러스터링 팩터 변화
* 인덱스에 칼럼을 추가하여 테이블 Random 액세스 부하를 줄이는 효과가 있지만, 인덱스 클러스터링 팩터가 나빠지는 부작용도 있을 수 있다

```sql
create table t
as
select * from ALL_OBJECTS
order by object_type
;
```

* 클러스터링 팩터가 좋은 케이스)
```sql
create index t_idx on t(object_type);

select /*+ index(t t_idx) */ count(object_name), count(owner) from t
where  object_type > ' ';
```
<div align="center">
  <img width="50%" src="https://github.com/PoSungKim/development_study/assets/37537227/f16c3b37-b88d-4588-a9ab-156affc1f6e6">
</div>

* 클러스터링 팩터가 나쁜 케이스)
  * rowid가 object_name으로도 정렬되면서 CF가 나빠지는 부작용이 발생
  * 이제 object_name은 인덱스 내에서 count 가능하지만, owner는 아직 인덱스에 있어서 테이블을 순회해야함 
```sql
create index t_idx on t(object_type, object_name);

select /*+ index(t t_idx) */ count(object_name), count(owner) from t
where  object_type > ' ';
```

<div align="center">
  <img width="50%" src="https://github.com/PoSungKim/development_study/assets/37537227/7d019de7-e2e8-459b-bf3e-fb75f5125b88">
</div>

<br>

### (4) 인덱스만 읽고 처리
* 인덱스만 읽고 처리하는 쿼리를 Covered 쿼리
* 사례 1)
  * 서브쿼리의 조건문에 사용되는 조건 칼럼들을 모두 인덱스에 추가하는 케이스
* 사례 2)
  * 인덱스 칼럼이 많아지면 그만큼 DML이 느려지는 측면이 있지만, 자주 사용되는 쿼리라면 고려해볼 수 있다

<br>

### (5) 버퍼 Pinning 효과 활용
* 오라클은 한번 입력된 테이블 레코드는 절대 rowid가 변경되지 않는다
  * TABLE ACCESS (BY USER ROWID) OF 'EMP' (TABLE)
* rowid 순으로 정렬 후 한 건씩 순차적으로 emp 테이블을 액세스하면 버퍼 Pinning 효과가 나타난다
  * Random 액세스 비효율은 한 건을 읽기 위해 블록을 통째로 읽기 때문에 발생하는 것인데, 버퍼 Pinning 효과가 있으면 한 번 액세스로 블록 안에 있는 모든 레코드를 . 다읽어 들이는 셈이 되기 때문에 인덱스를 통해 아무리 많은 테이블 레코드를 액세스하더라도 비효율이 거의 없어진다

```sql
select /*+ ordered use_nl(b) rowid(b) */ b.*
from   (select /*+ index(emp emp_pk) no_merge */ rowid rid
        from emp
        order by rowid) a, emp b
where   b.rowid = a.rid
```

<br>

### (6) 수동으로 클러스터링 팩터 높이기
* 보통, 테이블에는 데이터가 무작위로 입력되지만, 인덱스는 특정 키 값을 기준으로 정렬되기 때문에 CF가 나쁘다
* 해당 인덱스 기준으로 테이블을 재생성함으로써 CF를 인위적으로 좋게 만들 수 있다
  * 하지만, 특정 인덱스를 기준으로 재생성하면, 타 인덱스들과의 CF는 나빠질 수 있다
  * 따라서, Reorg하는 방법은 관리 포인트가 추가되는 것이기 때문에, 충분히 고려한 이후에 이행해야 한다

<br>

### 차세대 시스템 구축 시 주의사항
* ASIS 대비 TOBE 시스템의 CF가 나빠지는 경우가 많아서 성능이 오히려 나빠질 때가 있다
  * ASIS 시스템은 트랜잭션이 발생하는 순서대로 데이터가 입력한다
  * 하지만, TOBE 시스템으로 데이터를 이관할 때는 병렬쿼리를 많이 사용하기 때문에 데이터가 무작위로 입력될 수 있다

<br>
<hr>
<br>

## IOT, 클러스터 테이블 활용
#### 

<br>

### IOT란?
* 인덱스 구조로 테이블을 생성하는 방법이 IOT (Index-Organized Table)
  * rowid를 일반 인덱스와 달리, IOT는 모든 행 데이터를 리프 블록에 저장한다
  * 즉, IOT에서는 인덱스 리프 블록이 데이터 블록인 셈이다

<div align="center">
  <img width="50%" src="https://github.com/PoSungKim/development_study/assets/37537227/c7987898-3eb2-4357-bd6a-3304f33e2caf">
</div>

* (일반) 힙 구조 테이블
  * Random 방식으로 데이터 삽입
  * Freelist로부터 할당 받은 블록에 정해진 순서 없이 값 입력
```sql
create table heap_org_t ( a number primary key, b varchar(10))
organization heap;
```
* (IOT) 인덱스 구조 테이블
  * 정렬 상태 유지하며 데이터 삽입
```sql
create table index_org_t ( a number primary key, b varchar(10))
organization index;
```

* IOT의 장점과 단점

<br>

### IOT, 언제 사용할 것인가?
* 크기가 작고 NL 조인으로 반복 룩업(Lookup)하는 테이블
* 폭이 좁고 긴(=로우 수가 많은)테이블
* 넓은 범위를 주로 검색하는 테이블
* 데이터 입력과 조회 패턴이 서로 다른 테이블

<br>
<hr>
<br>
