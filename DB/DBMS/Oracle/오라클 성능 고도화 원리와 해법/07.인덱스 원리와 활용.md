# 인덱스 원리와 활용
> 
* 

<hr>
<br>

## 인덱스 구조
#### 

<br>

### 범위 스캔
* 인덱스는 키 칼럼 순으로 정렬돼 있기 때문에 특정 위치에서 스캔을 시작해 검색 조건에 일치하지 않는 값을 만나는 순간 멈출 수 있다
* 테이블은 일반적으로 힙 구조 테이블 (Heap-organized table)이기 때문에 범위 스캔이 있을 수 없다
  * IOT (index-organized table)는 특정 칼럼 순으로 정렬 상태를 유지하기 때문에 범위 스캔 가능

<br>

### 인덱스 기본 구조
* B*tree 인덱스
* LeftMost Child
* 요약
  * 리프 노드상의 인덱스 레코드와 테이블 레코드 간에는 1:1 관계
  * 리프 노드상의 키 값과 테이블 레코드 키 값은 서로 일치
  * 브랜치 노드상의 레코드 개수는 하위 렙레 블록 개수와 일치
  * 브랜치 노드상의 키 값은 하위 노드가 갖는 값의 범위를 의미

<br>

### 인덱스 탐색
* 수평적 탐색 : 범위 스캔 (Range Scan)
* 수직적 탐색 : 수평적 탐색을 위한 시작 지점을 찾는 과정
* 브랜치 블록 스캔
* 결합 인덱스 구조와 탐색
* ROWID 탐색
  * 파티션되지 않은 일반 테이블에 생성한 인덱스, 파티션된 테이블에 생성한 로컬 파티션 (Local Partitioned) 인덱스
    * 6 Byte
  * 파티션 테이블에 생성한 글로벌 파티션 (Global Partitioned) 인덱스, 비파티션 (Non Partitioned) 인덱스
    * 10 Byte
  * 제한 Rowid 포맷 (18자리)
    * 데이터파일 번호 (4자리) : 로우가 속한 데이터파일 번호로서, 데이터베이스 내에서 유일한 값
    * 블록 번호 (8자리) : 해당 로우가 저장된 데이터 블록 번호, (테이블스페이스가 아니라) 데이터파일 내에서의 상대적 번호
    * 로우 번호 (4자리) : 블록 내에서 각 로우에 붙여진 일련번호로서, 0부터 시작
  * 확장 Rowid 포맷 (18자리)
    * 데이터 오브젝트 번호 (6자리) : 데이터베이스 세그먼트를 식별하기 위해 사용되는 데이터 오브젝트 번호
    * 데이터퍄일 번호 (3자리)
    * 블록 번호 (6자리)
    * 로우 번호 (3자리)

<br>
<hr>
<br>

## 인덱스 기본 원리
#### B*Tree 인덱스를 정상적으로 사용하려면 범위 스캔 시작지점을 찾기 위해 루트 블록부터 리프 블록까지의 수직적 탐색 과정 필요
#### 인덱스 선두 칼럼이 조건절에 사용되지 않으면 범위 스캔을 위한 시작점을 찾을 수 없어 옵티마이저는 인덱스 전체를 스캔하거나 테이블 전체를 스캔하는 방식을 선택

<br>

### 인덱스 사용이 불가능하거나 범위 스캔이 불가능한 경우
* Index Range Scan은 불가능하지만, Index Full Scan은 가능한 경우
  ```sql
  select *
  from   업체
  where  substr(업체명, 1 2) = '대한';
  ```
  ```sql
  select *
  from   고객
  where  직업 <> '학생';
  ```
  ```sql
  select *
  from   사원
  where  부서코드 is not null; 
  ```
  * 단일 칼럼 인덱스는 null 값을 저장하지 않고, 결합 인덱스는 구성 칼럼 중 하나라도 null이 아닌 레코드는 인덱스에 포함시키기 때문에 필터링을 통해 is not null 만족 가능 
* Index 사용이 불가능한 경우
  * is null 조건만으로 검색할 때
    * 단일 칼럼 인덱스에는 not null인 레코드들만 있고, 결합 칼럼 인덱스는 모든 칼럼이 null인 레코드는 없어서 완전한 결과집합을 얻을 수 없기 때문
  ```sql
  select *
  from   사원
  where  연락처 is null;
  ```
  * not null인 칼럼은 is null 조건으로 조회하면, 옵티마이저는 Full Table Scan을 피하기 위해서 Index Range Scan을 한다
* not null 조건을 사용하지만 Index Range Scan이 가능한 경우
  * 결합 인덱스가 있고, 선두 칼럼들 중에 not null이외의 조건식이 하나라도 있는 경우
    * 인덱스 구성 칼럼 중 하나라도 null 값이 아닌 레코드는 결합 인덱스에 저장되기 때문
    * 오라클은 null을 가장 끝에 저장
  * 결합 인덱스에 속한 칼럼들 중 하나라도 Not Null Constraint가 있다면 항상 Index Range Scan 가능
  ```sql
  create index emp_idx on emp(job, deptno);
  -- is null 조건 이외의 조건이 있는 경우고, deptno 칼럼이 not null한 칼럼인 경우이기도 해서 Index Range Scan을 타게 된다
  select * from emp where job is null and deptno = 20;
  ```
  
<br>

### 인덱스 칼럼의 가공
* 인덱스 칼럼을 가공하면 정상적인 Index Range Scan이 불가능하기에 가공 사례를 튜닝하는 방법 고려 필요

| 인덱스 칼럼 가공 사례                                                 | 튜닝 방안                                                                                                     |
|-----------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------|
| select *<br>from 업체<br>where substr(업체명,1,2) = '대한'            | select *<br>from 업체<br>where 업체명 like '대한%'                                                            |
| select *<br>from 사원<br>where 월급여 * 12 = 36000000                 | select *<br>from 사원<br>where 월급여 = 36000000/12                                                           |
| select *<br>from 주문<br>where to_char(일시, 'yyyymmdd') = :dt        | select *<br>from 주문<br>where 일시 >= to_date(:dt, 'yyyymmdd')<br>and   일시 < to_date(:dt, 'yyyymmdd')      |
| select *<br>from   고객<br>where  연령 \|\| 직업 = '30공무원'         | select *<br>from   고객<br>where  연령 = 30<br>and    직업 = '공무원'                                         |
| select *<br>from   회원사지점<br>where  회원번호 \|\| 지점번호 = :str | select *<br>from   회원사지점<br>where  회원번호 = substr(:str, 1, 2)<br>and    지점번호 = substr(:str, 3, 4) |
* null이 숫자와 비교되면 0으로 치환된다
  * 0으로 치환되도 결과집합에는 미포함되기 때문에 결과집합은 동일하며, Index에 null 값을 미포함하더라도 어차피 결과집합에 미포함되는 레코드들이기 때문에 Index를 정상적으로 탈 수 있다. 즉, 문제 없다.
  ```sql
  -- 튜닝 전 
  select *
  from   주문
  where  nvl(주문수량, 0) >= 100

  -- 튜닝 후 (어차피 null값은 0으로 치환되기 때문에 이상인 값을 찾을 때는 nvl로 초기화할 필요는 없다
  select *
  from   주문
  where  주문수량 >= 100;
  ```
* 하지만, 미만을 찾는 연산에서는 고려를 더 해줘야 한다
  * null이 0으로 치환되는데 nvl을 사용했다는 점을 보면, 100 이하거나 null이면 결과집합에 포함시키려는 의도가 보이기 때문
  ```sql
  -- 튜닝 전
  select *
  from   주문
  where  nvl(주문수량, 0) < 100;

  -- 만약 주문수량이 not null 칼럼이면,
  -- nvl을 통한 null 고려도 필요없고 null 값 자체가 없기 때문에 index 범위 스캔에도 문제없다
  select *
  from   주문
  where  주문수량 < 100;
  
  -- 만약 주문수량이 null 칼럼이고 null값을 가진 레코드들까지 조회하는 것이 의도혔다면
  -- Table Full Scan이 불가피하다
  -- nvl을 사용하나 하단의 조건절을 사용하나 다 불가피하다
  select *
  from   주문
  where  주문수량 < 100 or 주문수량 is null

  -- 만약 null인 레코드가 너무 많아서 오히려 Table Full Scan이 효율적이면 괜찮지만
  -- 만약 아니라면, 함수 기반 인덱스 FBI (Function-based Index) 생성도 고려 가능
  create index 주문_x01 on 주문 ( nvl(주문수량, 0) );
  ```

* 튜닝 사례 1)
  * 인덱스 칼럼을 가공한 것이 원인이 되어 성능 이슈 발생한 케이스
    * 인덱스 선두 칼럼인 (지수구분코드)와 (지수업종코드)을 가공하여 의도했던 PK Index를 타지 못함
    * (거래일자)만 가지고 있는 index 혹은 table full scan으로 실행계획이 풀리게 되는 상황
```sql
-- 인덱스 구성도
일별지수업종별거래및시세_PK  : (지수구분코드, 지수없종코드, 거래일자)
일별지수업종별거래및시세_X01 : 거래일자
```
```sql
-- 튜닝 전
select 거래일자
       , sum(decode(지수구분코드, '1', 지수종가, 0)) kospi200_idx
       , sum(decode(지수구분코드, '1', 누적거래량, 0)) kospi200_idx_trdvol
       , sum(decode(지수구분코드, '2', 지수종가, 0)) kosdaq_idx
       , sum(decode(지수구분코드, '2', 누적거래량, 0)) kosdaq_idx_trdvol
from     일별지수업종별거래및시세 a
where    거래일자 between :startDd and :endDd
and      지수구분코드 || 지수업종코드 in ('1001', '2003') -- 바로 여기서 인덱스 선두 칼럼 (지수구분코드, 지수업종코드)를 가공함
group by 거래일자
```
```sql
-- 튜닝 후
select 거래일자
       , sum(decode(지수구분코드, '1', 지수종가, 0)) kospi200_idx
       , sum(decode(지수구분코드, '1', 누적거래량, 0)) kospi200_idx_trdvol
       , sum(decode(지수구분코드, '2', 지수종가, 0)) kosdaq_idx
       , sum(decode(지수구분코드, '2', 누적거래량, 0)) kosdaq_idx_trdvol
from     일별지수업종별거래및시세 a
where    거래일자 between :startDd and :endDd
and      (지수구분코드, 지수업종코드) in ( ('1', '001'), ('2', '003') ) -- IN-List 형태로 튜닝
group by 거래일자
```
* 튜닝 사례 2)
  * decode로 인덱스 선두 칼럼인 (정정대상접수번호, 금감원접수번호)를 모두 가공해버리기 때문에, decode문을 논리적으로 동일한 결과를 리턴하도록 리팩토링
```sql
-- 인덱스 구성도
접수정보파일_PK  : 수신번호
접수정보파일_X01 : (정정대상접수번호, 금감원접수번호)
```
```sql
-- 튜닝 전
select *
from   접수정보파일
where  decode( 정정대상접수번호, lpad(' ', 14), 금감원접수번호, 정정대상접수번호 ) = :접수번호 -- 리팩토링 대상
```
```sql
-- 튜닝 후
select *
from   접수정보파일
where  정정대상접수번호 in (:접수번호, lpad(' ', 14))
and    금감원접수번호 = decode( 정정대상접수번호, lpad(' ', 14), :접수번호, 금감원접수번호 ) -- 리택토링 완료
```

<br>

### 묵시적 형변환
* 묵시적 형변환으로 인해 인덱스를 제대로 타지 못하는 부작용이 발생할 수 있다
  * NL Outer 조인 Outer Table이 Driving Table이 되기 때문에, y 테이블의 조인 칼럼을 모두 포함하고 있는 인덱스를 보고, INDEX UNIQUE SCAN으로 실행계획이 풀릴 것이라고 생각했지만, INDEX FULL SCAN으로 실행계획이 풀릴 수 있다
  * 의도하지 않은 형변환으로 인해, 조인 칼럼이 가공되었기 때문인데, 이를 해결하면 의도했던 INDEX UNIQUE SCAN으로 실행계획을 만들 수 있다
    * 문자형에 +- 연산을 가하면 내부적으로 문자형이 숫자형으로 형변환을 해버린다
  * 인덱스 칼럼과 비교되는 반대쪽을 인덱스 칼럼 데이터 타입으로 맞춰줘야 한다
  * DBMS에서 사용자의 편의성을 위해서 묵시적 형변환 기능은 제공하지만, 웬만하면 직접 찝어주는 것이 좋고 사용하지 않는 것이 좋다
    * (문자형, 숫자형) -> (숫자형)
    * (문자형, 날짜형) -> (날짜형)
  ```sql
  월별품목실적_PK : 대상연월 + 영업조직ID + 물품지원품목코드
  월별품목실적_N1 : 대상연월 + 물품지원품목코드 + 영업조직ID
  ```
  ```sql
  select count(*)
  from (
  ) x, 월별품목실적 y
  where y.물품지원품목코드(+) = x.물품지원품목코드
  and   y.영업조직id(+)     = x.물품원신청조직id
  and   y.대상연월(+)       = substr(x.파트너지원요청일자, 1, 6) - 1 -- 문자형에서 숫자형으로 묵시적 형변환 발생하여 부작용이 발생한 조건문
  -- and   to_number(y.대상연월(+)) = to_number(substr(x.파트너지원요청일자, 1, 6)) - 1 문으로 변환된 것과 같다

  -- 따라서, 하단의 조인문으로 튜닝하여, y.대상연월(+) 칼럼이 가공되지 않게 막고 인덱스를 정상적으로 태울 수 있게 된다
  and   y.대상연월(+)       = to_char(add_months(to_date(x.파트너지원요청일자, 'yyyymmdd'), -1), 'yyyymm')
  ```
* 묵시적 형변환 사용시 주의사항
  * 문자형이 숫자형과 만나면 문자형으로 형변환한다
    * 이를 막기 위해서 like 연산 사용 가능
  * decode(a,b,c,d) 연산의 출력값 타입은 c인자 타입을 따라간다
    * null 값은 varchar2 타입으로 판단하기 때문에 문자형이 아닌 숫자형으로 리턴하고자 하면 to_number() 사용 가능
  ```sql
  -- 문자형 --> 숫자형 변환 예시
  where n_col = v_col

  -- 숫자형 --> 문자형 변환 예시
  where n_col like v_col || '%'
  -- where to_char(n_col) like v_col || '%'
  ```
  ```sql
  select round(avg(sal)) avg_sal
        , min(sal) min_sal
        , max(sal) max_sal
        , max(decode(job, 'PRESIDENT', NULL, sal)) max_sal2
  from    scott.emp;

  select round(avg(sal)) avg_sal
        , min(sal) min_sal
        , max(sal) max_sal
        , max(decode(job, 'PRESIDENT', to_number(NULL), sal)) max_sal2
  from    scott.emp;
  ```
* 함수기반 인덱스 (FBI) 활용
  * 시간적으로 여유가 없다면 함수기반 인덱스를 이용해서 급하게 해결할 수는 있지만 권장되지 못하는 방법
  ```sql
  create index emp_x01 on emp(v_deptno);
  select * from emp where v_deptno = 20;
  -- Predicate Information -> filter(to_number("V_DEPTNO")=20)

  drop index emp_x01;
  create index emp_x01 on emp( to_number( v_deptno ) ); -- FBI 생성
  select * from emp where v_deptno = 20;
  -- Predicate Information -> access(to_number("V_DEPTNO")=20)
  ```

<br>
<hr>
<br>

## 다양한 인덱스 스캔 방식
#### 

<br>

### Index Range Scan
```sql
create index emp_deptno_idx on emp(deptno);
select * from emp where deptno = 20;
```
* 인덱스 루트 블록에서 리프 블록까지 수직적으로 탐색한 후에 리프 블록을 필요한 범위만 스캔하는 방식
  * B*Tree 인덱스의 가장 일반적이고 정상적인 형태의 엑세스 방식
* 튜닝 포인트
  * 인덱스를 스캔하는 범위 (Range)를 얼마만큼 줄일 수 있느냐
  * 테이블로 액세스하는 횟수를 얼마만큼 줄일 수 있느냐 
* 사용방법
  * 조건절에 인덱스를 구성하는 선두 칼럼이 조건절에 사용되어야 한다; 없으면, Index Full Scan으로 처리된다
  * 결과집합은 인덱스 칼럼 순으로 정렬되어 sort order by연산을 스킵하거나 min/max 값을 빠르게 추출 가능
 
<br>

### Index Full Scan
```sql
create index emp_dx on emp (ename, sal);
-- 선두 칼럼 (ename)이 조건절에 없다
select * from emp where sal > 2000 order by ename;
```
* 수직적 탐색없이 인덱스 리프 블록을 처음부터 끝까지 수평적으로 탐색하는 방식
  * 검색을 위한 최적의 인덱스가 없을 때 차선으로 선택되는 방식
* Index Full Scan의 효용성
  * 옵티마이저는 인덱스 선두 칼럼(ename)이 조건절에 없으면 Table Full Scan을 가장 우선적으로 고려한다
  * 하지만, 대용량 테이블이어서 Table Full Scan의 부담이 크다면 옵티마이저는 인덱스를 활용하는 방법을 고려한다
  * 테이블의 데이터 저장공간은 `가로 x 세로`, `칼럼길이 x 레코드수`에 의해서 결정되는데, 대개 인덱스가 차지하는 면적은 테이블보다 작다
  * 따라서, 테이블 전체를 스캔하는 것보다 인덱스 스캔 단계에서 대부분을 필터링하고 일부 레코드들만 테이블 액세스가 발생하도록 하면 I/O를 효율적으로 발생시킬 수 있고, 이때 옵티마이저는 Index Full Scan을 선택한다
  ```sql
  -- emp 테이블에서 연봉이 5000을 초과하는 사원이 전체에서 극히 일부라서 Table Full Scan이 아니라 Index Full Scan 하면서 조건절에 맞는 레코드들만 테이블 액세스한다
  select * from emp where sal > 5000 order by ename;
  ``` 
* 인덱스를 이용한 소트 연산 대체
  * Index Full Scan도 결과집합이 인덱스 칼럼 순으로 정렬이 되어 있어서 Sort Order By 연산을 생략할 수 있다
    * 전체를 모두 Fetch하면 Table Full Scan이 효율적이지만, /*+ first_rows */로 Sort 연산을 생략함으로써 전체 집합 중 일부만을 빠르게 리턴할 목적으로 옵티마이저가 Index Full Scan을 사용
  ```sql
  -- 대부분의 직원들의 연봉이 1000을 넘기 때문에, 힌트가 없었으면 Table Full Scan이 더 효율적
  select /*+ first_rows */ * from emp
  where  sal > 1000
  order by ename;
  ```

<br>

### Index Unique Scan
* 수직적 탐색만으로 데이터를 찾는 스캔 방식
  * Unique 인덱스를 통해 `=` 조건으로 탐색하는 경우에 작동한다
```sql
create unique index pk_emp on emp(empno);
alter table emp add constraint pk_emp primary key(empno) using index pk_emp;

select empno, ename from emp where empno = 7788;
```
* Unique 인덱스에서도 범위검색 조건 (between, 부등호, like) 사용하면 Index Range Scan 가능

<br>

### Index Skip Scan
* 인덱스 선두 칼럼이 조건절로 사용되지 않으면 옵티마이저는 기본적으로 Table Full Scan을 선택하고, 만약 I/O를 줄이거나 정렬연산을 줄일 수 있다면 Index Full Scan을 선택한다
* 하지만, 오라클은 인덱스 선두 칼럼이 조건절에 없어도 인덱스를 활용하는 Index Skip Scan 방식 사용
  * 인덱스 선두 칼럼의 Distinct Value 개수가 적고 후행 칼럼의 Distinct Value 개수가 많을 때 유용
* Index Skip Scan은 루트 또는 브랜치 블록에서 읽은 칼럼 값 정보를 이용해 조건에 부합하는 레코드를 포함할 "가능성이 있는" 리프 블록만 골라서 액세스하는 방식
* 버퍼 Pinning을 이용한 Skip 원리
* Index Skip Scan이 작동하기 위한 조건
* In-List Iterator와의 비교

<br>

### Index Fast Full Scan
* Index Fast Full Scan의 특징
* Index Fast Full Scan을 활용한 튜닝 사례

<br>

### Index Range Scan Descending

<br>

### And-Equi, Index Combine, Index Join
* And-Equi
* Index Combine
* Index Join

<br>
<hr>
<br>

