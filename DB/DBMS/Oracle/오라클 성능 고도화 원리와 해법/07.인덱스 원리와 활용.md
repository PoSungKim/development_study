# 인덱스 원리와 활용
> ㅇ
* ㅇ

<hr>
<br>

## 인덱스 구조
#### 

<br>

### 범위 스캔
* 인덱스는 키 칼럼 순으로 정렬돼 있기 때문에 특정 위치에서 스캔을 시작해 검색 조건에 일치하지 않는 값을 만나는 순간 멈출 수 있다
* 테이블은 일반적으로 힙 구조 테이블 (Heap-organized table)이기 때문에 범위 스캔이 있을 수 없다
  * IOT (index-organized table)는 특정 칼럼 순으로 정렬 상태를 유지하기 때문에 범위 스캔 가능

<br>

### 인덱스 기본 구조
* B*tree 인덱스
* LeftMost Child
* 요약
  * 리프 노드상의 인덱스 레코드와 테이블 레코드 간에는 1:1 관계
  * 리프 노드상의 키 값과 테이블 레코드 키 값은 서로 일치
  * 브랜치 노드상의 레코드 개수는 하위 렙레 블록 개수와 일치
  * 브랜치 노드상의 키 값은 하위 노드가 갖는 값의 범위를 의미

<br>

### 인덱스 탐색
* 수평적 탐색 : 범위 스캔 (Range Scan)
* 수직적 탐색 : 수평적 탐색을 위한 시작 지점을 찾는 과정
* 브랜치 블록 스캔
* 결합 인덱스 구조와 탐색
* ROWID 탐색
  * 파티션되지 않은 일반 테이블에 생성한 인덱스, 파티션된 테이블에 생성한 로컬 파티션 (Local Partitioned) 인덱스
    * 6 Byte
  * 파티션 테이블에 생성한 글로벌 파티션 (Global Partitioned) 인덱스, 비파티션 (Non Partitioned) 인덱스
    * 10 Byte
  * 제한 Rowid 포맷 (18자리)
    * 데이터파일 번호 (4자리) : 로우가 속한 데이터파일 번호로서, 데이터베이스 내에서 유일한 값
    * 블록 번호 (8자리) : 해당 로우가 저장된 데이터 블록 번호, (테이블스페이스가 아니라) 데이터파일 내에서의 상대적 번호
    * 로우 번호 (4자리) : 블록 내에서 각 로우에 붙여진 일련번호로서, 0부터 시작
  * 확장 Rowid 포맷 (18자리)
    * 데이터 오브젝트 번호 (6자리) : 데이터베이스 세그먼트를 식별하기 위해 사용되는 데이터 오브젝트 번호
    * 데이터퍄일 번호 (3자리)
    * 블록 번호 (6자리)
    * 로우 번호 (3자리)

<br>
<hr>
<br>

## 인덱스 기본 원리
#### B*Tree 인덱스를 정상적으로 사용하려면 범위 스캔 시작지점을 찾기 위해 루트 블록부터 리프 블록까지의 수직적 탐색 과정 필요
#### 인덱스 선두 칼럼이 조건절에 사용되지 않으면 범위 스캔을 위한 시작점을 찾을 수 없어 옵티마이저는 인덱스 전체를 스캔하거나 테이블 전체를 스캔하는 방식을 선택

<br>

### 인덱스 사용이 불가능하거나 범위 스캔이 불가능한 경우
* Index Range Scan은 불가능하지만, Index Full Scan은 가능한 경우
  ```sql
  select *
  from   업체
  where  substr(업체명, 1 2) = '대한';
  ```
  ```sql
  select *
  from   고객
  where  직업 <> '학생';
  ```
  ```sql
  select *
  from   사원
  where  부서코드 is not null; 
  ```
  * 단일 칼럼 인덱스는 null 값을 저장하지 않고, 결합 인덱스는 구성 칼럼 중 하나라도 null이 아닌 레코드는 인덱스에 포함시키기 때문에 필터링을 통해 is not null 만족 가능 
* Index 사용이 불가능한 경우
  * is null 조건만으로 검색할 때
    * 단일 칼럼 인덱스에는 not null인 레코드들만 있고, 결합 칼럼 인덱스는 모든 칼럼이 null인 레코드는 없어서 완전한 결과집합을 얻을 수 없기 때문
  ```sql
  select *
  from   사원
  where  연락처 is null;
  ```
  * not null인 칼럼은 is null 조건으로 조회하면, 옵티마이저는 Full Table Scan을 피하기 위해서 Index Range Scan을 한다
* not null 조건을 사용하지만 Index Range Scan이 가능한 경우
  * 결합 인덱스가 있고, 선두 칼럼들 중에 not null이외의 조건식이 하나라도 있는 경우
    * 인덱스 구성 칼럼 중 하나라도 null 값이 아닌 레코드는 결합 인덱스에 저장되기 때문
    * 오라클은 null을 가장 끝에 저장
  * 결합 인덱스에 속한 칼럼들 중 하나라도 Not Null Constraint가 있다면 항상 Index Range Scan 가능
  ```sql
  create index emp_idx on emp(job, deptno);
  -- is null 조건 이외의 조건이 있는 경우고, deptno 칼럼이 not null한 칼럼인 경우이기도 해서 Index Range Scan을 타게 된다
  select * from emp where job is null and deptno = 20;
  ```
  
<br>

### 인덱스 칼럼의 가공
* 인덱스 칼럼을 가공하면 정상적인 Index Range Scan이 불가능하기에 가공 사례를 튜닝하는 방법 고려 필요

| 인덱스 칼럼 가공 사례                                                 | 튜닝 방안                                                                                                     |
|-----------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------|
| select *<br>from 업체<br>where substr(업체명,1,2) = '대한'            | select *<br>from 업체<br>where 업체명 like '대한%'                                                            |
| select *<br>from 사원<br>where 월급여 * 12 = 36000000                 | select *<br>from 사원<br>where 월급여 = 36000000/12                                                           |
| select *<br>from 주문<br>where to_char(일시, 'yyyymmdd') = :dt        | select *<br>from 주문<br>where 일시 >= to_date(:dt, 'yyyymmdd')<br>and   일시 < to_date(:dt, 'yyyymmdd')      |
| select *<br>from   고객<br>where  연령 \|\| 직업 = '30공무원'         | select *<br>from   고객<br>where  연령 = 30<br>and    직업 = '공무원'                                         |
| select *<br>from   회원사지점<br>where  회원번호 \|\| 지점번호 = :str | select *<br>from   회원사지점<br>where  회원번호 = substr(:str, 1, 2)<br>and    지점번호 = substr(:str, 3, 4) |
* null이 숫자와 비교되면 0으로 치환된다
  * 0으로 치환되도 결과집합에는 미포함되기 때문에 결과집합은 동일하며, Index에 null 값을 미포함하더라도 어차피 결과집합에 미포함되는 레코드들이기 때문에 Index를 정상적으로 탈 수 있다. 즉, 문제 없다.
  ```sql
  -- 튜닝 전 
  select *
  from   주문
  where  nvl(주문수량, 0) >= 100'

  -- 튜닝 후 (어차피 null값은 0으로 치환되기 때문에 이상인 값을 찾을 때는 nvl로 초기화할 필요는 없다
  select *
  from   주문
  where  주문수량 >= 100;
  ```
* 하지만, 미만을 찾는 연산에서는 고려를 더 해줘야 한다
  * null이 0으로 치환되는데 nvl을 사용했다는 점을 보면, 100 이하거나 null이면 결과집합에 포함시키려는 의도가 보이기 때문
  ```sql
  -- 튜닝 전
  select *
  from   주문
  where  nvl(주문수량, 0) < 100;

  -- 만약 주문수량이 not null 칼럼이면,
  -- nvl을 통한 null 고려도 필요없고 null 값 자체가 없기 때문에 index 범위 스캔에도 문제없다
  select *
  from   주문
  where  주문수량 < 100;
  
  -- 만약 주문수량이 null 칼럼이고 null값을 가진 레코드들까지 조회하는 것이 의도혔다면
  -- Table Full Scan이 불가피하다
  -- nvl을 사용하나 하단의 조건절을 사용하나 다 불가피하다
  select *
  from   주문
  where  주문수량 < 100 or 주문수량 is null

  -- 만약 null인 레코드가 너무 많아서 오히려 Table Full Scan이 효율적이면 괜찮지만
  -- 만약 아니라면, 함수 기반 인덱스 FBI (Function-based Index) 생성도 고려 가능
  create index 주문_x01 on 주문 ( nvl(주문수량, 0) );
  ```

* 튜닝 사례 1)
  * 인덱스 칼럼을 가공한 것이 원인이 되어 성능 이슈 발생한 케이스
    * 인덱스 선두 칼럼인 (지수구분코드)와 (지수업종코드)을 가공하여 의도했던 PK Index를 타지 못함
    * (거래일자)만 가지고 있는 index 혹은 table full scan으로 실행계획이 풀리게 되는 상황
```sql
-- 인덱스 구성도
일별지수업종별거래및시세_PK  : (지수구분코드, 지수없종코드, 거래일자)
일별지수업종별거래및시세_X01 : 거래일자
```
```sql
-- 튜닝 전
select 거래일자
       , sum(decode(지수구분코드, '1', 지수종가, 0)) kospi200_idx
       , sum(decode(지수구분코드, '1', 누적거래량, 0)) kospi200_idx_trdvol
       , sum(decode(지수구분코드, '2', 지수종가, 0)) kosdaq_idx
       , sum(decode(지수구분코드, '2', 누적거래량, 0)) kosdaq_idx_trdvol
from     일별지수업종별거래및시세 a
where    거래일자 between :startDd and :endDd
and      지수구분코드 || 지수업종코드 in ('1001', '2003') -- 바로 여기서 인덱스 선두 칼럼 (지수구분코드, 지수업종코드)를 가공함
group by 거래일자
```
```sql
-- 튜닝 후
select 거래일자
       , sum(decode(지수구분코드, '1', 지수종가, 0)) kospi200_idx
       , sum(decode(지수구분코드, '1', 누적거래량, 0)) kospi200_idx_trdvol
       , sum(decode(지수구분코드, '2', 지수종가, 0)) kosdaq_idx
       , sum(decode(지수구분코드, '2', 누적거래량, 0)) kosdaq_idx_trdvol
from     일별지수업종별거래및시세 a
where    거래일자 between :startDd and :endDd
and      (지수구분코드, 지수업종코드) in ( ('1', '001'), ('2', '003') ) -- IN-List 형태로 튜닝
group by 거래일자
```
* 튜닝 사례 2)
  * decode로 인덱스 선두 칼럼인 (정정대상접수번호, 금감원접수번호)를 모두 가공해버리기 때문에, decode문을 논리적으로 동일한 결과를 리턴하도록 리팩토링
```sql
-- 인덱스 구성도
접수정보파일_PK  : 수신번호
접수정보파일_X01 : (정정대상접수번호, 금감원접수번호)
```
```sql
-- 튜닝 전
select *
from   접수정보파일
where  decode( 정정대상접수번호, lpad(' ', 14), 금감원접수번호, 정정대상접수번호 ) = :접수번호 -- 리팩토링 대상
```
```sql
-- 튜닝 후
select *
from   접수정보파일
where  정정대상접수번호 in (:접수번호, lpad(' ', 14))
and    금감원접수번호 = decode( 정정대상접수번호, lpad(' ', 14), :접수번호, 금감원접수번호 ) -- 리택토링 완료
```

<br>

### 묵시적 형변환
* 묵시적 형변환 사용시 주의사항
* 함수기반 인덱스 (FBI) 활용

<br>
<hr>
<br>

## 다양한 인덱스 스캔 방식
#### 

<br>

### Index Range Scan

<br>

### Index Full Scan
* Index Full Scan의 효용성
* 인덱스를 이용한 소트 연산 대체

<br>

### Index Unique Scan

<br>

### Index Skip Scan
* 버퍼 Pinning을 이용한 Skip 원리
* Index Skip Scan이 작동하기 위한 조건
* In-List Iterator와의 비교

<br>

### Index Fast Full Scan
* Index Fast Full Scan의 특징
* Index Fast Full Scan을 활용한 튜닝 사례

<br>

### Index Range Scan Descending

<br>

### And-Equi, Index Combine, Index Join
* And-Equi
* Index Combine
* Index Join

<br>
<hr>
<br>

