# 소트 튜닝
> SQL 튜닝에서 빠질 수 없는 요소가 소트 튜닝
* 소트 오퍼레이션은 수행과정에서 CPU와 메모리를 많이 사용하고, 데이터량이 많을 때는 디스크 I/O까지 발생한다
* OLTP 환경에서 애플리케이션 성능을 저하시키는 주요인으로 작용하기도 한다

<hr>
<br>

## 소트 수행 원리
#### 

<br>

### 소트 수행 과정
* SQL 수행 도중 데이터 정렬이 필요할 때면 오라클은 PGA 메모리에 Sort Area를 할당하는데, 그 안에서의 처리 완료 가능 여부에 따라 2가지 유형으로 나뉜다
  * 메모리 소트 (Memory Sort)
    * 전체 데이터의 정렬 작업을 메모리 내에서 완료하는 경우이며, Internal Sort로 불리기도 한다
  * 디스크 소트 (Disk Sort)
    * 할당받은 Sort Area 내에서 정렬을 완료하지 못해 디스크 공간까지 사용하는 경우이며, External Sort로 불리기도 한다

<div align="center">
  <img width="80%"  src="https://github.com/PoSungKim/development_study/assets/37537227/be8ac102-750d-48e5-83e5-c833158d423a" />
</div>

* Optimal 소트 : 소트 오퍼레이션이 메모리 내에서만 이루어짐
  * Sort Area 내에서 데이터 정렬을 마무리하는 경우 (최적)
* Onepass 소트 : 정렬 대상 집합이 디스크에 한 번만 쓰임
  * Sort Area가 각 Sort Run으로부터 하나의 청크(Chunk)씩 읽어 들일 정도의 크기라서 추가적인 디스크 I/O가 발생하는 경우
* Multipass 소트 : 정렬 대상 집합이 디스크에 여러 번 쓰임
  * Sort Run으로부터 읽은 데이터를 다시 디스크에 썼다가 읽어 들이는 과정을 여러 번 반복하는 경우

<br>

### 소트 오퍼레이션 측정
* 환경설정
  ```sql
  create table t_emp
  as
  select *
  from emp, (select rownum no from dual connect by level <= 100000);
  
  alter session set workarea_size_policy = manual;
  
  alter session set sort_area_size = 1048576;
  ```
* 소트 쿼리수행
  ```sql
  set autotrace on
  select *
  from   (
      select no, empno, ename, job, mgr, sal
           , avg(sal) over (partition by to_char(no), deptno) avg_sal
      from   t_emp
  )
  where no = 1
  order by sal desc;
  ```
* autotrace
  ```
  Id     Operation                             Name
  ----   -----------------------------------   --------------
  0      SELECT STATEMENT
  1        SORT ORDER BY
  2          VIEW                              
  3            WINDOW SORT                     
  4              TABLE ACCESS FULL             T_EMP
  
  Predicate Information (identified by operation id):
  -----------------------------------------------------
  2 - filter ("NO"=1)
  
  Statistics
  -----------------------------------------------------
    241   recursive calls
     90   db block gets
   9293   consistent gets
  33003   physical reads
      0   redo size
   1275   bytes sent via SQL*Net to client
    385   bytes received via SQL*Net from client
      2   SQL*Net roundtrips to/from client
      1   sorts (memory)
      1   sorts (disk)
     14   rows processed
  ```
* 분석
  * sorts (memory)
    * ID (1) - SORT ORDER BY
    * `no = 1` 조건으로 한 번 필터링된 결과집합만 정렬하기 때문
  * sorts (disk)
    * ID (3) - WINDOW SORT
    * window 함수의 대상이 t_emp 테이블 전체이기 때문
  * physical reads (33003) > consistent gets (9293) + db block gets (90)
    * 디스크 I/O시 버퍼캐시를 항상 경유하기 때문에 일반적으로 디스크 블록 I/O I/O 개수가 메모리 블록 I/O 개수를 초과할 수 없다
    * 이번에는 physical reads 값이 훨씬 큰 이유는 디스트 소트 과정에서 발생한 디스크 I/O도 포함됐기 때문
* SQL 트레이스
  ```
  call       count  cpu    elapsed  disk   query  current  rows
  --------   -----  -----  -------  -----  -----  -------  -----
  Parse          1   0.00     0.00      0      0        0      0
  Execute        1   0.00     0.00      0      0        0      0
  Fetch          2  10.73    28.92  23785   9204       90     14
  --------   -----  -----  -------  -----  -----  -------  -----
  total          4  10.73    28.92  23785   9204       90     14

  Rows     Row Source Operation                  
  ------   -------------------------------------
       14  SORT ORDER BY (cr=9204 pr=23785 pw=23784 time=28923191 us)
       14    VIEW (cr=9204 pr=23785 pw=23784 time=17573914 us)
  1400000      WINDOW SORT (cr=9204 pr=23785 pw=23784 time=39973641 us)
  1400000        TABLE ACCESS FULL T_EMP (cr=9204 pr=0 pw=0 time=5600071 us)

  Elapsed times include waiting on following events:
  Event waited on                             Times  Max. Wait  Total Waited
  -----------------------------------------  Waited  ---------  ------------
  SQL*Net message to client                       2       0.00          0.00
  direct path write temp                       6217       0.17          2.76
  direct path read temp                       20264       0.23         15.65
  SQL*Net message from client                     2       0.10          0.10
  ```
  * 쿼리수행을 2~3번 수행하면, TABLE ACCESS FULL T_EMP 연산에서 더 이상 디스크 읽기가 전혀 발생하지 않게 된다
    * 이에 따라, Call 통계에 나타난 23,785번의 디스크 읽기는 전량 소트 과정에서 발생한 것이다
    * 이 뜻은 `WINDOW SORT (cr=9204 pr=23785 pw=23784 time=39973641 us)`부분에서 `pr=23785`를 읽어서 `pw=23784` 블록 모두 Temp 세그먼트에 저장한 것이다
* 뷰
  * 소트 작업 및 관련 수행 통계 확인 가능
  * v$sysstat, v$sesstat, v$mystat, v$sort_segment, v$sort_usage, v$temp_extent_pool

<br>

### Sort Area
* 데이터 정렬을 위해 사용되는 Sort Area는 소트 오퍼레이션이 진행되는 동안 공간이 부족해질 때마다 청크 (Chunk) 단위 (db_block_size 파라미터로 결정)로 조금씩 할당된다
  * workarea_size_policy 파라미터를 auto로 설정하면 오라클이 내부적으로 결정한다
* SORT_AREA_RETAINED_SIZE
  * 데이터 정렬을 끝내고 나서 결과집합을 모두 Fetch할 때까지 유지할 Sort Area 크기를 지정한다
  * 이 크기를 초과한 데이터는 Temp 세그먼트에 저장했다가 Fetch 과정에서 다시 읽어들인다

<div align="center">
  <img width="80%"  src="https://github.com/PoSungKim/development_study/assets/37537227/1a106edb-5078-4aac-90ce-13ccca0bd222" />
</div>

* PGA (Process/Program/Private Global Area)
  * 각 오라클 서버 프로세스는 메모리 영역을 할당받고, 이를 프로세스에 종속적인 고유 데이터를 저장하는 용도로 사용한다
  * PGA는 다른 프로세스와 공유되지 않는 독립적인 메모리 공간으로서, 래치 메커니즘이 필요 없어 똑같은 개수의 불록을 읽더라도 SGA 버퍼 캐시에서 읽는 것보다 훨씬 빠르다
* UGA (User Global Area)
  * 각 세션을 위한 독립적인 메모리 공간이 필요해지고, 이를 UGA라고 부른다
    * 전용 서버 (Dedicated Server) 방식
      * 프로세스:세션 = 1:1 관계
      * UGA 할당 공간 = PGA
    * 공유 서버 (Shared Server 또는 MTS) 방식
      * 프로세스:세션 = 1:M 관계
      * UGA 할당 공간 = SGA (Large Pool 혹은 Shared Pool)
* 주요사항
  * 하나의 프로세스에는 하나의 PGA를 갖는다
  * 하나의 세션은 하나의 UGA를 갖는다
  * PGA에는 세션과 독립적인 프로세스만의 정보를 관리한다
  * UGA에는 프로세스와 독립적인 세션만의 정보를 관리한다
  * 거의 대부분 전용 서버 방식을 사용하므로 세션과 프로세스는 1:1 관계이다
    * 따라서 UGA도 PGA내에 할당된다고 이해하면 쉽다
* CGA (Call Global Area)
  * PGA에 할당되는 메모리 공간으로 CGA도 있다
    * CGA : Call이 진행되는 동안만 필요한 정보 저장
    * UGA : Call을 넘어서 다음 Call까지 계속 참조되는 정보 저장
  * Parse Call, Execute Call, Fetch Call마다 매번 할당받는다
    * 만약 Recurisve Call이 발생하면, 그 안에서도 Parse, Execute, Fetch 단계별로 CGA가 추가로 할당된다
    * CGA에 할당된 공간은 하나의 Call이 끝나자마자 해제돼 PGA로 반환된다
* Sort Area 할당 위치
  * Sort Area가 할당되는 위치는 SQL문 종류와 소트 수행 단계에 따라 다르다
  * DML 문장
    * DML 문장은 하나의 Execute Call 내에서 모든 데이터 처리르 완료하며, Execute Call이 끝나는 순간 자동으로 커서가 닫힌다
      * 따라서 DML 수행 도중 정렬한 데이터를 Call을 넘어서까지 참조할 필요가 없으므로 Sort Area를 CGA에 할당한다
  * SELECT 문장
    * SELECT 문장이 수행되는 가장 마지막 단게에서 정렬된 데이터는 계속 이어지는 Fetch Call에서 사용되어야 한다
      * 따라서 그 마지막 소트를 위한 Sort Area는 UGA에 할당한다
    * 반면, 마지막보다 앞선 단계에서 정렬된 데이터는 첫 번째 Fetch Call 내에서만 사용되므로 Sort Area를 CGA에 할당한다
      * 처음 데이터를 Fetch하기 전 단계에서의 데이터 가공 (group by, order by 등)은 Execute Call 내에서 처리될 것이라는 믿음과 달리, 실제로는 첫 번째 Fetch Call에서 이루어진다

```sql
select /*+ ordered use_merge(e) */
        d.deptno, d.dname, e.ename, e.sal, e.job
      , rank() over (partition by d.deptno order by e.sal) sal_rank
from   dept d, emp e
where  d.deptno = e.deptno
order by e.sal desc;
```

```
Id     Operation                             Name             CGA or UGA?
----   -----------------------------------   --------------   -----------
0      SELECT STATEMENT
1        SORT ORDER BY                                        UGA
2          WINDOW SORT                                        CGA
3            MERGE JOIN                     
4              SORT JOIN                                      CGA                     
5                TABLE ACCESS FULL            DEPT
6              SORT JOIN                                      CGA 
7                TABLE ACCESS FULL            EMP
```

* 정리 요약
  * DML 문장 수행 시 발생하는 소트는 CGA에서 수행
  * SELECT 문장 수행 시
    * 쿼리 중간 단계의 소트
      * CGA에서 수행
    * 결과집합을 출력하기 직전 단계에서 수행하는 소트
      * sort_area_retained_size 제약이 있다면, CGA에서 소트 수행
        * 이 제약만큼의 UGA를 할당해 정렬된 결과를 담았다가 이후 Fetch Call에서 Array 단위로 전송
      * sort_area_retained_size 제약이 없다면, 바로 UGA에서 소트 수행
  * Sort Area
    * CGA 할당 : 하나의 Call이 끝나자마자 PGA에 반환된다
    * UGA 할당 : 마지막 Row가 Fetch될 때 비로소 UGA Heap에 반환되고, 거의 대부분 그 부모 Heap에도 즉각 반환된다
      * 부모 Heap
        * 전용서버 : PGA
        * 공유서버 : SGA
   
<br>
<hr>
<br>

