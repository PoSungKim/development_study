# 오라클 아키텍처
> 소프트웨어 세계에서 가장 중요한 화두인 재사용성은 데이터베이스 성능 튜닝의 핵심 원리
*

<hr>
<br>

## 기본 아키텍처
#### DB + Instance ( Memory + Processes )

<div align="center" >
  <img width="50%" src="https://github.com/PoSungKim/development_study/assets/37537227/97da7754-37f6-4eb4-b8be-67b803535e56" >
</div>

<br>

### Instance ( Server Processes + Memory + Background Processes )

<div align="center" >
  <img width="50%" src="https://github.com/PoSungKim/development_study/assets/37537227/f19d2116-b875-4d0c-b0f7-12a50a7bafef" >
</div>

* SGA (Shared Global Area)
  * 서버 프로세스와 백그라운드 프로세스 모두 접속 엑세스 가능한 데이터 및 제어 구조 메모리 공간
* PGA (Process Global Area)
  * 서버 프로세스만을 위한 독립적인 메모리 공간
* 서버 프로세스
  * 오라클에 접속하면 각 클라이언트 전용 서버 프로세스가 뜬다
  * SQL 파싱 + 최적화 + 결과집합 + 네트워크 전송 등의 업무를 직접 수행
  * 자신이 하지 못하는 일은 OS, I/O 서브시스템, 백그라운드 프로세스 등에 신호를 보내 업무를 위임한다

<br>

### Connection Pool

<div align="center" >
  <img width="50%" src="https://github.com/PoSungKim/development_study/assets/37537227/2f69cdbe-8793-49b8-89e1-bb5d96bacccf" >
  <img width="30%" src="https://github.com/PoSungKim/development_study/assets/37537227/ce014635-fce1-4189-af6a-dbc51a88b33c" >
</div>

* 클라이언트에서 오라클에 접속 요청을 하면, Listener가 요청을 받아서 하나의 프로세스를 fork하고 PGA 메모리를 할당한다
* 한번 Connection을 맺으면 작업을 완료하더라도 이를 해제하지 않고 애플리케이션 서버에 Pooling하고 있다가 반복 재사용

<br>

### RAC (Real Application Cluster)
* 기본 구성
  * 1 x DB + 1 x Instance
* RAC 구성
  * 1 x DB + n x Instance
* RAC 장점
  * 각 인스턴스를 전용 네트워크로 연결
    * Shared Disk (공유 디스크)뿐만 아닌, Shared Cache (공유 캐시)
    * Local Cache (로컬 캐시)뿐만 아닌, Global Cache (글로벌 캐시)
  * 다른 인스턴스의 Dirty 버퍼 내의 데이터도 네트워크를 통해 서로 주고받으며 갱신 수행
    * 원래는 타 노드의 Dirty 버퍼 내용은 디스크로 쓰기 작업을 한 이후에 해당 디스크에서 다른 노드가 읽어야 하는 동기화 과정이 필요했음 (PING 과정)
* SQL 튜닝 툴
  * SQL 트레이스

<br>
<hr>
<br>

## DB 버퍼 캐시
#### 

<br>

### 
* 버퍼 버킷
* 버퍼 체인
* 버퍼 블록
  * Free Block
  * Dirty Block
  * Pin Block

<br>
<hr>
<br>
