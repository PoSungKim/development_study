# 오라클 아키텍처
> 소프트웨어 세계에서 가장 중요한 화두인 재사용성은 데이터베이스 성능 튜닝의 핵심 원리
*

<hr>
<br>

## 기본 아키텍처
#### DB + Instance ( Memory + Processes )

<div align="center" >
  <img width="50%" src="https://github.com/PoSungKim/development_study/assets/37537227/97da7754-37f6-4eb4-b8be-67b803535e56" >
</div>

<br>

### Instance ( Server Processes + Memory + Background Processes )

<div align="center" >
  <img width="50%" src="https://github.com/PoSungKim/development_study/assets/37537227/f19d2116-b875-4d0c-b0f7-12a50a7bafef" >
</div>

* SGA (Shared Global Area)
  * 서버 프로세스와 백그라운드 프로세스 모두 접속 엑세스 가능한 데이터 및 제어 구조 메모리 공간
* PGA (Process Global Area)
  * 서버 프로세스만을 위한 독립적인 메모리 공간
* 서버 프로세스
  * 오라클에 접속하면 각 클라이언트 전용 서버 프로세스가 뜬다
  * SQL 파싱 + 최적화 + 결과집합 + 네트워크 전송 등의 업무를 직접 수행
  * 자신이 하지 못하는 일은 OS, I/O 서브시스템, 백그라운드 프로세스 등에 신호를 보내 업무를 위임한다

<br>

### Connection Pool

<div align="center" >
  <img width="50%" src="https://github.com/PoSungKim/development_study/assets/37537227/2f69cdbe-8793-49b8-89e1-bb5d96bacccf" >
  <img width="30%" src="https://github.com/PoSungKim/development_study/assets/37537227/ce014635-fce1-4189-af6a-dbc51a88b33c" >
</div>

* 클라이언트에서 오라클에 접속 요청을 하면, Listener가 요청을 받아서 하나의 프로세스를 fork하고 PGA 메모리를 할당한다
* 한번 Connection을 맺으면 작업을 완료하더라도 이를 해제하지 않고 애플리케이션 서버에 Pooling하고 있다가 반복 재사용

<br>

### RAC (Real Application Cluster)
* 기본 구성
  * 1 x DB + 1 x Instance
* RAC 구성
  * 1 x DB + n x Instance
* RAC 장점
  * 각 인스턴스를 전용 네트워크로 연결
    * Shared Disk (공유 디스크)뿐만 아닌, Shared Cache (공유 캐시)
    * Local Cache (로컬 캐시)뿐만 아닌, Global Cache (글로벌 캐시)
  * 다른 인스턴스의 Dirty 버퍼 내의 데이터도 네트워크를 통해 서로 주고받으며 갱신 수행
    * 원래는 타 노드의 Dirty 버퍼 내용은 디스크로 쓰기 작업을 한 이후에 해당 디스크에서 다른 노드가 읽어야 하는 동기화 과정이 필요했음 (PING 과정)
* SQL 튜닝 툴
  * SQL 트레이스

<br>
<hr>
<br>

## DB 버퍼 캐시 (DB Buffer Cache)
#### 빠른 입출력을 위해 사용하는 SGA 공유 메모리 구성 요소 

<br>

### 블록 단위 I/O
* 인덱스를 통한 테이블 엑세스
  * Single Block Read
* Full Scan을 통한 테이블 엑세스
  * Multiblock Read

<br>

<div align="center">
  <img width="50%" src= "https://github.com/PoSungKim/development_study/assets/37537227/9bb98852-e68f-49a6-aea4-a06eda8d7891" />
</div>

<br>

### 버퍼 캐시 구조
* 버퍼 버킷
  * 해시 테이블, 해시 맵
  * Key
    * 데이터 블록 주소 (DBA, Data Block Address)
  * Value
    * 버퍼 체인
* 버퍼 체인
  * 연결리스트 (Linked List)
* 버퍼 헤더
  * 포인터 (Pointer) to 데이터 블록

<br>

### 캐시 버퍼 체인
* DB 버퍼 캐시는 공유 메모리 영역인 SGA 내에 구성되어 있기 때문에 여러 프로세스가 동시에 접근 가능
  * 따라서, 리소스 엑세스를 반드시 직렬화 (Serialization)해야 함
  * 직렬화 구현을 위해 래치 (Latch)라는 Lock 매커니즘 사용
  * 래치를 획득한 프로세스만 해당 래치가 보호하는 자료구조로 진입 가능
* 캐시 버퍼 체인 래치 (Cache Buffer Chain Latch)
  * 해시 체인 스캔
    * Share 모드
  * 블록 추가 및 제거
    * Exclusive 모드
* 해시 버퍼 : 해시 체인
  * 1 : 1

<br>

<div align="center">
  <img width="50%" src= "https://github.com/PoSungKim/development_study/assets/37537227/a0ca4f43-842f-4d3e-bf70-9a93ed44154e" />
</div>

### 캐시 버퍼 LRU 체인
* DB 버퍼 캐시는 데이터 버퍼를 캐싱해두는 메모리 공간인데, 메모리 용량은 제한적
  따라서, * Free 블록이 필요할 때, 사용빈도가 가장 낮은 블록을 먼저 Free한다
* LRU 리스트
  * Dirty 리스트
    * 캐시 내에서 변경됐지만, 아직 디스크에 기록되지 못한 Dirty 버퍼 블록
  * LRU 리스트
    * 아직 Dirty 리스트로 옮겨지지 않은 나머지 버퍼 블록
* 캐시 버퍼 LRU 체인 래치 (Cache Buffers LRU Chain Latch)
* 버퍼 상태
  * Free 버퍼
    * Clean 버퍼
    * 데이터 파일과 동기화된 버퍼
  * Dirty 버퍼
    * 버퍼에 캐시되었지만, 아직 디스크에 기록되지 않아서, 데이터 파일 블록과 동기화가 필요한 버퍼 블록
  * Pinned 버퍼
    * 읽기 혹은 쓰기 작업을 위해 현재 엑세스되고 있는 버퍼 블록

<br>
<hr>
<br>

## 버퍼 Lock
#### 

<br>

### 버퍼 Lock이란? 
* 버퍼 버킷 > 버퍼 체인 > 래치 획득 > 버퍼 헤더 > 버퍼 Lock 획득 > 래치 해제 순으로 직렬화를 진행하여 데이터 정합성 (Data Integrity)을 맞춘다
  * 버퍼 내용 읽기 Share 모드
  * 버퍼 내용 변경 Exclusive 모드
* 경합 X 상황
  * 버퍼 읽기/쓰기 작업 완료 > 래치 획득 > 버퍼 Lock 해제 > 래치 해제
* 경합 O 상황
  * 해치 획득 후 목적한 버퍼를 찾았으나 이미 해당 버퍼가 Lock 잡혀있다면, 버퍼 Lock 대기자 목록 (Waiter List)에 자신을 등록 후 해치 해제한다
  * `buffer busy waits 대기 이벤트`
* 버퍼 블록을 읽을 때, 두 번의 래치 획득이 필요한 상황

<br>

### 버퍼 핸들
* 버퍼 Lock 설정은 `버퍼 Pin`이라고도 표현
  * 변경 시에는 하나의 프로세스만 Pin 가능
  * 조회 시에는 다수의 프로세스가 Pin 가능
* 버퍼 Pin할 때 사용하는 공유 리소스 오브젝트가 `버퍼 핸들 (Buffer Handle)`
  * 버퍼 헤더에 있는 소유자 목록 (Holder List)에 연결시키는 방식으로 Pin 설정
* cache buffer handles 래치

<br>

### 버퍼 Lock의 중요성
* 오라클이 하나의 레코드를 개신하더라도 블록 단위로 I/O를 수행하기 때문에, 블록 접근에 대한 Lock에 더불어 블록 자체에 대한 Lock도 잡는 것이다

<br>

### 버퍼 Pinning
* 버퍼를 읽고 나서 버퍼 Pin (버퍼 Lock)을 즉각 해제하지 않고, 데이터베이스 Call이 진행되는 동안 유지하는 기능
  * Lock 획득/해제에 필요한 래치 해제/재획득 숫자를 줄인다
* 데이터베이스 Call
  * Parse Call
  * Execute Call
  * Fetch Call
* 버퍼 Pinning을 통한 블록 I/O 감소는 SQL 튜닝에 꼭 필요
* 전통적으로 버퍼 Pinning이 적용되던 지점은 인덱스를 스캔하면서 테이블을 엑세스할 때의 인덱스 리프 블록

<br>
<hr>
<br>

## Redo
#### 오라클은 데이터파일과 컨트롤 파일에 가해지는 모든 변경사항을 하나의 Redo 로그 엔트리로서 Redo 로그에 기록한다

<br>

### Online Redo 로그 + Archived (Offline) Redo 로그
* Online Redo 로그는 Redo 로그 버퍼에 버퍼링된 로그 엔트리를 기록하는 파일로서, 최소 두 개 이상의 파일로 구성
  * Log Switching
  * Round-Robin 방식
* Redo 로그의 목적
  * Database Recovery
    * 물리적으로 디스크가 깨지는 등의 사건 이후에 Archived Redo 로그로 데이터베이스 복구
  * Cache Recovery (Instance Recovery)
    * 버퍼 캐시는 휘발성이기 때문에, 사고가 발생했을 때 복구하기 위해 Redo 로그 필요
    * 단계
      * Instance Crash
      * Roll Forward (버퍼 캐시를 마지막 체크포인트 이후부터 시스템 셧다운 이전의 상태로 트랜젝션들을 재현하면서 복구) > Cache Recovery
      * Rollback (커밋되지 않았던 트랜잭션들을 모두 롤백) > Transactoin Recovery
      * 데이터베이스는 커밋되지 않은 기록사항들은 모두 제거되고, 데이터 파일에는 커밋에 성공한 데이터만 남고, 데이터베이스는 완전히 동기화 상태
  * Fast Commit
    * 변경사항을 Append 방식으로 빠르게 Redo 로그 파일에 기록하고
    * 메모리 데이터 블록과 데이터 파일 간 동기화는 적절한 수단 (DBWR, Checkpoint)을 이용해 나중에 배치 (Batch) 방식으로 일괄 수행
    * 즉, 커밋 정보는 로그에만 기록되어 있고, 메모리상의 버퍼 블록에만 기록되고, 디스크에는 기록되지 않은 상태
      * 오라클은 Instance Crash가 발생해도, Redo 로그를 통해 Recovery가 가능하다고 판단이 되기에, 안심하고 Fast Commit을 할 수 있다는 문맥
* Delayed Block Cleanout
  * 갱신된 블록에 커밋 정보를 기록하고 Lock을 해제하는 작업

<div align="center">
  <img width="50%" src= "https://github.com/PoSungKim/development_study/assets/37537227/f8e1745d-615a-4a2d-9ad6-bd901a637d18" />
</div>

* Write Ahead Logging
  * (1) LGWR (Log Writer)가 Redo 로그 버퍼를 Redo 로그에 기록 (Log Force at Commit)
  * (2) DBWR (Database Writer)가 Dirty 데이터 블록 버퍼를 데이터 파일에 기록

<br>

### 

<br>
<hr>
<br>
