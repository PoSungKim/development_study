# 인덱스 튜닝
> 
* 

<hr>
<br>

## 인덱스 기본 원리
#### 

<br>

### B*Tree 인덱스 구조
* 브랜치 블록의 각 로우는 하위 블록에 대한 주소값을 갖는다
* 브랜치 블록 각 로우의 키 값은 하위 블록이 갖는 값의 범위를 의미한다
* 리프 블록의 각 로우는 테이블 로우에 대한 주소값을 갖는다
* 리프 블록 각 로우의 키 값과 테이블 로우의 키 값은 서로 일치한다
* 리프 블록의 각 로우와 테이블 로우 간에는 1:1 관계다
* 리프 블록끼리는 이중연결리스트 (double linked list) 구조다

<br>

### 인덱스 ROWID
* 오브젝트 번호 + 데이터파일 번호 + 블록 번호 + 블록 내 로우번호

<br>

### 인덱스 탐색
* 

<br>
<hr>
<br>

## 테이블 액세스 최소화
#### 

<br>

### 인덱스 ROWID를 이용한 테이블 액세스
* 

<br>

### 클러스터링 팩터 (Clustering Factor)

<br> 

### 인덱스 손익분기점

<br> 

### 온라인 프로그램 튜닝 vs 배치 프로그램 튜닝

<br> 

### Table Access By Index Rowid Batched

<br>
<hr>
<br>

## 인덱스 스캔 효율화
#### 

<br>

### 인덱스 튜닝의 2가지 핵심요소
* 인덱스 스캔 효율화 튜닝
* 테이블 랜덤 엑세스 최소화 튜닝
  * Index Range Scan에서 읽은 Row 수 (ex: 100000)가 Table Access By Index Rowid 하고 남은 Row 수 (ex: 10) 보다 훨씬 크다면 불필요한 테이블 랜덤 엑세스가 발생했다고 할 수 있다
  * cr (ex: 8459) 개수가 결과 Row (ex: 10) 보다 훨씬 크다면 필요 이상의 블록을 읽었다고 할 수 있다
    * 책에서는 블록당 1000건의 Row가 있는 것을 기준으로 판단한다

<br>

### 인덱스 스캔 효율
* 테이블과 달리 인덱스에는 '같은 값'을 갖는 레코드들이 서로 군집해 있다
  * 즉, 인덱스 칼럼을 앞쪽부터 누락 없이 '=' 연산자로 조회하면 조건절을 만족하는 레코드는 모두 모여 있다
* 따라서, 인덱스 칼럼을 조건절에 모두 등치 (=) 조건으로 사용할 때 인덱스 스캔 효율이 가장 좋다
  * 다만, 인덱스 칼럼 중 일부가 조건절에 없거나 등치 (=) 조건이 아니라도, 해당 칼럼이 뒤쪽 칼럼일 때는 비효율이 없다
* 비효율은 인덱스 선행 칼럼이 조건절에 없거나 부등호, BETWEEN, LIKE 같은 범위검색 조건이면, 인덱스를 스캔하는 단계에서 비효율이 생긴다

<br>
<hr>
<br>

## 인덱스 설계
#### 

<br>

### 
* 

<br>
<hr>
<br>
