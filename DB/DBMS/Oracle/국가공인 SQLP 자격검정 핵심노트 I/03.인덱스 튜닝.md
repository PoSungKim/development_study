# 인덱스 튜닝
> 
* 

<hr>
<br>

## 인덱스 기본 원리
#### 

<br>

### B*Tree 인덱스 구조
* 브랜치 블록의 각 로우는 하위 블록에 대한 주소값을 갖는다
* 브랜치 블록 각 로우의 키 값은 하위 블록이 갖는 값의 범위를 의미한다
* 리프 블록의 각 로우는 테이블 로우에 대한 주소값을 갖는다
* 리프 블록 각 로우의 키 값과 테이블 로우의 키 값은 서로 일치한다
* 리프 블록의 각 로우와 테이블 로우 간에는 1:1 관계다
* 리프 블록끼리는 이중연결리스트 (double linked list) 구조다

<br>

### 인덱스 ROWID
* 오브젝트 번호 + 데이터파일 번호 + 블록 번호 + 블록 내 로우번호

<br>

### 인덱스 탐색
* 

<br>
<hr>
<br>

## 테이블 액세스 최소화
#### 

<br>

### 인덱스 ROWID를 이용한 테이블 액세스
* 

<br>

### 클러스터링 팩터 (Clustering Factor)

<br> 

### 인덱스 손익분기점

<br> 

### 온라인 프로그램 튜닝 vs 배치 프로그램 튜닝

<br> 

### Table Access By Index Rowid Batched

<br>
<hr>
<br>

## 인덱스 스캔 효율화
#### 

<br>

### 인덱스 튜닝의 2가지 핵심요소
* 인덱스 스캔 효율화 튜닝
* 테이블 랜덤 엑세스 최소화 튜닝
  * Index Range Scan에서 읽은 Row 수 (ex: 100000)가 Table Access By Index Rowid 하고 남은 Row 수 (ex: 10) 보다 훨씬 크다면 불필요한 테이블 랜덤 엑세스가 발생했다고 할 수 있다
  * cr 개수가 Row 보다 훨씬 크다면 필요 이상의 블록을 읽었다고 할 수 있다
    * 책에서는 블록당 1000건의 Row가 있는 것을 기준으로 판단한다

<br>
<hr>
<br>

## 인덱스 설계
#### 

<br>

### 
* 

<br>
<hr>
<br>
