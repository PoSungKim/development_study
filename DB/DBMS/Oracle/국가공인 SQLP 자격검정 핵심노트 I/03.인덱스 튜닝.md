# 인덱스 튜닝
> 
* 

<hr>
<br>

## 인덱스 기본 원리
#### 

<br>

### B*Tree 인덱스 구조
* 브랜치 블록의 각 로우는 하위 블록에 대한 주소값을 갖는다
* 브랜치 블록 각 로우의 키 값은 하위 블록이 갖는 값의 범위를 의미한다
* 리프 블록의 각 로우는 테이블 로우에 대한 주소값을 갖는다
* 리프 블록 각 로우의 키 값과 테이블 로우의 키 값은 서로 일치한다
* 리프 블록의 각 로우와 테이블 로우 간에는 1:1 관계다
* 리프 블록끼리는 이중연결리스트 (double linked list) 구조다

<br>

### 인덱스 ROWID
* 오브젝트 번호 + 데이터파일 번호 + 블록 번호 + 블록 내 로우번호

<br>

### 인덱스 탐색
* 

<br>
<hr>
<br>

## 테이블 액세스 최소화
#### 

<br>

### 인덱스 ROWID를 이용한 테이블 액세스
* 

<br>

### 클러스터링 팩터 (Clustering Factor)

<br> 

### 인덱스 손익분기점

<br> 

### 온라인 프로그램 튜닝 vs 배치 프로그램 튜닝

<br> 

### Table Access By Index Rowid Batched

<br>
<hr>
<br>

## 인덱스 스캔 효율화
#### 

<br>

### 인덱스 튜닝의 2가지 핵심요소
* 인덱스 스캔 효율화 튜닝
* 테이블 랜덤 엑세스 최소화 튜닝
  * Index Range Scan에서 읽은 Row 수 (ex: 100000)가 Table Access By Index Rowid 하고 남은 Row 수 (ex: 10) 보다 훨씬 크다면 불필요한 테이블 랜덤 엑세스가 발생했다고 할 수 있다
  * cr (ex: 8459) 개수가 결과 Row (ex: 10) 보다 훨씬 크다면 필요 이상의 블록을 읽었다고 할 수 있다
    * 책에서는 블록당 1000건의 Row가 있는 것을 기준으로 판단한다

<br>

### 인덱스 스캔 효율
* 테이블과 달리 인덱스에는 '같은 값'을 갖는 레코드들이 서로 군집해 있다
  * 즉, 인덱스 칼럼을 앞쪽부터 누락 없이 '=' 연산자로 조회하면 조건절을 만족하는 레코드는 모두 모여 있다
* 따라서, 인덱스 칼럼을 조건절에 모두 등치 (=) 조건으로 사용할 때 인덱스 스캔 효율이 가장 좋다
  * 다만, 인덱스 칼럼 중 일부가 조건절에 없거나 등치 (=) 조건이 아니라도, 해당 칼럼이 뒤쪽 칼럼일 때는 비효율이 없다
* 비효율은 인덱스 선행 칼럼이 조건절에 없거나 부등호, BETWEEN, LIKE 같은 범위검색 조건이면, 인덱스를 스캔하는 단계에서 비효율이 생긴다

<br>

### 인덱스 최선두 칼럼이 BETWEEN 조건이면 인덱스 스캔 효율이 최악
* 최선두 칼럼의 NDV가 적고 후행 칼럼의 NDV가 높으면
  * INDEX SKIP SCAN 유도 매우 효율적
  * BETWEEN 절을 IN 조건 변경 매우 효율적
* 예시) 승인요청일자 vs 승인요청일시
  * 승인요청일자 : NDV 낮다
  * 승인요청일시 : NDV 높다 (하루 86400초 존재)

<br>

### 인덱스 칼럼 구성에 따른 접근 방식
* a 고객이 평균 10개의 b 상품을 가입한다
  * 핵심 : 10개면 1개의 리프 블록에 다 들어갈 수 있다
* Index 높이 : 3
* 조회 조건
  * 고객 : 1234
  * 상품 : (nh0037, nh0041, nh0050)
* 칼럼 (a, b) > 리프 블록 > 고객별 가입 상품 
  * b를 필터 방식
    * leaf block : 3개
  * b를 In-List Iterator
    * leaf block : 최소 9개
* 칼럼 (b, a) > 리프 블록 > 가입 상품별 고객
  * b를 필터 방식
    * leaf block : Index Full Scan
  * b를 In-List Iterator
    * leaf block : 최소 9개

<br>

### where 고객ID LIKE :CUST_ID || '%'
* 고객ID
  * :CUST_ID에 NULL 값세팅하면 `고객ID LIKE '%'` 조건으로 모든 고객을 스캔한다
  * 칼럼이 NULL 허용이면, `NULL LIKE '%'` 조건이 되면서 NULL 칼럼을 가진 로우들은 누락된다

<br>
<hr>
<br>

## 인덱스 설계
#### 

<br>

### 
* 

<br>
<hr>
<br>
