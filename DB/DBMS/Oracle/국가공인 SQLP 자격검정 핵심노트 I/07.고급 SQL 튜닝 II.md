# 고급 SQL 튜닝 II
> 
* 

<hr>
<br>

## Partitioning
#### 

<br>

### Partitioning
* 이점
  * 성능 향상
  * 경합 분산
  * 가용성 향상
    * 백업 및 복구, 대량 데이터 변경 및 삭제 등
* 단점
  * 저장 공간
    * 여유단위를 세그먼트 단위로 관리

<br>

### Range Partitioning
* 파티션 기준 칼럼 다건 가능
* 파티션 기준 칼럼 Number/Date/Varchar2 모두 가능
* 입력 공간을 찾지 못하는 에러를 예방하기 위해서 maxvalue 파티셔닝 추가 필요
* 구 파티션에 대한 변경이 있을때, 최신 파티션에도 별도의 변경이 병렬로 처리될 수 있음
* interval 파티셔닝 기능을 사용하지 않는 한 주기적으로 신규 파티션을 추가하는 관리적인 부담이 있다

<br>

### List Partitioning
* 파티션 기준 칼럼 단건 가능
* 파티션 기준 칼럼 불연속된 값을 목록으로 관리
* 입력 공간을 찾지 못하는 에러를 예방하기 위해서 default 파티셔닝 추가 필요
* 구 파티션에 대한 변경이 있을때, 최신 파티션에도 별도의 변경이 병렬로 처리될 수 있음
* 파티션 pruning은 =, in-list, between절에 모두 동작한다

<br>

### Hash Partitioning
* 파티션 기준 칼럼 다건 가능
* 파티션 기준 칼럼에 데이터 분포도가 몰릴 때 이를 분산할 수 있는 옵션이 없어서 고르게 분산되는 데이터 분포도로 떨어지는 파티션 기준 칼럼을 고려해야 한다
  * 즉, 특정 파티션에 데이터가 몰릴 수 있다
* 입력 공간을 찾지 못하는 에러 발생 X
* dml 분산 처리에 용이하다

<br>

### Subpartitioning
* range - hash 가능

<br>

### 파티션 Pruning
* 정적 (Static) 파티션 Pruning
  * 실행계획
    * Pstart - 파티션 번호
    * Pstop - 파티션 번호
  * 발동 조건
    * 파티션에 칼럼에 상수 조건으로 값을 세팅해서 사용할 때
* 동적 (dynamic) 파티션 Pruning
  * 실행계획
    * Pstart - KEY
    * Pstop - KEY
  * 발동 조건
    * 파티션 칼럼에 바인딩 변수 사용할 때
    * nl조인 대상 테이블의 조인 칼럼이 파티션 칼럼일 때

<br>

### 파티션 Pruning 유의사항
* 파티션 키 칼럼을 가공하지 않는 것이 좋다
* 가급적 실행계획에 Partition Range All 오퍼레이션이 나타나지 않도록 쿼리 작성 필요
  * 파티션 키 칼럼이 문자형인데 입력값을 숫자형으로 세팅하면, 문자형이 숫자형으로 변환되는데, 그렇다면 하필 파티션 키 값이 가공되면서 `TO_NUMBER(주문일자) between 20201001 AN D 20201231` 형태로 쿼리가 변환될 수 있다
  * 결과적으로, 파티션 키 칼럼이 가공되면서, PARTITION RANGE ALL 오퍼레이션이 실행되게 되고, 이는 정확한 파티션 타게팅에 실패하면서, 불필요하게 모든 파티션을 읽게 되는 비효율성이 발생하고 성능이 저하된다
* 파티션 키가 문자형 일자 칼럼일 때, LIKE 조건 보다는 BETWEEN 조건이 올바르다
  * 인덱스처럼 불필요한 파티션까지 읽을 수 있기 때문
* 정적 Pruning과 동적 Pruning간의 성능 차이는 거의 없다
  * 실행할 때마다 딕셔너리를 참조하면서 읽어야 할 파티션을 결정하는 것이 아니기 때문에 성능 차이가 거의 없다

<br>

### 


<br>
<hr>
<br>
