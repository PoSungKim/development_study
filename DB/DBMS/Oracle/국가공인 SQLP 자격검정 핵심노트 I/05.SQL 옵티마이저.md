# SQL 옵티마이저
> 
* 

<hr>
<br>

## SQL 옵티마이징 원리

#### 

<br>

### 옵티마이저
* RBO (Rule-based Optimizer)
  * 대용량 데이터베이스 환경에 부적합하다
* CBO (Cost-based Optimizer)
  * 사용자 쿼리를 위해 후보군이 될만한 실행계획들을 도출하고, 데이터 딕셔너리 (Data Dictionary)에 미리 수집해 둔 통계정보를 이용해 각 실행계획의 예상비용을 산정하고, 그중 낮은 비용의 실행계획 하나를 선택
  * 통계정보
    * 데이터양, 칼럼 값의 수, 칼럼 값 분포, 인덱스 높이, 클러스터링 팩터
  * 최적화
    * Query Transformer
      * 사용자에게 전달받은 쿼리를 최적화에 유리한 형태로 변환
    * Estimator
      * 쿼리 오퍼레이션 각 단계의 선택도 (Selectivity), 카디널리티 (Cardinality), 비용 (Cost)을 계산하고, 궁극적으로는 실행계획 전체에 대한 비용을 계산
    * Plan Generator
      * 하나의 쿼리를 수행할 때, 실행계획 후보군들을 생성
  * 힌트
    * 명령어 (Directives)로 비용이 더 낮은 실행계획이 있더라도 힌트를 따라간다

<br>

### 실행계획 
* Bind Variable Peeking
  * SQL이 첫 번째 수행될 때 함께 딸려 온 바인드 변수 값을 살짝 훔쳐보고 (Peek), 그 값에 대한 칼럼 분포를 이용해 실행계획을 결정하는 기능
  * 바인드 변수를 사용하면 히스토그램 정보를 활용하지 못하는 제약을 극복하기 위한 기능
* Self-Learning Optimizer O (기존에 선택했던 실행계획을 상황에 따라 다른 실행계획으로 변경하는 것이 주요 포인트인 것 같다)
  * Adaptive Cursor Sharing
    * 처음 실행 시 특정 실행계획으로 실행했다가 바인드 변수에 다른 값이 입력됐을 때 예상보다 많은 I/O가 발생하면 다른 실행계획을 추가로 생성하고, 이후로 바인드 변수 값 분포에 따라 다른 실행계획을 선택적으로 사용하는 기능
  * Statistics Feedback (Cardinality Feedback)
    * 최초 실행계획을 수립할 때 추정했던 카디널리티와 실제 실행 과정에 읽은 로우 수 간에 차이가 크다면, 조정된 카디널리티 값을 어딘가에 저장해 두었다가 다음번 실행 시에 그것을 사용함으로써 다른 실행계획이 수립되도록 하는 기능
  * Adaptive Plans
    * 런타임에 실행계획을 변경하는 기능
      * 통계정보 상 A 집합과 B 집합, 둘 다 작은 집합이라고 판단이 되어서 NL조인을 옵티마이저가 선택했지만, 실제 실행 과정에서는 먼저 읽은 A 집합에서 예상보다 많은 로우를 반환되면 Hash 조인으로 조인 메소드를 변경한다

<br>
<hr>
<br>
