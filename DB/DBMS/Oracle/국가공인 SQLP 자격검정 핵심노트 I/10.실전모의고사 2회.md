# 실전모의고사 2회
> 
* 

<hr>
<br>

## SQL 고급 활용 및 튜닝
#### 

<br>

### select-list에 칼럼 개수가 더 많은 쿼리의 성능 저하
* 쿼리
  * order by 절이 있는 동일한 쿼리
  * 단지, select하는 칼럼의 개수가 더 많아진 케이스
* 저하 포인트
  * 클라이언트 측에 더 많은 데이터를 전송한다
  * 클라이언트 측에서 더 많은 CPU를 사용한다
  * 서버 측에서 정렬을 위해 더 많은 메모리를 사용한다
* 유지 포인트
  * 서버 측에서는 어차피 지정된 칼럼만 읽을 수 없었기 때문에 IO 발생량은 동일하다

<br>

### 실제 실행계획 vs 예상 실행계획
* 예상 실행계획
  * DBMS_XPLAN.display()
* 라이브러리 캐시에 적재된 커서의 실제 실행계획 + 커서의 트레이스 정보
  * DBMS_XPLAN.display_cursor()
  * V$SQL_PLAN
  * V$SQL_PLAN_STATISTICS_ALL

<br>

### AWR 보고서
* 인스턴스 효율성 항목 100% 가까울수록 좋음
* 대기 이벤트
  * CPU Time이 최상위에 위치하는 것이 좋다
  * db file sequential read와 db file scattered read가 최상위에 위치한다고 하여 무조건 튜닝이 필요한 시스템은 아니다

<br>
  
### 묵시적 형변환
* 가이드 
  * 상이한 데이터 타입 간의 연산시, 묵시적으로 형변환 발생
  * (사용하는 연산자, 데이터 타입)를 기준으로 묵시적 형변환이 달라진다 
* 데이터 타입
  * 문자열 [등호|부등호] 숫자 > 문자열이 숫자로 형변환
  * 문자열 [등호|부등호] 날짜 > 문자열이 날짜로 형변환
* 문자열 연산
  * LIKE
    * 숫자 LIKE 문자열 > 숫자가 문자열로 형변환

<br>

### Index Range Scan
* 인덱스에 모든 칼럼이 Null인 레코드는 포함하지 않는다
* 인덱스 선두칼럼만 가공되지 않으면 Index Range Scan 가능
* 인덱스 엑세스 조건으로 OR 연산자를 사용하여, 인덱스가 아예 없는 칼럼을 연산한다면, 옵티마이저는 Table Full Scan을 택한다
  * /*+ INDEX() */ 힌트를 사용하면, 옵티마이저는 Index Full Scan을 택한다
* 선행 칼럼이 모두 = 조건인 상태에서 첫 번째 범위검색 조건까지만 인덱스 스캔 범위를 줄인다
  * 인덱스 엑세스 조건으로 사용되여 수직탐색으로 사용되기 때문
* 첫 번째 범위검색 조건 이후부터는 정해진 인덱스 스캔 범위 내에서 필터링 역할을 한다
  * 인덱스 필터링 조건으로 사용되여 수평탐색으로 사용되기 때문

<br>

### 인덱스 재생성
* 클러스터링 팩터
* 인덱스 저장 레코드 수
* 인덱스 Depth(Height)
* 인덱스 효용성

<br>

### IOT (Index Oriented Table)
* IOT=PK 인덱스
  * 모든 테이블 칼럼
* IOT에 만든 Secondary 인덱스
  * 자기 자신의 칼럼 + PK 인덱스 칼럼

<br>
<hr>
<br>
