# 고급 SQL 튜닝 I
##

<hr>
<br>

## 소트 튜닝
#### 

<br>

### 소트 수행 과정
* 정렬할 대상 집합을 SGA 버퍼캐시를 통해 읽어들이고, 일차적으로 Sort Area에서 정렬을 시도한다
* PGA 메모리 공간에 할당한 Sort Area에서 정렬 작업을 완료하는 것이 Optimal Sort이다
  * 실행계획에 나타난 하나의 소트 오퍼레이션에 대해 정렬 대상 집합을 디스크에 한 번만 기록하고 작업을 마치는 것을 Onepass 소트
* 다만, 양이 많을 때는 정렬된 중간집합을 Temp 테이블스페이스에 임시 세그먼트를 만들어 저장한다
  * Sort Area가 찰 때마다 Temp영역에 저장해 둔 중간 단계의 집합을 Sort Runs라고 부른다
  * 실행계획에 나타난 하나의 소트 오퍼레이션에 대해 정렬 대상 집합을 디스크에 여러번 기록하고 작업을 마치는 것을 Multipass 소트
  * 정렬된 결과를 Temp 영역에 임시 저장했다가 다시 읽어들이는 디스크 소트가 발생하는 순간 SQL 수행 성능은 크게 나빠진다

<br>

### AutoTrace
* 쿼리
  ```sql
  SET AUTOTRACE TRACEONLY;
  
  SELECT *
  FROM   (SELECT 고객번호, 거래일자, 거래금액, SUM(거래금액) OVER (PARTITION BY 고객번호) 총거래금액
          FROM   거래)
  WHERE  총거래금액 >= 1000000
  ORDER BY 총거래금액 DESC, 고객번호, 거래일자;
  ```
* 실행계획
  ```
  ------------------------------------------------------
  Id | Operation
  ------------------------------------------------------
  0  | SELECT STATEMENT
  1  |    SORT ORDER BY
  2  |        VIEW
  3  |            WINDOW SORT
  4  |                TABLE ACCESS FULL (거래)
  
  ------------------------------------------------------
  Predicate Information (identified by operation id) :
  ------------------------------------------------------
      2 - filter("총거래금액"=1000000)
  ```
* 실행통계
  ```
  ------------------------------------------------------
  Statistics
  ------------------------------------------------------
     ... ...
      13 db block gets
  251231 consistent gets
  529027 physical reads
     ... ...
       1 sorts (memory)
       1 sorts (disk)
     ... ...
  ```
* 해설
  * 실행계획의 소트 오퍼레이션 개수 = 실행통계의 sorts (memory) 개수 + sorts (disk) 개수
    * 2 (SORT ORDER BY, WINDOW SORT) = 1 + 1
  * 소트 대상 데이터의 사이즈를 고려하면 sorts (memory) 혹은 sorts (disk)가 발생하는 오퍼레이션 예상 가능
    * 
 
<br>
<hr>
<br>
