# 고급 SQL 튜닝 I
> 
* 

<hr>
<br>

## 소트 튜닝
#### 

<br>

### 소트 수행 과정
* 정렬할 대상 집합을 SGA 버퍼캐시를 통해 읽어들이고, 일차적으로 Sort Area에서 정렬을 시도한다
* PGA 메모리 공간에 할당한 Sort Area에서 정렬 작업을 완료하는 것이 Optimal Sort이다
  * 실행계획에 나타난 하나의 소트 오퍼레이션에 대해 정렬 대상 집합을 디스크에 한 번만 기록하고 작업을 마치는 것을 Onepass 소트
* 다만, 양이 많을 때는 정렬된 중간집합을 Temp 테이블스페이스에 임시 세그먼트를 만들어 저장한다
  * Sort Area가 찰 때마다 Temp영역에 저장해 둔 중간 단계의 집합을 Sort Runs라고 부른다
  * 실행계획에 나타난 하나의 소트 오퍼레이션에 대해 정렬 대상 집합을 디스크에 여러번 기록하고 작업을 마치는 것을 Multipass 소트
  * 정렬된 결과를 Temp 영역에 임시 저장했다가 다시 읽어들이는 디스크 소트가 발생하는 순간 SQL 수행 성능은 크게 나빠진다

<br>

### AutoTrace
* 쿼리
  ```sql
  SET AUTOTRACE TRACEONLY;
  
  SELECT *
  FROM   (SELECT 고객번호, 거래일자, 거래금액, SUM(거래금액) OVER (PARTITION BY 고객번호) 총거래금액
          FROM   거래)
  WHERE  총거래금액 >= 1000000
  ORDER BY 총거래금액 DESC, 고객번호, 거래일자;
  ```
* 실행계획
  ```
  ------------------------------------------------------
  Id | Operation
  ------------------------------------------------------
  0  | SELECT STATEMENT
  1  |    SORT ORDER BY
  2  |        VIEW
  3  |            WINDOW SORT
  4  |                TABLE ACCESS FULL (거래)
  
  ------------------------------------------------------
  Predicate Information (identified by operation id) :
  ------------------------------------------------------
      2 - filter("총거래금액"=1000000)
  ```
* 실행통계
  ```
  ------------------------------------------------------
  Statistics
  ------------------------------------------------------
     ... ...
      13 db block gets
  251231 consistent gets
  529027 physical reads
     ... ...
       1 sorts (memory) -- SORT ORDER BY
       1 sorts (disk)   -- WINDOW SORT
     ... ...
  ```
* 해설
  * 실행계획의 소트 오퍼레이션 개수 = 실행통계의 sorts (memory) 개수 + sorts (disk) 개수
    * 2 (SORT ORDER BY, WINDOW SORT) = 1 + 1
  * 소트 대상 데이터의 사이즈를 고려하면 sorts (memory) 혹은 sorts (disk)가 발생하는 오퍼레이션 예상 가능
    * 상단 예시 (3)번 WINDOW SORT 연산은 필터링 조건 없이 테이블의 모든 데이터를 대상으로 WINDOW SORT가 발생하기 때문에 sorts (disk) 발생
    * 상단 예시 (1)번 SORT ORDER BY 연산은 적어도 `총거래금액 >= 1000000`라는 조건 1개가 있기 때문에 sorts (memory) 발생
      * 직접 실행계획이나 실제 데이터을 보기 전까지 100% 확신할 수는 없지만, 2개의 오퍼레이션이 연산 유형과 연산 시점이 다르기 때문에 적어도 어느 연산이 더 많은 데이터를 처리할지에 대해서는 비교 가능하고, 더 큰 데이터를 처리하는 연산에서 `sorts (disk)`이 발생할 확률이 높다는 결론까지는 도달할 수 있다
* 비고
  * 모든 연산은 일단 SGA 버퍼캐시를 거치기 때문에, 실행통계의 sorts (memory) 개수 안에 sorts (disk) 개수가 포함되어 있을 수 있다고 착각할 수도 있다
  * 하지만, 두 연산은 독립적으로 카운팅된다는 점을 `실행계획의 소트 오퍼레이션 개수 = 실행통계의 sorts (memory) 개수 + sorts (disk) 개수`라는 점에서 유추할 수 있다
  * 따라서, 독립적이기 때문에, 하단의 예시가 가능해진다
    ```
    ------------------------------------------------------
    Statistics
    ------------------------------------------------------
       ... ...
         1 sorts (memory) -- SORT ORDER BY
         0 sorts (disk)
       ... ...
    ```
    ```
    ------------------------------------------------------
    Statistics
    ------------------------------------------------------
       ... ...
         0 sorts (memory) 
         1 sorts (disk)   -- sort group by
       ... ...
    ```
    ```
    ------------------------------------------------------
    Statistics
    ------------------------------------------------------
       ... ...            -- hash group by (group by 혹은 중복 제거 연산에 Hash 알고리즘을 사용하면 memory/disk 0건, 즉 아예 아예 안 잡힌다)
         0 sorts (memory) 
         0 sorts (disk)   
       ... ...
    ```

<br>

### 대기 이벤트
* direct path write
  * 세션 PGA(Program Global Area) 내부의 버퍼로부터 데이터파일로 기록할 때 대기 발생
* direct path read temp
  * sort 과정에서 디스크 I/O 연산할 때 대기 발생
* direct path sync
* db file parallel write
  * DBWR가 더티 블록를 기록하기 위한 I/O 요청을 보낸 후 대기 발생

<br>

### 실행계획
* 예시 쿼리문
  ```sql
  SELECT DISTINCT 고객번호
  FROM   주문
  WHERE  주문일시 >= TRUNC(SYSDATE - 1)
  ORDER BY 고객번호
  ```
* HASH (UNIQUE) 연산
  * Distinct 연산만 있는 케이스에서 발생 가능
* SORT (ORDER BY) 연산
  * Order By 연산만 있는 케이스에서 발생 가능
* SORT (UNIQUE) 연산
  * Order By 연산 + Distinct 연산이 동시에 있는 케이스에서 발생 가능
  * HASH (UNIQUE)와 SORT (ORDER BY) 연산 2개가 모두 발생하는게 아니라 SORT(UNIQUE) 연산 1개만 발생한다는 의미

<br>

### PGA 또는 Temp 테이블스페이스를 가장 많이 소비하는 실행계획
* 가장 많이 소비하는 실행계획
  * SORT (ORDER BY) - 가장 많이 소비
    * 전체 데이터를 정렬하는 연산
* 더 적게 소비하는 실행계획
  * SORT (AGGREGATE) - 가장 적게 소비
    * 전체 데이터에 대한 COUNT, AVG, SUM 등을 구하는 연산
  * SORT (GROUP BY)
    * Group By 하는 연산
    * 결과집합 건수만큼의 Sort Area만 사용한다
      * Group By 기능에 전체 데이터를 정렬하지는 않기 때문
      * 읽는 레코드마다 Sort 알고리즘을 이용해 값을 찾아가서 COUNT, SUM, MIN, MAX 연산을 수행한다
      * 집계 대상 집합이 아무리 크더라도 Group By 결과집합이 작다면 소량의 Sort Area만 사용하고 Temp 테이블스페이스는 아예 사용하지 않는다는 의미이다
  * HASH (GROUP BY)
    * SORT 알고리즘을 사용하지 않고, HASH 알고리즘을 통해 Group By 기능을 구현했다
    * SORT (GROUP BY)와 동일하게, 결과집합만큼만 Sort Area 그리고 필요하다면 Temp 테이블스페이스를 사용한다

<br>

### 인덱스를 통해 소트 연산 생략하기
* 생략 가능한 SORT 연산
  * SORT (AGGREGATE)
    * MIN/MAX 함수는 실행계획에서 INDEX RANGE SCAN (MIN/MAX) 연산하면서 FIRST_ROW 연산으로 정렬없이 가져올 수 있다
  * SORT (ORDER BY)
    * 인덱스 구성을 맞춰주면 된다
  * SORT (GROUP BY)
    * 인덱스 구성을 맞춰주면 된다 (Group By 연산 대상인 칼럼이 항상 최선두 칼럼일 필요는 없다)
      * 소트 연산에 필요한 칼럼들을 종합한 이후에 `=` 연산인 칼럼들을 앞에 두고, 범위 연산인 칼럼들은 후방에 배치한다
      * 각 칼럼별 선택도를 고려하여, 선택도가 낮은 칼럼부터 선두 칼럼으로 인덱스 구성도를 설계하면 된다
    * SORT (GROUP BY NOSORT) 연산으로 노출된다
* 생략 불가능한 SORT 연산
  * SORT (UNIQUE) + UNION-ALL
    * 집합간 중복을 제거하기 위해서 데이터를 모두 읽어야 함으로 인덱스로 소트 연산을 생략할 수 없다
* 생략 가능한 조인기법
  * NL 조인
  * Sort Merge 조인
* 생략 불가능한 조인기법
  * Hash 조인

<br>

### union vs union all
* union 연산과 union all 연산의 결과집합이 동일하려면, 합집합한 집합들이 상호배타적인 관계를 가지고 있어야 한다
* 합집합을 할 때, 레코드의 중복이 없음을, 즉 집합들이 서로 배타적임을 보장하기 위한 방법이 필요하다
  * SELECT-LIST에 PK/FK 칼럼을 모두 포함한다
  * 집합간에 조건절이 달라야 한다
  * 다른 집합에 있는 조건을 미포함하도록 not 조건으로 포함시킨다

<br>

### 페이징
* Top N Stopkey 알고리즘 작동 필요
  ```sql
  select 계약번호, 상품코드, 계약일시, 계약금액
  from (
      select rownum as rnum, C.*
      from   (
          select 계약번호, 상품코드, 계약일시, 계약금액
          from 계약
          where  지점ID = :BRCH_ID
          and    계약일시 >= trunc( sysdate - 7 )
          order by 계약일시 desc
      ) C
      where rownum <= (:page * 10)
  ) rnum >= (:page - 1) * 10 + 1;
  
  ```

<br>

### MIN/MAX 구하기
* 환경 
  * 테이블 (상품변경이력)
    * (PK) 상품번호
    * (PK) 변경일시
    * 변경구분코드
    * ...
  * 인덱스 (상품변경이력_PK)
    * 상품번호
    * 변경일시
  * 쿼리
    ```sql
    select max(변경일시)
    from   상품변경이력
    where  상품번호 = 'ZE367'
    and    변경구분코드 = 'C2'
    ```
* 해결안 1) 인덱스 추가
  * 상품변경이력_X1
    * 상품번호
    * 변경구분코드
    * 변경일시
* 해결안 2) 쿼리 튜닝
  ```sql
  select 변경일시
  from   (
    select 변경일시
    from   상품변경이력
    where  상품번호 = 'ZE367'
    and    변경구분코드 = 'C2'
    order by 변경일시 desc
  )
  where rownum <= 1
  ```

<br>

### 특정 월에서 마지막으로 변경된 상품번호 데이터 조회
* 환경 
  * 테이블 (상품변경이력)
    * (PK) 상품번호
    * (PK) 변경일시
    * 변경구분코드
    * ...
* 쿼리
  ```sql
  select 상품번호, 변경일시
  from   (
    select 상품번호, 변경일시, row_number() over (partition by 상품번호 order by 변경일시 desc ) no
    from   상품변경이력
    where  변경일시 between '20210301 and '20210131' 
  )
  where  no <= 1
  and    변경구분코드 = 'C2'
  ```

<br>

### 특정 상품에 대해서 특정 월의 일별 최종 할인율
* 환경 
  * 테이블 (상품할인율)
    * (PK) 상품번호
    * (PK) 기준일자
    * (PK) 변경순번
    * 할인률
    * ...
* 쿼리
  ```sql
  select 기준일자, 할인율
  from   상품할인율
  where  상품번호 = 'R0014'
  and    기준일자 between '20210301' and '20210331'
  and    변경순번 = 1
  ```

<br>
<hr>
<br>
