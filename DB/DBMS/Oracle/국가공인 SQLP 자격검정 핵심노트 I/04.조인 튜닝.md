# 조인 튜닝
> 
* 

<hr>
<br>

## NL 조인
#### 

<br>

### ordered vs leading
* ordered use_nl(c) use_hash(t)
* leading(o c t) use_nl(c) use_hash(t)

<br>

### ordered use_nl(c) index(e) index(c)
* NL 조인 데이터 엑세스 순서
  * index - table - index - table
* 
  ```sql
  select /*+ ordered use_nl(c) index(e) index(c) */
      ...
  from 사원 e, 고객 c
  where 1=1
  and e.관리사원번호 = c.사원번호
  and e.입사일자 >= '19960101'
  and e.부서코드 = 'Z123'
  and c.최종주문금액 >= 20000
  ```

<br>

### NL 조인 특징
* 랜덤 액세스 위주의 조인 방식
  * 인덱스 구성이 완벽에 가까워도 대량 데이터를 조인할 때는 NL 조인이 불리하다
* 조인할 대상 레코드가 많아도 ArraySize에 해당하는 최초 N건을 빠르게 출력할 수 있다
  * 조인을 한 레코드씩 순차적으로 진행한다
    * 순차적으로 진행하기 때문에 부분범위 처리가 가능하면 빠른 응답 속도를 낼 수 있다
  * 먼저 액세스되는 테이블 처리 범위에 따라 전체 일량이 결정된다
* 인덱스 유무, 인덱스 구성에 의해 성능이 크게 달라진다
* 따라서, 소량 데이터 위주의 처리 혹은 부분범위 처리가 가능한 온라인 트랜잭션 처리 (OLTP) 시스템에 적합한 조인 방식

<br>

### 인덱스 튜닝 - Driving 테이블 인덱스 칼럼 추가
* 환경
  ```sql
  // 한 달 간 거래 건수 : 평균 20만 건
  
  select .*
  from   상품 p, 거래 t
  where  p.상품분류코드 = 'KTG'
  and    p.상품가격 between 100000 and 200000
  and    t.상품코드 = p.상품코드
  and    t.거래일자 between '20210101' and '20210131';
  ```
  ```
  Rows     Row Source Operation                  
  ------   ----------------------------------------------------------------------------
     368   NESTED LOOPS
      69     TABLE ACCESS BY INDEX ROWID 상품
    9185       INDEX RANGE SCAN 상품_X01
     368     TABLE ACCESS BY INDEX ROWID 거래
     385       INDEX RANGE SCAN 거래_X02
  ```
* 튜닝 방안
  * (1) 조인 순서 변경
    * 한 달 거래 건수가 평균 20만 건이기 때문에 효과가 미흡
  * (2) 상품_X01 인덱스 칼럼 순서 조정
    * Index Range Scan 결과 Rows 수는 순서 조정과는 무관해서 효과가 미흡
  * (3) 상품_X01 인덱스 칼럼 추가
    * Table Access By Index Rowid까지 했을 때 Rows 수가 감소하는 것을 보면, 상품_X01 인덱스는 단일 칼럼으로 되어 있는 경우로 추정됨; 따라서, 테이블에서 필터링 조건으로 사용됐을 칼럼을 인덱스에 추가하면 Table Random Access에 사용되는 Rows들이 감소할 예정
  * (4) 거래_X02 인덱스 칼럼 추가
    * 인덱스 엑세스 후 결과 Rows 개수와 테이블 액세스 후 결과 Rows 개수의 차이가 17밖에 나지 않기 때문에 칼럼 추가의 효과는 미흡

<br>

### 인덱스 튜닝 - Driving 테이블 인덱스 칼럼 순서 변경
* 환경
  ```sql
  상품_PK : 상품코드
  상품_X01 : 상품분류코드 + 상품가격 + 공급업체코드
  거래_PK : 거래번호
  거래_X01 : 거래일자 + 상품코드
  거래_X02 : 상품코드 + 거래구분코드 + 거래일자
  
  select .*
  from   상품 p, 거래 t
  where  p.상품분류코드 = 'KTG'
  and    p.상품가격 between 10000 and 100000
  and    t.상품코드 = p.상품코드
  and    t.거래일자 between '20210101' and '20210131';
  ```
  ```
  Rows     Row Source Operation                  
  ------   ----------------------------------------------------------------------------
     368   NESTED LOOPS (cr=1311 pr=124 pw=0 time=1622 us)
      69     TABLE ACCESS BY INDEX ROWID 상품 (cr=986 pr=35 pw=0 time=659 us)
      69       INDEX RANGE SCAN 상품_X01 (cr=922 pr=31 pw=0 time=645 us)
     368     TABLE ACCESS BY INDEX ROWID 거래 (cr=325 pr=89 pw=0 time=963 us)
     385       INDEX RANGE SCAN 거래_X02 (cr=140 pr=21 pw=0 time=326 us)
  ```
* 튜닝 방안
  * (1) 상품_X01 인덱스 칼럼 순서 조정
    * 인덱스 스캔 효율이 매우 안 좋은 상태 (922 블록을 읽어서 69 로우을 조회); 따라서, 상품가격 칼럼을 후행으로 순서 조정하면 인덱스 스캔 효율이 좋아질 예정
  * (2) 상품_X01 인덱스 칼럼 추가
    * 인덱스와 테이블 액세스 후 Row 개수가 동일하기 때문에, 칼럼 추가 효과는 미흡
  * (3) 거래_X02 인덱스 칼럼 추가
    * 인덱스와 테이블 액세스 후 Row 개수가 동일하기 때문에, 칼럼 추가 효과는 미흡
  * (4) 거래_X02 인덱스 대신 거래_X01 인덱스 사용
    * 140 블록을 읽어서 385 Rows를 조회한 것이 비효율이라고 볼 수도 있지만, 후행 인덱스 액세스이기 때문에, 선행 테이블에서 발생한 조인 액세스, 즉 수직 탐색이 69번 발생했다는 점에서 만약 각 수직 탐색이 2개의 블록을 사용했다면 바로 138 블록을 읽어버리는 효과가 있다; 따라서, 어쩔 수 없는 수직 탐색을 고려하면, 인덱스 스캔 효율이 그렇게 나쁘지는 않다는 것이다
    * 또한, 거래_X02 인덱스에서는 거래일자가 필터조건이기 때문에 스캔 효율이 안 좋을 수 있는데, I/O가 많이 발생하지 않은 것을 보면, (상품분류코드, 상품가격, 공급업체코드)를 만족하는 상품의 거래량이 많지 않다는 것을 알 수 있다; 따라서, 굳이 거래일자가 선두 칼럼인 거래_X01 인덱스를 사용하면, 오히려 거래량이 많은 상품들까지 포함하여 모든 상품의 한 달 치 거래를 모두 스캔해야 하기 때문에 성능이 나빠질 수 있다

<br>

### 인덱스 튜닝 - Driven 테이블 인덱스 칼럼 순서 변경
* 환경
  ```sql
  상품_PK : 상품코드
  상품_X01 : 공급업체코드 + 상품가격
  거래_PK : 거래번호
  거래_X01 : 거래일자 + 상품코드
  거래_X02 : 상품코드 + 거래일자
  
  select .*
  from   상품 p, 거래 t
  where  p.공급업체코드 = 'SP83732'
  and    p.상품가격 between 100000 and 200000
  and    t.상품코드 = p.상품코드
  and    t.거래일자 between '20210101' and '20210131';
  ```
  ```
  Rows     Row Source Operation                  
  ------   ----------------------------------------------------------------------------
     368   NESTED LOOPS (cr=25667 pr=3548 pw=0 time=1123705 us)
      69     TABLE ACCESS BY INDEX ROWID 상품 (cr=42 pr=0 pw=0 time=151 us)
      69       INDEX RANGE SCAN 상품_X01 (cr=2 pr=0 pw=0 time=145 us)
     368     TABLE ACCESS BY INDEX ROWID 거래 (cr=25625 pr=3548 pw=0 time=1123554 us)
     368       INDEX RANGE SCAN 거래_X02 (cr=25257 pr=3421 pw=0 time=1125326 us)
  ```
* 튜닝 방안
  * (1) 상품_X01 인덱스 칼럼 순서 조정
    * rows=69개를 읽을 때 읽는 블록 수 cr=2로 인덱스 스캔 효율이 이미 좋다
  * (2) 상품_X01 인덱스 칼럼 추가
    * 인덱스 스캔 이후 결과와 테이블 스캔 이후 결과가 rows=69로 동일하기 때문에 인덱스에 칼럼 추가는 필요 없다
  * (3) 거래_X01이 아닌 거래_X02 사용
    * cr=25257로 인덱스 스캔에서 비효율 발생
    * 거래일자가 앞에 있으면 공급업체코드가 동일한 모든 상품의 한 달간 거래를 스캔해야 하기 때문에 상품코드가 선두칼럼인 거래_X02 인덱스를 사용해서 특정 상품의 한 달간 거래를 스캔하는 방식으로 읽는 블록 개수 (cr)를 줄일 수 있게 된다
  * (4) 해시조인 사용
    * 해시조인도 좋은 방안이 될 수 있지만, NL조인에서도 가능하면 NL조인 튜닝이 선행되는게 좋다

<br>

### 인덱스 튜닝 - 해시 조인 변경
* 환경
  ```sql
  상품_PK : 상품코드
  상품_X01 : 상품분류코드 + 상품가격
  거래_PK : 거래번호
  거래_X01 : 상품코드 + 거래일자
  거래_X02 : 거래일자
  
  select .*
  from   상품 p, 거래 t
  where  p.상품분류코드 = 'KTG'
  and    p.상품가격 between 10000 and 100000
  and    t.상품코드 = p.상품코드
  and    t.거래일자 between '20210101' and '20210131';
  ```
  ```
  Rows     Row Source Operation                  
  ------   ----------------------------------------------------------------------------
   64368   NESTED LOOPS (cr=171325 pr=54250 pw=0 time=14215131 us)
   35272     TABLE ACCESS BY INDEX ROWID 상품 (cr=15202 pr=735 pw=0 time=1653219 us)
   35272       INDEX RANGE SCAN 상품_X01 (cr=70 pr=3 pw=0 time=1645 us)
   64368     TABLE ACCESS BY INDEX ROWID 거래 (cr=156123 pr=53515 pw=0 time=13984132 us)
   64368       INDEX RANGE SCAN 거래_X02 (cr=105818 pr=3953 pw=0 time=9226231 us)
  ```
* 튜닝 방안
  * (1) 상품_X01 인덱스 칼럼 순서 조정
    * rows=35272개를 읽을 때 읽는 블록 수 cr=70로 인덱스 스캔 효율이 이미 좋다
  * (2) 상품_X01 인덱스 칼럼 추가
    * 인덱스 스캔 이후 결과와 테이블 스캔 이후 결과가 rows=35272개로 동일하기 때문에 인덱스에 칼럼 추가는 필요 없다
  * (3) NL 조인 순서 변경
    * 평균 한 달 거래가 10만건이기 때문에 오히려 조인 순서를 변경하면 더 많은 조인 건수가 발생하기 때문에 비효율이 발생한다
  * (4) 해시 조인 변경
    * 인덱스 스캔 및 칼럼 구성, 그리고 조인 순서 변경을 통해서 개선될 수 없다면, 새로운 조인 방법을 찾는 것이 해결책이 될 수 있다
    * 해시 조인 사용시, 인덱스 클러스터링 팩터에 의해 성능이 판단된다

<br>

### 인덱스 튜닝 - 부분범위처리 및 소트연산 생략, NL조인 최적화
* 환경
  ```sql
  select /*+ ORDERED USE_NL(B) */ *
  from   PRA_HST_STC A, ODM_TRMS B
  where  A.SALE_ORG_ID = :SALE_ORG_ID
  and    A.STRD_GRP_ID = B.STRD_GRP_ID
  and    A.STRD_ID     = B.STRD_ID
  order by A.STC_DT
  ```
  ```sql
  select /*+ ORDERED USE_NL(B) */ *
  from   PRA_HST_STC A, ODM_TRMS B
  where  A.USER_ID     = :USER_ID
  and    A.SALE_ORG_ID = :SALE_ORG_ID
  and    A.STRD_GRP_ID = B.STRD_GRP_ID
  and    A.STRD_ID     = B.STRD_ID
  order by A.STC_DT
  ```
* 튜닝 방안
  * 소트연산 생략 불가능한 인덱스 구성
    * PRA_HST_STC_X1 : SALE_ORG_ID + STRD_GRP_ID + STRD_ID + STC_DT
    * PRA_HST_STC_X2 : USER_ID + SALE_ORG_ID + STRD_GRP_ID + STRD_ID + STC_DT
      * 두 인덱스 모두 중간에 NL조인 조건인 STRD_GRP_ID와 STRD_ID가 껴있어서 STC_DT가 후행 칼럼에 위치하면서 소트 생략 자체가 불가능해짐
      * 소트 생략 자체가 가능해지려면, 인덱스 선두 칼럼이 모두 = 조건으로 입력값을 받는 칼럼이어야 하고, 그 바로 다음 후행칼럼으로 STC_DT로 인덱스가 구성되어야 함
  * 소트연산 생략 가능 인덱스 구성
    * 가정
      * SALE_ORG_ID : 변별력이 나쁜 칼럼
      * USER_ID : 변별력이 좋은 칼럼
    * 옵션 1
      * PRA_HST_STC_X1 : SALE_ORG_ID + STC_DT
        * SALE_ORG_ID이 변별력이 나빠서 결과 로우 수가 많다면 Order By 연산을 생략하는 전략을 취할 수 있다
      * PRA_HST_STC_X2 : USER_ID + SALE_ORG_ID
        * USER_ID이 변별력이 좋아서 결과 로우 수가 작다면 굳이 Order By 연산을 생략해도 효과 미비함
    * 옵션 2
      * PRA_HST_STC_X3 : SALE_ORG_ID + STC_DT + USER_ID
        * 인덱스 하나로 줄이는 방안이라면 상단의 방안도 가능
  * 고려포인트
    * 부분범위처리 가능여부 확인 필요; 가능해야지, 소트연산 생략도 효과가 있음
    * 결과집합의 크기가 너무 작지는 않은지 확인 필요; 커야지, 소트연산 생략도 효과가 있음
    * 부분범위처리와 소트연산 생략 둘 다 가능하고 효과가 있어야지, 소트연산 생략 효과가 생김

<br>

### 인덱스 튜닝 - 부분범위처리 및 소트연산 생략, NL조인 최적화
* 환경 (TOP-N 쿼리)
  ```sql
  
  ```
* 튜닝방안
  * Driving Table (Outer Table)
    * 부분범위 처리 + 소트 생략
    * PRA_HST_STC_X1
  * Driven Table (Inner Table)
    * NL조인 최적화

<br>

### 인덱스 튜닝 - NL조인 Driven (Inner) Table 일반조건 vs 조인조건 
* 오해
  * 보통 조인조건으로 액세스되는 Driven Table 칼럼을 인덱스 선두 칼럼으로 인덱스를 구성하는 것이 낫다고 생각한다
* 진실
  * 일반조건이든 조인조건이든 모두 = (등치) 조건이면 인덱스 칼럼 순서 상관없이 인덱스 액세스 효율에는 문제없다
  * 결국은 데이터 분포도에 따라서 결정하는 것이 옳다
  * 등치 (=)조건인 조인조건보다 부등호 혹은 LIKE 조건인 일반조건의 변별력이 더 좋다면/ 카디널리티가 더 낮다면, 일반조건 칼럼을 조인조건 칼럼보다 앞선 순서로 인덱스를 구성하는게 더 성능이 좋을 수 있다는 의미이다

<br>

### Driven (Inner) Table Access By Rowid 위치의 의미
* 위치
  * Nested Loop 상단
    * 디스크 I/O 때 테이블 Prefetch를 의미 
  * Index Access 하단
    * 디스크 I/O 때 배치 I/O를 의미

<br>
<hr>
<br>
