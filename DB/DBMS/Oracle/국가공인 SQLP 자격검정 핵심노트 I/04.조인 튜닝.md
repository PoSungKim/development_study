# 조인 튜닝
> 
* 

<hr>
<br>

## NL 조인
#### 

<br>

### ordered vs leading
* ordered use_nl(c) use_hash(t)
* leading(o c t) use_nl(c) use_hash(t)

<br>

### ordered use_nl(c) index(e) index(c)
* NL 조인 데이터 엑세스 순서
  * index - table - index - table
* 
  ```sql
  select /*+ ordered use_nl(c) index(e) index(c) */
      ...
  from 사원 e, 고객 c
  where 1=1
  and e.관리사원번호 = c.사원번호
  and e.입사일자 >= '19960101'
  and e.부서코드 = 'Z123'
  and c.최종주문금액 >= 20000
  ```

<br>

### NL 조인 특징
* 랜덤 액세스 위주의 조인 방식
  * 인덱스 구성이 완벽에 가까워도 대량 데이터를 조인할 때는 NL 조인이 불리하다
* 조인할 대상 레코드가 많아도 ArraySize에 해당하는 최초 N건을 빠르게 출력할 수 있다
  * 조인을 한 레코드씩 순차적으로 진행한다
    * 순차적으로 진행하기 때문에 부분범위 처리가 가능하면 빠른 응답 속도를 낼 수 있다
  * 먼저 액세스되는 테이블 처리 범위에 따라 전체 일량이 결정된다
* 인덱스 유무, 인덱스 구성에 의해 성능이 크게 달라진다
* 따라서, 소량 데이터 위주의 처리 혹은 부분범위 처리가 가능한 온라인 트랜잭션 처리 (OLTP) 시스템에 적합한 조인 방식

<br>

### 인덱스 튜닝
* 한 달 간 거래 건수 : 평균 20만 건
  ```sql
  select .*
  from   상품 p, 거래 t
  where  p.상품분류코드 = 'KTG'
  and    p.상품가격 between 100000 and 200000
  and    t.상품코드 = p.상품코드
  and    t.거래일자 between '20210101' and '20210131';
  ```
  ```
  Rows     Row Source Operation                  
  ------   ----------------------------------------------------------------------------
     368   NESTED LOOPS
      69     TABLE ACCESS BY INDEX ROWID 상품
    9185       INDEX RANGE SCAN 상품_X01
     368     TABLE ACCESS BY INDEX ROWID 거래
     385       INDEX RANGE SCAN 거래_X02
  ```
* 튜닝 방안
  * (1) 조인 순서 변경
    * 한 달 거래 건수가 평균 20만 건이기 때문에 효과가 미흡
  * (2) 상품_X01 인덱스 칼럼 순서 조정
    * Index Range Scan 결과 Rows 수는 순서 조정과는 무관해서 효과가 미흡
  * (3) 상품_X01 인덱스 칼럼 추가
    * Table Access By Index Rowid까지 했을 때 Rows 수가 감소하는 것을 보면, 상품_X01 인덱스는 단일 칼럼으로 되어 있는 경우로 추정됨; 따라서, 테이블에서 필터링 조건으로 사용됐을 칼럼을 인덱스에 추가하면 Table Random Access에 사용되는 Rows들이 감소할 예정
  * (4) 거래_X02 인덱스 칼럼 추가
    * 인덱스 엑세스 후 결과 Rows 개수와 테이블 액세스 후 결과 Rows 개수의 차이가 17밖에 나지 않기 때문에 칼럼 추가의 효과는 미흡

<br>

### 인덱스 튜닝
* 환경
  ```sql
  상품_PK : 상품코드
  상품_X01 : 상품분류코드 + 상품가격 + 공급업체코드
  거래_PK : 거래번호
  거래_X01 : 거래일자 + 상품코드
  거래_X02 : 상품코드 + 거래구분코드 + 거래일자
  
  select .*
  from   상품 p, 거래 t
  where  p.상품분류코드 = 'KTG'
  and    p.상품가격 between 10000 and 100000
  and    t.상품코드 = p.상품코드
  and    t.거래일자 between '20210101' and '20210131';
  ```
  ```
  Rows     Row Source Operation                  
  ------   ----------------------------------------------------------------------------
     368   NESTED LOOPS (cr=1311 pr=124 pw=0 time=1622 us)
      69     TABLE ACCESS BY INDEX ROWID 상품 (cr=986 pr=35 pw=0 time=659 us)
      69       INDEX RANGE SCAN 상품_X01 (cr=922 pr=31 pw=0 time=645 us)
     368     TABLE ACCESS BY INDEX ROWID 거래 (cr=325 pr=89 pw=0 time=963 us)
     385       INDEX RANGE SCAN 거래_X02 (cr=140 pr=21 pw=0 time=326 us)
  ```
* 튜닝 방안
  * (1) 상품_X01 인덱스 칼럼 순서 조정
    * 인덱스 스캔 효율이 매우 안 좋은 상태 (922 블록을 읽어서 69 로우을 조회); 따라서, 상품가격 칼럼을 후행으로 순서 조정하면 인덱스 스캔 효율이 좋아질 예정
  * (2) 상품_X01 인덱스 칼럼 추가
    * 인덱스와 테이블 액세스 후 Row 개수가 동일하기 때문에, 칼럼 추가 효과는 미흡
  * (3) 거래_X02 인덱스 칼럼 추가
    * 인덱스와 테이블 액세스 후 Row 개수가 동일하기 때문에, 칼럼 추가 효과는 미흡
  * (4) 거래_X02 인덱스 대신 거래_X01 인덱스 사용
    * 140 블록을 읽어서 385 Rows를 조회한 것이 비효율이라고 볼 수도 있지만, 후행 인덱스 액세스이기 때문에, 선행 테이블에서 발생한 조인 액세스, 즉 수직 탐색이 69번 발생했다는 점에서 만약 각 수직 탐색이 2개의 블록을 사용했다면 바로 138 블록을 읽어버리는 효과가 있다; 따라서, 어쩔 수 없는 수직 탐색을 고려하면, 인덱스 스캔 효율이 그렇게 나쁘지는 않다는 것이다
    * 또한, 거래_X02 인덱스에서는 거래일자가 필터조건이기 때문에 스캔 효율이 안 좋을 수 있는데, I/O가 많이 발생하지 않은 것을 보면, (상품분류코드, 상품가격, 공급업체코드)를 만족하는 상품의 거래량이 많지 않다는 것을 알 수 있다; 따라서, 굳이 거래일자가 선두 칼럼인 거래_X01 인덱스를 사용하면, 오히려 거래량이 많은 상품들까지 포함하여 모든 상품의 한 달 치 거래를 모두 스캔해야 하기 때문에 성능이 나빠질 수 있다

<br>

### 인덱스 튜닝
* 환경
  ```sql
  상품_PK : 상품코드
  상품_X01 : 공급업체코드 + 상품가격
  거래_PK : 거래번호
  거래_X01 : 거래일자 + 상품코드
  거래_X02 : 상품코드 + 거래일자
  
  select .*
  from   상품 p, 거래 t
  where  p.공급업체코드 = 'SP83732'
  and    p.상품가격 between 100000 and 200000
  and    t.상품코드 = p.상품코드
  and    t.거래일자 between '20210101' and '20210131';
  ```
  ```
  Rows     Row Source Operation                  
  ------   ----------------------------------------------------------------------------
     368   NESTED LOOPS (cr=25667 pr=3548 pw=0 time=1123705 us)
      69     TABLE ACCESS BY INDEX ROWID 상품 (cr=42 pr=0 pw=0 time=151 us)
      69       INDEX RANGE SCAN 상품_X01 (cr=2 pr=0 pw=0 time=145 us)
     368     TABLE ACCESS BY INDEX ROWID 거래 (cr=25625 pr=3548 pw=0 time=1123554 us)
     368       INDEX RANGE SCAN 거래_X02 (cr=25257 pr=3421 pw=0 time=1125326 us)
  ```
* 튜닝 방안
  * (1) 상품_X01 인덱스 칼럼 순서 조정
    * rows=69개를 읽을 때 읽는 블록 수 cr=2로 인덱스 스캔 효율이 이미 좋다
  * (2) 상품_X01 인덱스 칼럼 추가
    * 인덱스 스캔 이후 결과와 테이블 스캔 이후 결과가 rows=69로 동일하기 때문에 인덱스에 칼럼 추가는 필요 없다
  * (3) 거래_X01이 아닌 거래_X02 사용
    * cr=25257로 인덱스 스캔에서 비효율 발생
    * 거래일자가 앞에 있으면 공급업체코드가 동일한 모든 상품의 한 달간 거래를 스캔해야 하기 때문에 상품코드가 선두칼럼인 거래_X02 인덱스를 사용해서 특정 상품의 한 달간 거래를 스캔하는 방식으로 읽는 블록 개수 (cr)를 줄일 수 있게 된다
  * (4) 해시조인 사용
    * 해시조인도 좋은 방안이 될 수 있지만, NL조인에서도 가능하면 NL조인 튜닝이 선행되는게 좋다

<br>

### 인덱스 튜닝

* (3) NL 조인 순서 변경
  * 평균 한 달 거래가 10만건이기 때문에 오히려 조인 순서를 변경하면 더 많은 조인 건수가 발생하기 때문에 비효율이 발생한다
* (4) 해시 조인 변경
  * 인덱스 스캔 및 칼럼 구성, 그리고 조인 순서 변경을 통해서 개선될 수 없다면, 새로운 조인 방법을 찾는 것이 해결책이 될 수 있다


<br>
<hr>
<br>
