## 중급쿼리
> 
* 

<hr>
<br>

## 조인(JOIN)
#### 부모 테이블과 자식 테이블을 기본키(PK)와 외래키(FK)로 조인하는 것이 일반적이지만, 관계를 가지지 않는 태이블을 조인하는 경우도 빈번하다

<br>

### 기본 원리
* 조인 조건
  * 카티시안 곱(Cartesian Product)
  * 등가 조인(Equi-Join)
  * 비등기 조인(Nonequi-Join)
* 조인 범위
  * 이너 조인(Inner Join)
    * NULL을 포함한 조인
      ```sql
      -- NVL 활용 방법
      SELECT a.c1 AS ac1 , a.c2 AS ac2, a.c3 AS ac3 , b.c1 AS bc1 , b.c2 AS bc2 , b.c3 AS bc3
      FROM   t1 a, t2 b
      WHERE  b.c1 = a.c1
      AND    NVL(b.c2, -1) = NVL(a.c2 -1)
      AND    NVL(b.c3, -1) = NVL(a.c3, -1);
      
      -- IS NULL 활용 방법
      SELECT a.c1 AS ac1 , a.c2 AS ac2, a.c3 AS ac3 , b.c1 AS bc1 , b.c2 AS bc2 , b.c3 AS bc3
      FROM   t1 a, t2 b
      WHERE  b.c1 = a.c1
      AND    (b.c2 = a.c2 OR (b.c2 is NULL AND a.c2 is NULL))
      AND    (b.c3 = a.c3 OR (b.c3 is NULL AND a.c3 is NULL))
      ```
  * 아우터 조인(Outer Join)
    * 아우터 기준이 아닌 일반 조건 에 (+)기호를 기술하지 않으면 아우터 조인이 이너 조인으로 변경된다
      ```sql
      SELECT a.c1 AS a, b.c1 AS b
      FROM   t1 a, t2 b
      WHERE  b.c1(+) = a.c1
      ORDER BY 1;

      SELECT a.c1 AS a, b.c1 AS b
      FROM   t1 a, t2 b
      WHERE  b.c1 = a.c1(+)
      ORDER BY 1;
      ```
    * (+)기호 사용 조합 케이스
      ```sql
      SELECT a.c1 AS a, b.c1 AS b
      FROM   t1 a, t2 b
      WHERE  a.c1 > 1
      AND    b.c1(+) = a.c1
      ORDER BY 1;

      SELECT a.c1 AS a, b.c1 AS b
      FROM   t1 a, t2 b
      WHERE  b.c1(+) = a.c1
      -- 이너 조인(Inner Join)
      -- 따라서, 조건에 맞는 결과 집합
        -- 예) if NULL > 1, then 필터링 O
        -- 예) if 1    > 1, then 필터링 O
        -- 예) if 2    > 1, then 필터링 X
      AND    b.c1 > 1
      ORDER BY 1;

      SELECT a.c1 AS a, b.c1 AS b
      FROM   t1 a, t2 b
      WHERE  b.c1(+) = a.c1
      -- 아우터 조인(Outer Join)으로 필터링 X
      -- 따라서, a기준 결과 집합 
        -- 예) if NULL(+) > 1, then 필터링 X
        -- 예) if 1(+)    > 1, then 필터링 X
        -- 예) if 2(+)    > 1, then 필터링 X
      AND    b.c1(+) > 1
      ORDER BY 1;

      SELECT a.c1 AS a, b.c1 AS b
      FROM   t1 a, t2 b
      WHERE  b.c1(+) = a.c1
      -- 이너 조인(Inner Join)
      -- 따라서, 조건에 맞는 결과 집합
        -- 예) if NULL IS NULL, then 필터링 X
        -- 예) if 1    IS NULL, then 필터링 O
        -- 예) if 2    IS NULL, then 필터링 O
      AND    b.c1 IS NULL
      ORDER BY 1;

      SELECT a.c1 AS a, b.c1 AS b, c.c1 AS c
      FROM   t1 a, t2 b, t3 c
      -- 아우터 조인(Outer Join)
      -- a(아우터 기준)
      WHERE  b.c1(+) = a.c1
      -- 아우터 조인(Outer Join)
      -- b(아우터 기준)
      AND    c.c1(+) = b.c1
      ORDER BY a.c1;

      SELECT a.c1 AS a, b.c1 AS b, c.c1 AS c
      FROM   t1 a, t2 b, t3 c
      -- 아우터 조인(Outer Join)
      -- a(아우터 기준)
      WHERE  b.c1(+) = a.c1
      -- 아우터 조인(Outer Join)
      -- a(아우터 기준)
      AND    c.c1(+) = a.c1
      ORDER BY a.c1;

      SELECT a.c1 AS a, b.c1 AS b, c.c1 AS c, d.c1 AS d
      FROM   t1 a, t2 b, t3 c, t4 d
      -- 아우터 조인(Outer Join)
      -- a(아우터 기준)
      WHERE  b.c1(+) = a.c1
      -- 아우터 조인(Outer Join)
      -- b(아우터 기준)
      AND    c.c1(+) = b.c1
      -- 아우터 조인(Outer Join)
      -- c(아우터 기준)
      AND    d.c1(+) = c.c1
      ORDER BY 1;
      ```
    * 아우터 기준이 아닌 조인 조건에 (+)기호가 누락되면 선행되는 모든 아우터 조인이 이너 조인으로 변경된다
      ```sql
      SELECT a.c1 AS a, b.c1 AS b, c.c1 AS c, d.c1 AS d
      FROM   t1 a, t2 b, t3 c, t4 d
      -- 아우터 조인(Outer Join) > 이너 조인(Inner Join)으로 변환
      WHERE  b.c1(+) = a.c1 --조건1
      -- 이너 조인(Inner Join)
      AND    c.c1    = b.c1 --조건2
      -- 아우터 조인(Outer Join)
      -- c(아우터 기준)
      AND    d.c1(+) = c.c1 --조건3
      ORDER BY 1;

      SELECT a.c1 AS a, b.c1 AS b, c.c1 AS c, d.c1 AS d
      FROM   t1 a, t2 b, t3 c, t4 d
      -- 아우터 조인(Outer Join) > 이너 조인(Inner Join)으로 변환
      WHERE  b.c1(+) = a.c1 --조건1
      -- 아우터 조인(Outer Join) > 이너 조인(Inner Join)으로 변환
      AND    c.c1(+) = b.c1 --조건2
      -- 이너 조인(Inner Join)
      AND    d.c1    = c.c1 --조건3
      ORDER BY 1;
      ```
* 조인 차수
  * 1:M 조인
    * 등가 조인 시 관계 차수가 1:M이고 조인 기준이 1이면 조인 기준의 행이 M으로 늘어날 수 있다
      ```sql
      SELECT a.c1 AS a1 , b.c1 AS b1 , b.c2 AS b2
      FROM t1 a, t2 b
      WHERE b.c1 = a.c1
      ORDER BY 1, 2, 3
      ```
    * 보통 사고할 때, 마스터 테이블을 드라이빙 테이블로 다른 테이블과 조인 및 필터링하면서, 드라이빙 테이블이 점차적으로 작아지는 패턴으로 생각을 한다
    * 하지만, 드라이빙 테이블이 다른 테이블과 조인되면서, 드라이빙 테이블 내에서 1개씩 존재하던 행들이 M개가 될 수 있다는 의미이다
    * 즉, 드라이빙 테이블의 행들이 중복되면서 커질 수 있다
  * M:1 조인
    * 등가 조인 시 관계 차수가 M:1이고 조인 기준이 M이면 조인 기준의 행이 늘어나지 않는다
      ```sql
      SELECT a.c1 AS a1 , b.c1 AS b1 , b.c2 AS b2
      FROM t2 b, t1 a
      WHERE a.c1 = b.c1
      ORDER BY 1, 2, 3
      ```
    * 등가 조인 시 관계 차수가 M:1이고 M쪽의 PK가 모두 등호(=)로 입력되면 조인 차수는 1:1이 된다
      ```sql
      SELECT a.c1 AS a1 , b.c1 AS b1 , b.c2 AS b2
      FROM   t2 b, t1 a
      WHERE  a.c1 = b.c1
      AND    b.c2 = 1
      ORDER BY 1, 2, 3
      ```
  * 비고
    * 비등가 조인은 관계 차수와 상관없이 조인 차수가 1:M이다
      ```sql
      SELECT b.c1 AS b1, b.c2 AS b2, a.c1 AS a1
      FROM   t2 b, t1 a
      WHERE  a.c1 > b.c1
      ORDER BY 1, 2, 3 
      ```

<br>

### 기술 순서
* FROM절
  * 데이터 모델에 따라 조인 순서를 결정하고, 업무 요건에 따라 조인 순서를 조정한다
    * 조인은 행이 가장 적게 늘어나는 순서로 수행해야 하며 FROM절의 테이블도 동일한 순서로 기술히는 편이 바람직하다
    * 일반 조건이 존재하는 경우 실제 행의 증감까지 고려할 필요가 있다
    * 아우터 조인의 경우 아우터 기준을 FROM 절에 먼저 기술하는 편이 바람직하다
* WHERE절
  * FROM 절에 첫 번째로 기술된 테이블의 일반 조건을 기술한 다음,
  * FROM 절에 기술된 테이블의 순서에 따라 조인 조건과 일반 조건의 순서로 조건을 기술한다
  * 조인 조건은 가능한 PK와 FK 순서대로 기술하고
  * 먼저 조회된 테이블의 값이 입력되는 형태로 작성한다
    ```sql
    SELECT a.ename, b.dname
    FROM   emp a, dept b
    WHERE  a.job = 'CLERK'     -- 일반(a)
    AND    a.sal >= 1000       -- 일반(a)
    AND    b.deptno = a.deptno -- 조인(b=a)
    AND    b.loc 'DALLAS';     -- 일반(b)
    ```
  * 데이터 모델의 관계에 따라 조인 조건을 작성하는 편이 바람직하다
    ```sql
    --GOOD
    SELECT *
    FROM   t1 a, t2 b, t3 c
    WHERE  b.c1 = a.c1
    AND    c.c2 = b.c1;
    
    --BAD
    SELECT *
    FROM   t1 a, t2 b, t3 c
    WHERE  b.c1 = a.c1
    AND    c.c2 = a.c1;
    ```

<br>

### ANSI 조인 문법
* 오라클 조인 문법 (Oracle Join Syntax) vs. ANSI 조인 문법(ANSI Join Syntax)
* NATURAL JOIN절
* USING절
* CROSS JOIN절
* INNER JOIN절
  ```sql
  -- ANSI Join Syntax
  SELECT a.c1 AS a, b.c1 AS b
    FROM t1 a
    JOIN t2 b
      ON b.c1 = a.c1
   WHERE b.c1 > 1;

  SELECT a.c1 AS a, b.c1 AS b
    FROM t1 a
    JOIN t2 b
      ON b.c1 = a.c1
     AND b.c1 > 1; -- 이너 조인은 ON 절에 일반 조건을 기술해도 결과가 동일하다.

  -- Oracle Join Syntax
  SELECT a.c1 AS a, b.c1 AS b
    FROM t1 a
       , t2 b
   WHERE b.c1 = a.c1
     AND b.c1 > 1;
  ```
* OUTER JOIN절
  * LEFT OUTER JOIN, RIGHT OUTER JOIN, FULL OUTER JOIN
    ```sql
    -- ANSI Join Syntax
    SELECT a.c1 AS a, b.c1 AS b
      FROM t1 a
      LEFT OUTER
      JOIN t2 b
        ON b.c1 = a.c1
     WHERE a.c1 > 1;

    -- Oracle Join Syntax
    SELECT a.c1 AS a, b.c1 AS b
      FROM t1 a
         , t2 b
     WHERE a.c1 > 1;
       AND b.c1(+) = a.c1
    ```
    ```sql
    -- ANSI Join Syntax
    SELECT a.c1 AS a, b.c1 AS b
      FROM t1 a
      LEFT OUTER
      JOIN t2 b
        ON b.c1 = a.c1
       AND b.c1 > 1;

    -- Oracle Join Syntax
    SELECT a.c1 AS a, b.c1 AS b
      FROM t1 a
         , t2 b
     WHERE b.c1(+) = a.c1
       AND b.c1(+) > 1;
    ```
    ```sql
    -- ANSI Join Syntax
    SELECT a.c1 AS a, b.c1 AS b
      FROM t1 a
      LEFT OUTER
      JOIN t2 b
        ON b.c1 = a.c1
     WHERE b.c1 > 1;

    -- Oracle Join Syntax
    SELECT a.c1 AS a, b.c1 AS b
      FROM t1 a
         , t2 b
     WHERE b.c1(+) = a.c1
       AND b.c1 > 1;
    ```
* 파티션 아우터 조인
  * PARTITION BY (expr [, expr]...)

<br>

### 활용 예제 
* 조인 조건
  * 관계의 속성
* 조인 범위
  * 관계의 옵셔널리티
    * 필수관계: 이너 조인
    * 선택관계: 아우터 조인
* 조인 차수
  * 관계의 카디널리티
    * 1:1 관계 차수 = 1:1 조인 차수
    * 1:M 관계 차수 = 1:M 조인 차수
  * 1행임을 보장하기 위한 방법
    * 모든 PK 칼럼에 등치(=)조건 사용
    * UNIQUE 제약 생성
* 기술 순서
  * 조인 조건, 조인 범위, 조인 차수 종합
    * 식별관계(실선)이면, FK을 조인조건으로 조인 했을 때 결과집합이 무조건 존재
    * 비식별관계(점선)이면, FK을 조인조건으로 조인 했을 때 결과집합이 있을 수도 있고 없을 수도 있기 때문에, 반드시 결과집합이 존재해야 한다면 아우터 조인(Outer Join) 필요
* 카티션 곱
  * 특정 행 1개를 N개로 복제한 이후에 각 행을 특정 칼럼의 유효값을 기준으로 분기치고자 할 때, 복제 테이블 활용 가능
      * DUAL CONNECT BY 혹은 XML_TABLE() 모두 사용 가능
      ```sql
      WITH 데이터 AS (
          SELECT 'A' AS c1, 43500 AS c2
          FROM dual
          UNION ALL
          SELECT 'B' AS c1, 132000 AS c2
          FROM dual
      ), 복제 AS (
          SELECT ROWNUM AS 순번
          FROM dual
          CONNECT BY LEVEL <= 2
      )
      SELECT CASE 순번 WHEN 1 THEN c1 END c1, sum(c2)
      FROM 데이터,
           복제
      GROUP BY CASE 순번 WHEN 1 THEN c1 END;
    
      WITH 데이터 AS (
          SELECT 'A' AS c1, 43500 AS c2
          FROM dual
          UNION ALL
          SELECT 'B' AS c1, 132000 AS c2
          FROM dual
      )
      SELECT c1, sum(c2)
      FROM 데이터
      GROUP BY ROLLUP(c1);
      ```
* 셀프 조인(Self Join)
  * 순환 관계 조회 및 누적 합 계산 가능
      ```sql
      -- Self Join 방식
      SELECT a.상품코드, a.기준연월, a.판매금액, SUM(b.판매금액) AS 누적판매금액
      FROM   판매통계 a,
             판매통계 b
      WHERE  b.상품코드  = a. 상품코드
      AND    b.기준연월 <= a. 기준연월
      GROUP BY a.상품코드, a.기준연월, a.판매금액
      ORDER BY 1, 2;
      ```
      ```sql
      -- 분석 함수 방식
      SELECT 상품코드, 기준연월, 판매금액,
             SUM(판매금액) OVER (PARTITION BY 상품코드 ORDER BY 기준연월) AS 누적판매금액
      FROM   판매통계 a
      ORDER BY 1, 2;
      ```
* 범위 조인
  * 선분 이력 테이블과 시간 속성 테이블 간의 조인
      ```sql
      SELECT a.*, b.발행일자, b.만료일자, b.할인비율
      FROM 상품가격 a, 할인쿠폰 b
      WHERE a.상품코드 = 'A'
      AND   b.대상상품코드 = a.상품코드
      AND   b.발행일자   <= a.종료일자
      AND   b.만료일자   >= a.시작일자
      ORDER BY a.시작일자, b.발행일자
      ```
* 선택 조인
  * 서브 타입 혹은 다중 관계를 가진 테이블 조인
    * 슈퍼타입: 고객
    * 배타서브타입: 개인고객, 법인고객
        ```sql
        -- OK (고객번호 칼럼에 들어있는 값으로 무조건 조인 - NULL과 번호, 그리고 예상하지 못한 값)
        SELECT a.고객번호, a.고객유형, NVL(b.주민번호, c.법인번호) AS 식별번호
        FROM   고객 a, 개인고객 b, 법인고객 c
        WHERE  b.고객번호(+) = a.고객번호
        AND    c.고객번호(+) = a.고객번호
        ORDER BY 1;
    
        -- GOOD (고객유형에 따라 유효한 고객번호만 조인 - NULL과 번호 ONLY)
        SELECT a.고객번호, a.고객유형, NVL(b.주민번호, c.법인번호) AS 식별번호
        FROM   고객 a, 개인고객 b, 법인고객 C
        WHERE  b.고객번호(+) = DECODE(a.고객유형, 'P', a.고객번호)
        AND    c.고객번호(+) = DECODE(a.고객유형, 'C', a.고객번호)
        ORDER BY 1;
        ```
    * 상품의 기획담당사번: 필수관계
    * 상품의 구매담당사번: 선택관계
        ```sql
        SELECT a.상품코드, NVL2(a.구매담당사번, '구매', '기획') AS 담당, b.사원명
        FROM   상품 a, 사원 b
        WHERE  b.사원번호 = COALESCE (a.구매담당사번, a.기획담당사번)
        ORDER BY 1;
        ```
    * 사원의 소속부서번호: 분기값
        ```sql
        -- DECODE 방식
        SELECT a.상품코드， b.사원명， b.소속부서번호
        FROM   상품 a, 사원 b
        -- 다만, 하나의 조인 조건에 조인할 태이블의 여러 열이 기술되면 쿼리의 성능이 저하될 수 있다
        WHERE  b.사원번호 = DECODE(b.소속부서번호, 2, a.기획담당사번, 3, a.구매담당사번)
        ORDER BY 1, 2;

        -- OR 방식
        SELECT a.상품코드, b.사원명, b.소속부서번호
        FROM   상품 a, 사원 b
        WHERE  ( (b. 사원번호 = a. 기획담당사번 AND b. 소속부서번호 = 2)
              OR (b. 사원번호 = a. 구매담당사번 AND b. 소속부서번호 = 3))
        ORDER BY 1, 2;
        ```
* 파티션 아우터 조인 (Partition Outer Join)
  * 누락된 기간 값 채우기 가능
    * 연월 임시 테이블을 생성해서 아우터 조인의 기준 테이블로 활용 가능
      ```sql
      SELECT a.상품코드, b.기준연월, NVL(c.판매금액, 0) AS 판매금액
      FROM   (상품 a CROSS JOIN 연월 b)
      LEFT OUTER
      JOIN   판매통계 C
      ON     c.상품코드 = a.상품코드
      AND    c.기준연월 = b.기준연월
      WHERE  a.상품코드 IN ('A', 'B')
      AND    b.기준연월 LIKE '2011%'
      ORDER BY 1, 2;
      ```
    * QUERY PARTITION절을 통해 쪼갠 파티션별로 LEFT OUTER JOIN을 진행한다
      ```sql
      SELECT b.상품코드, a.기준연월, b.판매금액
      FROM   연월 a
      LEFT OUTER
      JOIN   판매통계 b PARTITION BY (b.상품코드)
      ON     b.기준연월 = a.기준연월
      AND    b.상품코드 IN ('A', 'B')
      WHERE  a.기준연월 LIKE '2011%'
      ORDER BY 1, 2;
      ```
    * 생각해보면, 판매통계 테이블 자체를 처음부터 상품별로 판매금액이 0인 월도 쌓게끔 설계하면 좋았을 것 같지만, 예시를 위해서 특정 상황으로 만들어 준듯하다

<br>
<hr>
<br>

## 서브 쿼리(Subquery)
#### 

<br>

### 중첩 서브 쿼리(Nested Subquery): WHERE절, HAVING절
* 유형 1) 메인쿼리와 상관여부
  * 비상관 서브쿼리(Uncorrelated Subquery): 메인쿼리와 상관없음
  * 상관 서브쿼리(Correlated Subquery): 메인쿼리와 상관있음
* 유형 2) 반환 행 개수
  * 단일 행 서브 쿼리: 단일 행 반환
  * 다중 행 서브 쿼리: 다중 행 반환
* 유형 1+2) 쿼리 패턴
  * 단일 행 비상관 서브쿼리
    ```sql
    -- WHERE절 단일행 비상관 서브쿼리
    -- 단일행 반환 보장 방법
      -- GROUP BY절
      -- 집계함수
      -- PK 제약 조건 혹은 UNIQUE 제약조건의 모든 열에 등호(=)조건
    SELECT * FROM t1 WHERE (1 = (SELECT MAX ((1) AS c1 FROM t2);

    -- WHERE절 단일행 다중열 비상관 서브쿼리
    SELECT * FROM t1 WHERE (1, 2) = (SELECT MAX(c1), MAX(c2) FROM t2);

    -- HAVING절 단일행 비상관 서브쿼리
    SELECT   c1, MIN(c2) AS c2
    FROM     t1
    GROUP BY c1
    HAVING   MIN(c2) = (SELECT MIN(c1) FROM t2);
    ```
  * 다중 행 비상관 서브쿼리
    * IN절
      ```sql
      SELECT * FROM t1 WHERE c1       IN (SELECT c1     FROM t2);
      SELECT * FROM t1 WHERE (c1, c2) IN (SELECT c1, c2 FROM t2);
      ```
    * NOT IN절
      ```sql
      SELECT * FROM t1 WHERE c2 NOT IN (SELECT c2 FROM t2);
      ```
      ```sql
      -- NOT IN절에 NULL이 존재하면 AND NULL로 풀리면서 UNKNOWN 상태임으로 결과집합이 없어진다
      SELECT * FROM t1 WHERE c1 NOT IN (SELECT c1 FROM t2);

      -- NOT (c1 = 2 or c1 = 3 or c1 = NULL)
      -- (c1 != 2 AND c1 != 3 AND c1 != NULL)
      -- (c1 != 2 AND c1 != 3 AND NULL)
      -- (UNKNOWN)
      -- SELECT 0건

      -- IS NOT NULL 방어로직 필요    
      SELECT * FROM t1 WHERE c1 NOT IN (SELECT c1 FROM t2 WHERE c1 IS NOT NULL);
      ```
      ```sql
      -- OR NULL 조건은 다른 조건이 TRUE 인 경우 항상 TRUE이므로 무시되는데 이때 로직이 달라지면서 결과집합이 달라진다
      SELECT * FROM t1 WHERE (c1, c2) NOT IN (SELECT c1, c2 FROM t2);

      -- NOT ( (c1, c2) = (1, 2) OR (c1, c2) = (2, 3) OR (c1, c2) = (2, NULL) )
      -- NOT ( (c1 = 1 AND c2 = 2) OR (c1 = 2 AND c2 = 3) OR (c1 = 2 AND c2 = NULL) )
      --     ( (c1 != 1 OR c2 != 2) AND (c1 != 2 OR c2 != 3) AND (c1 != 2 OR NULL ) )
      --     ( (c1 != 1 OR c2 != 2) AND (c1 != 2 OR c2 != 3) AND (c1 != 2) )
         -- 여기서 (c1 != 2)에서 걸리게 되면서, c1이 2이기만 해도, FALSE가 되서 결과집합에서 제외된다
         -- 즉, (2, NULL)를 제외시켜야 하는데, (2, ...) 모두를 제외시키게 된다

      -- IS NOT NULL 방어로직 필요
      SELECT * FROM t1 WHERE (c1, c2) NOT IN (SELECT c1, c2 FROM t2 WHERE c2 IS NOT NULL);
      ```
    * ANY, ALL
      * =
        * ANY: IN (subquery)
        * ALL
      * <>
        * ANY
        * ALL: NOT IN (subquery)
      * >
        * ANY: > (SELECT MIN... subquery)
        * ALL: > (SELECT MAX... subquery)
      * <
        * ANY: < (SELECT MAX... subquery)
        * ALL: < (SELECT MIN... subquery)
  * 단일 행 상관 서브쿼리
    ```sql
    SELECT a.*
    FROM   t1 a
    WHERE  a.c2 = (SELECT MAX(x.c2) FROM t2 x WHERE x.c1 = a.c1)
    ```
  * 다중 행 상관 서브쿼리
    * EXISTS - 세미조인(SEMI JOIN), 서브 쿼리와의 조인이 1번이라도 성공하면 행 반환 O
      ```sql
      SELECT a.* FROM t1 a WHERE EXISTS (SELECT 1 FROM t2 x WHERE x.c1 = a.c1);

      -- 특정행은 무조건 반환하고 싶을 때
      SELECT a.*
      FROM   t1 a
      WHERE  EXISTS (SELECT 1 FROM DUAL WHERE a.c1 = 2 --특정값은 항상 있도록 값을 추가해두는 방법
                     UNION ALL
                     SELECT 1 FROM t2 x WHERE x.c2 = a.c2);
      ```
    * NOT EXISTS - 안티조인(ANTI JOIN), 서브 쿼리와의 조인이 1번이라도 성공하면 행 반환 X
      ```sql
      SELECT a.* FROM t1 a WHERE NOT EXISTS (SELECT 1 FROM t2 x WHERE x.c1 = a.c1);

      -- 특정행은 무조건 반환하고 싶을 때
      SELECT a.*
      FROM   t1 a
      WHERE  NOT EXISTS (SELECT 1
                         FROM t2 x
                         WHERE a.c1 <> 2 --특정값만 제외하고 포함함으로써 NOT EXISTS에 그 특정값은 필터링되지 않게 뚫리게 해주는 방법
                         AND x.c2 = a.c2);
      ```
* 유형 1+2) 쿼리 패턴
  * 단일행 비상관 서브쿼리
    ```sql
    SELECT 고객번호/ 고객명
    FROM 고객
    WHERE 고객번호 = (SELECT MAX (주문고객번호) KEEP (DENSE_RANK FIRST ORDER BY 주문일자 DESC)
                    FROM 주문);
    ```
    ```sql
    SELECT 주문번호, 주문일자
    FROM   주문
    WHERE  주문고객번호 = (SELECT 고객 번호
                        FROM 개인고객
                        WHERE 주민번호 ='0101013000001');

    -- 단일행 비상관 서브쿼리는 메인 쿼리와 서브 쿼리의 조인차수가 1:1이므로 조인으로 변경 가능
    SELECT b.주문번호, b.주문일자
    FROM   개인고객 a, 주문 b
    WHERE  a.주민번호    = '0101013000001'
    AND    b.주문고객번호 = a. 고객번호;
    ```
  * 단일행 상관 서브쿼리
    ```sql
    SELECT a.고객변호, b.주문번호, b.주문일자
    FROM   개인고객 a, 주문 b
    WHERE  b.주문고객번호 = a.고객번호
    AND    b.주문일자    = (SELECT MAX(x.주문일자)
                          FROM   주문 x
                          WHERE  x.주문고객번호 = a.고객번호);
    ```
    ```sql
    -- BAD: 서브쿼리의 결과를 리터럴과 비교하면 성능이 안 좋아질 수 있다
    SELECT a.*
    FROM   t1 a
    WHERE  (SELECT MAX(x.c2)
            FROM   t2 x
            WHERE  x.c1 = a.c1) >= 3;

    -- GOOD: 다중행 상관 서브쿼리
    SELECT a.*
    FROM   t1 a
    WHERE  c1 IN (SELECT c1
                  FROM   t2 x
                  WHERE  x.c1 = a.c1
                  HAVING MAX(x.c2) >= 3);

    -- GOOD: 다중행 비상관 서브쿼리
    SELECT a.*
    FROM   t1 a
    WHERE  c1 IN (SELECT   c1
                  FROM     t2 x
                  GROUP BY c1
                  HAVING   MAX(x.c2) >= 3);
    ```
* 다중행 서브쿼리
  * 의미
    * `IN`: 서브 쿼리를 먼저 조회하여, 메인 쿼리에 값 공급
    * `EXISTS`: 메인 쿼리를 먼저 조회하여, 서브 쿼리로 존재 여부를 확인
  * 결과집합
    * `IN`과 `EXISTS`: 동일한 결과집합을 갖는다; 따라서, 의미에 따라서 개발자가 적재적소로 결정하면 된다
    * `NOT IN`과 `NOT EXISTS`: 서브 쿼리의 널 존재 여부에 따라 결과가 달라질 수 있다
      * `NOT IN`: `AND NULL` = UNKNOWN 이슈 및 `OR NULL` => 무시됨 이슈가 있다
      * `NOT EXISTS`: NULL 관련 이슈 없이 정상적으로 결과집합을 리턴한다; 따라서, `NOT EXISTS`을 사용하는 것이 더 바람직하다

<br>

### 스칼라 서브 쿼리(Scalar Subquery): SELECT절
* 스칼라
  * 단일값 = 단일열 + 단일행
  * NULL = 반환값 존재 X
```sql
SELECT a.c1, (SELECT MAX(x.c2) FROM t2 x WHERE x.c1 = a.c1) AS c2
FROM   t1 a;

SELECT a.deptno, a.dname
       , (SELECT MIN (x.sal) FROM emp x WHERE x.deptno = a.deptno) AS sal_min
       , (SELECT MAX (x.sal) FROM emp x WHERE x.deptno = a.deptno) AS sal_max
FROM dept a;

SELECT a.deptno, a.dname
, NVL ((SELECT SUM(x.sal) FROM emp x WHERE x.deptno = a.deptno), 0) AS sal
, CASE
       WHEN (SELECT SUM(x.sal) FROM emp x WHERE x.deptno = a.deptno) >= 10000
       THEN 1
       ELSE 2
  END AS grade
FROM dept a;
```

<br>

### 인라인 뷰(Inline View): WHERE절
* 인라인 뷰
  * 쿼리에서 즉시 처리되는 (inline) 뷰
* 결과 집합의 변경 여부
  * 단순 뷰 (Simple View): 결과 집합의 변경이 없음
    ```sql
    SELECT a.dname, b.ename
    FROM (SELECT * FROM dept WHERE loc = 'DALLAS') a
       , (SELECT * FROM emp  WHERE job = 'CLERK' ) b
    WHERE b.deptno = a.deptno;

    SELECT a.dname, b.ename
    FROM   dept a
         , emp b
    WHERE a.loc = 'DALLAS'
    AND   b.deptno = a.deptno
    AND   b.job    = 'CLERK'
    ```
  * 복합 뷰 (Complex View): 결과 집합의 변경이 있을 수 있음 (DISTINCT 키워드, GROUP BY 절)
    ```sql
    -- 조인차수 1:1로 만들어줄 수 있다
    SELECT a.dname , b.sal
    FROM  dept a
       , (SELECT deptno, SUM (sal) AS sal FROM emp GROUP BY deptno) b
    WHERE b.deptno = a.deptno;
    ```

<br>

### 사용기준
* 조인과 서브 쿼리의 사용 기준은 조인 치수와 관련이 있다
  * 조인 (Join): 조인 기준의 행이 줄어들거나 늘어날 수 있음
  * 중칩 서브 쿼리 (Nested Subquery): 메인 쿼리의 행이 줄어들 수 있지만 늘어나지는 않음
  * 스칼라 서브 쿼리 (Scalar Subquery): 메인 쿼리의 행이 변하지 않음
  * 인라인 뷰 (Inline View): 메인 쿼리의 행이 줄어들거나 늘어날 수 있음 (조인과 동일)
* 조인
 * 조인은 테이블을 연결하는 기본 방식
   ```sql
   -- 1:M = dept:emp
   -- M행으로 증가한다
   SELECT a.deptno, a.dname , b.ename
   FROM   dept a, emp b
   WHERE  b.deptno = a.deptno;
   ```

<br>

### 중칩 서브 쿼리 (Nested Subquery)
* 서브 쿼리로 메인 쿼리의 결과 집합을 제한할 때 사용
   ```sql
   -- 1:M = 메인쿼리(dept):서브쿼리(emp)
   -- 메인쿼리가 M행으로 증가하지 않는다; 유지하거나 감소한다
   SELECT a.deptno, a.dname
   FROM   dept a
   WHERE  EXISTS (SELECT 1 FROM emp x WHERE x.deptno = a.deptno);

   -- 조인되는 값의 종류가 적고, 서브 쿼리 테이블의 크기가 클 때 EXISTS 사용
   -- 아니면, 인라인 뷰 (Inline View)가 성능이 보편적으로 더 좋다
   -- 다만, 인라인 뷰 (Inline View)는 M열로 증가가 가능하기 때문에 DISTINCT를 해줘야 한다
   SELECT a.deptno, a.dname
   FROM   dept a
       , (SELECT DISTINCT deptno FROM emp) b
   WHERE  b.deptno = a.deptno;

   SELECT DISTINCT a.deptno, a.dname FROM dept a, emp b WHERE b.deptno = a.deptno;
   ```
 * 보통, `M:1=메인쿼리:서브쿼리`때 사용 X
   ```sql
   -- BAD
   SELECT a.empno, a.ename
   FROM   emp a
   WHERE  EXISTS (SELECT 1 FROM dept x WHERE x.deptno = a.deptno);

   -- GOOD
   -- 조인(Join) 활용
   SELECT a.empno, a.ename FROM emp a, dept b WHERE b.deptno = a.deptno;
   ```
 * 보통, `1:M=메인쿼리:서브쿼리`때 사용 O

 <br>
 
### 스칼라 서브 쿼리 (Scalar Subquery)
* 서브 쿼리로 단일 값을 조회할 때 시용
 ```sql
 -- 메인쿼리의 행에 영향도 X; 이미 결정된 뒤에 동일한 행에서 단일값을 조회하기 때문
 SELECT a.deptno, a.dname
     , (SELECT MIN (sal) FROM emp x WHERE x.deptno = a.deptno) AS sal_min
     , (SELECT MAX (sal) FROM emp x WHERE x.deptno = a.deptno) AS sal_max
 FROM dept a;
 ```
* 보통, `M:1=메인쿼리:서브쿼리`때 사용 X
 ```sql
 -- BAD
 SELECT a.empno, a.ename
     , (SELECT x.dname FROM dept x WHERE x.deptno = a.deptno) AS dname
 FROM emp a;

 -- GOOD
 -- 조인(Join) 활용
 SELECT a.empno, a.ename, b.dname
 FROM   emp a, dept b
 WHERE  b.deptno = a.deptno;

 -- 만약 스칼라 서브쿼리에 일반조인 조건이 있다면, 아우터 조인 (Outer Join) 필요
 ```
* 보통, `1:M=메인쿼리:서브쿼리`때 사용 O

<br>

### 인라인 뷰 (Inline View)
* 복합 뷰
 * 새로운 결과 집합을 만들거나 조인 치수를 1:1 관계로 만들 때 사용
* 간단 뷰
 * 조인 순서를 제어하거나 반복되는 표현식을 제거할 때 사용
   ```sql
   SELECT deptno
        , MAX(sal + NVL(comm, 0)) AS sal_max
        , MIN(sal + NVL(comm, 0)) AS sal_min
   FROM   emp
   GROUP BY deptno;

   SELECT deptno
        , MAX(sal) AS sal_max
        , MIN(sal) AS sal_min
   FROM   (SELECT deptno, sal + NVL(comm, 0) AS sal
           FROM   emp)
   GROUP BY deptno;
   ```

<br>
   
### WITH 절
* SUBQUERY FACTORING절
  * SUBQUERY FACTORING절에 기술한 서브 쿼리를 2번 이상 사용하면 서브 쿼리의 결과 집합이 임시 영역에 저장
    * 2번 예시
      * WITH절에서 w1과 `w2(w1포함)`
      * WHERE절에서 `w1`
    * 저장 순서
      * 먼저 메모리 PGA에 먼저 저장하고
      * 이후에 공간이 부족한 경우 임시 영역(DISK)에 저장한다

<br>

### 신규기능
* LATERAL 인라인 뷰
  * 인라인 뷰에 메인 쿼리의 열 기술 가능
    * 중첩 서브쿼리(Nested Subquery)에서는 기존부터 계속 가능했음
* CROSS APPLY 절
* OUTER APPLY 절
* 기존 동작 변화

<br>
<hr>
<br>

## 집합 연산자(Set Operator)
#### 조인은 수직으로 데이터를 연결하고, 집합은 수평으로 데이터를 연결한다

<br>

### 기본문법
* UNION ALL 연산자
  * 작성 순서대로 결과집합이 나열된다
* UNION 연산자
  * 중복값 제거를 위해서 정렬(Sort)가 발생한다
  * 데이터 중복이 없고, 정렬이 필요없을 때는 UNION ALL로 대체 가능
* INTERSECT 연산자
  * 중복값 제거를 위해서 정렬(Sort)가 발생한다
* MINUS 연산자
  * 중복값 제거를 위해서 정렬(Sort)가 발생한다

<br>

### 주의사항
* UNION ALL
  * 열의 개수 동일 필요
  * 열의 데이터 타입 동일 필요
  * 인라인 뷰로 연결해서 인라인 뷰 별로 다른 ORDER BY로 정렬 후 순차적으로 UNION ALL 가능
    * 즉, 중복값 삭제를 위한 정렬 연산을 수행하는 UNION/MINUS/INTERSECT에서는 불가능한 연산
* 집합 연산자 공통
  * ORDER BY절을 쿼리문 최하단에 1번만 기술 필요

<br>

### 활용예제
* OR 조건 성능 개선
  * OR-Expansion 
    * UNION-ALL로 변환할 때, 중복된 행이 리턴될 수 있으니, 조건문을 배타적으로 작성이 필요하다 
    * 배타적 조건을 만들다가 NULL 값으로 인해 값이 누락될 수 있다
      * `IS NULL` 혹은 `LNNVL` 활용 가능
* 동적 조건 성능 개선
  * 유형 
    * 입력값에 따라 동적으로 변하는 OR조건
    * ORDER BY DECODE()
  * 모두 UNION-ALL로 변환 가능
* FULL OUTER JOIN 성능 개선
  * 조인이 여러번 수행되어 쿼리의 성능 저하 발생
  * UNION-ALL로 대체 가능
* INTERSECT, MINUS 연산자 성능 개선
  * 중복값을 제거하기 위해 데이터 집합 정렬할 때 성능 저하 발생
  * EXISTS와 LNNVL로 대체 가능

<br>
<hr>
<br>

## 분석 함수(Analytic Function)
#### 

<br>

### 분석함수는 집계함수의 확장
* 집계 방식
  * 집계함수: 행그룹으로 값 집계
  * 분석함수: 파티션과 윈도우로 값 집계
* 데이터 집합 변경여부
  * 집계함수: 행그룹별로 단일행 반환 > 변경 O
  * 분석함수: 데이터 집합 변경없이 집계 > 변경 X
* 예시
  ```sql
  --집계함수
  --원본 데이터 조회를 위해서 emp 테이블 2번 조회 필요
  SELECT a.empno, a.sal, b.sal AS c1, a.sal / b.sal AS c2
  FROM emp a
  , (SELECT deptno, SUM (sal) AS sal FROM emp GROUP BY deptno) b
  WHERE a.deptno = 10
  AND b.deptno = a.deptno
  ORDER BY 1;
  ```
  ```sql
  --분석함수(SUM)
  --SUM 함수는 OVER 절을 기술하면 분석함수로 사용된다
  SELECT empno, sal
  , SUM (sal) OVER () AS c1
  , RATIO_TO_REPORT (sal) OVER () AS c2
  FROM emp
  WHERE deptno = 10
  ORDER BY 1;
  ```
  ```sql
  --집계함수(SUM)
  --ORA-00937: 단일 그룹의 그룹 함수가 아닙니다
  SELECT empno , job, sal , SUM (sal) AS tot FROM emp WHERE deptno = 30;
  ```

<br>

### 기본 문법
* 분석함수는 OVER 키워드를 사용한다
  ```sql
  analytic_function([arguments]) OVER (analytic_clause)
  ```
* analytic_clause
  ```sql
  [query_partition_cluase] [order_by_clause [windowing_clause]]
  ```
* QUERY PARTITION 절
  ```sql
  PARTITION BY expr [, expr]...
  ```
  ```sql
  SELECT empno, job, sal
       , SUM(sal) OVER (PARTITION BY job) AS c1
       , SUM(sal) OVER () AS c2 -- 파티션을 지정하지 않았을 때 전체 행이 하나의 파티션으로 동작한다
  FROM   emp
  WHERE  deptno = 30
  ORDER BY 2, 1;
  ```
* ORDER BY 절
  ```sql
  ORDER BY expr [ASC | DESC] [NULLS FIRST | NULLS LAST]
                [, expr [ASC | DESC] [NULLS FIRST | NULLS LAST]]...
  ```
* WINDOWING 절

  <div align="center">
    <img width="50%" src="https://github.com/user-attachments/assets/0d7c1ca2-0889-4ab8-9268-792aa32d1e86" />
  </div>
  
  ```sql
  {ROWS | RANGE}
    {BETWEEN {UNBOUNDED PRECEDING | CURRENT ROW | value_expr {PRECEDING | FOLLOWING}}
         AND {UNBOUNDED FOLLOWING | CURRENT ROW | value_expr {PRECEDING | FOLLOWING}}
  | {UNBOUNDED PRECEDING | CURRENT ROW | value_expr PRECEDING}}
  ```
    * ROWS
      * 윈도우 기준
        * 물리적 행
      * 동일한 정렬 값
        * 다른 값을 반환
      * value_expr 계산
        * 정렬 행의 위치
    * RANGE
      * 윈도우 기준
        * 논리적 범위
      * 동일한 정렬 값
        * 같은 값을 반환
      * value_expr 계산
        * 정렬 값
    * 윈도우의 범위
      * BETWEEN ... AND ... : 윈도우의 시작과 끝 
      * UNBOUNDED PRECEDING : 앞쪽 끝
      * UNBOUNDED FOLLOWING : 뒤쪽 끝
      * CURRENT ROW : 현재 행
      * value_expr PRECEDING
        * ROWS: 현재 행에서 앞쯕오로 value_expr만큼 이동
        * RANGE: 현재 값에서 value_expr을 가감
      * value_expr FOLLOWING
        * ROWS: 현재 행에서 뒤쪽으로 value_expr만큼 이동
        * RANGE: 현재 값에서 value_expr을 가감
    * DEFAULT 세팅
      * `RANGE UNBOUNDED PRECEDING`
* KEEP 키워드
  ```sql
  analytic_function ([arguments]) KEEP (DENSE_RANK {FIRST|LAST} ORDER BY expr) [OVER ([query_partition_clause])]
  ```
  * KEEP 키워드를 사용하면, ANALYTIC절에 QUERY PARTITION절만 사용 가능하다
* 주의 사항
  * RANGE 방식에 value_expr을 지정하면 ORDER BY 절에 숫자값이나 날짜 값을 사용해야 한다 (문자값을 사용하면 값을 계산할 수 없기 때문에 에러 발생)
  ```sql
  SELECT job, sal, SUM (sal) OVER (ORDER BY job RANGE 1 PRECEDING) AS c1
  FROM emp
  WHERE deptno = 30;
  -- ORA-00902: 데이터유형이 부적합합니다
  ```
  * RANGE 방식에 value_expr을 지정하면 정렬 표현식을 1개만 사용할 수 있다
  ```sql
  SELECT job, sal, SUM (sal) OVER (ORDER BY sal, comm RANGE 1 PRECEDING) AS c1
  FROM emp
  WHERE deptno = 30;
  -- ORA-30486: 윈도우 지정의 창 합계 그룹이 부적합합니다
  -- 2개 (sal, comm)
  ```
  ```sql
  SELECT hiredate, sal
       , SUM(sal) OVER( ORDER BY hiredate RANGE 90 PRECEDING ) AS c1
       , SUM(sal) OVER( ORDER BY hiredate RANGE INTERVAL '3' MONTH PRECEDING ) AS c2
  FROM   emp
  WHERE  deptno = 30
  ORDER BY 1;
  ```
  * 분석함수는 SELECT와 ORDER BY에서만 사용 가능
    * 대신에 인라인 뷰 활용 가능
  ```sql
  SELECT deptno, ename, sal
  FROM    emp
  WHERE  SUM(sal) OVER (PARTITION BY deptno) >= 10000;
  -- ORA-00934: 그룹 함수는 허가되지 않습니다
  ```
  ```sql
  SELECT hiredate, ename, sal, c1
  FROM   (SELECT a.*, SUM(a.sal) OVER (PARTITION BY a.deptno) AS c1 FROM emp a)
  WHERE  c1 >= 10000
  ORDER BY 1,2;
  ```
  * c2, c3에 사용된 분석함수는 그룹핑이 완료된 후에 수행된다
  ```sql
  SELECT deptno
       , SUM(sal) AS c1, SUM(SUM(sal)) OVER () AS c2, COUNT(*) OVER () AS c3
  FROM  emp
  GROUP BY deptno
  ORDER BY 1;
  ```
  ```sql
  -- 이렇게 인라인 뷰로 작성하는 것이 가독성에 더 좋다
  SELECT deptno, c1, SUM (c1) OVER () AS c2, COUNT (*) OVER () AS c3
  FROM (SELECT deptno, SUM (sal) AS c1 FROM emp GROUP BY deptno)
  ORDER BY 1;
  ```
  * 분석함수는 데이터 집합 변경이 없기 때문에 DISTINCT가 필요한 상황이 생긴다
  ```sql
  SELECT DISTINCT deptno, SUM(sal) OVER (PARTITION BY deptno) AS c1
  FROM emp;
  ```
  ```sql
  -- 이렇게 GROUP BY를 사용하여 행 그룹으로 집계하는 것이 가독성에 더 좋다
  SELECT deptno, SUM(sal) AS c2 FROM emp GROUP BY deptno;
  ```

<br>

### 분석 함수
* 분석 함수의 대부분은 집계 함수에 OVER 키워드를 기술하는 방식으로 사용된다
* 종류
  * 기본 함수
    * COUNT - WINDOWING + KEEP
    * MIN - WINDOWING + KEEP
    * MAX - WINDOWING + KEEP
    * SUM - WINDOWING + KEEP
    * AVG - WINDOWING + KEEP
  * 통계 함수
    * STDDEV - WINDOWING + KEEP
    * VARIANCE - WINDOWING + KEEP
  * 순위 함수
    * RANK
    * DENSE_RANK
    * ROW_NUMBER
    * NTILE
    * CUME_DIST
    * PERCENT_RANK
    * RATIO_TO_REPORT
  * 분포 함수
    * PERCENTILE_CONT - WITHIN GROUP
    * PERCENTILE_DISC - WITHIN GROUP
    * MEDIAN - WITHIN GROUP
  * 순차 함수
    * FIRST_VALUE - WINDOWING
    * LAST_VALUE - WINDOWING
    * NTH_VALUE - WINDOWING
  * 기타 함수
    * LAG
    * LEAD
    * LISTAGG - WITHIN GROUP
* 기본 함수
  * COUNT
    * COUNT ({* | [DISTINCT | ALL] expr}) OVER (analytic_clause)
    ```sql
    SELECT job, COUNT(*) OVER (PARTITION BY job) AS c1
    FROM   emp
    WHERE  deptno = 30
    ORDER BY 1;
    ```
  * MIN
    * MIN (expr) OVER (analytic_clause)
    ```sql
    SELECT empno, sal, comm
                                            -- ROWS: 정렬 값이 고유하지 않으면 결과가 변경될 수 있으므로 고유한 정렬 값 지정 필요
                                            -- 따라서, ORDER BY절에 PK값인 empno가 포함됨
         , MIN(comm) OVER (ORDER BY sal, empno ROWS UNBOUNDED PRECEDING) AS c1
    FROM   emp
    WHERE  deptno = 30
    ORDER BY 2, 1;
    ```
  * MAX
    * MAX (expr) OVER (analytic_clause)
    ```sql
    -- RANGE UNBOUNDED PRECEDING 방식
    SELECT empno, sal, comm, MAX(comm) OVER (ORDER BY sal) AS c1
    FROM   emp
    WHERE  deptno = 30
    ORDER BY 2, 1;
    ```
  * SUM
    * SUM([DISTINCT | ALL] expr) OVER (analytic_clause)
    ```sql
    SELECT empno, sal
         , SUM(sal) OVER () AS c1
         , SUM(sal) OVER (ORDER BY sal, empno) AS c2
         , EXP(SUM(LN(sal)) OVER (ORDER BY sal, empno)) AS c3
    FROM   emp
    WHERE  deptno = 30
    ORDER BY 2, 1;
    ```
  * AVG
    * AVG([DISTINCT | ALL] expr) OVER (analytic_clause)
    ```sql
    SELECT empno, ename, sal
         , AVG (sal) OVER (ORDER BY sal, empno ROWS BETWEEN 1 PRECEDING
                                                        AND 1 FOLLOWING) AS c1
         , COUNT(*) OVER (ORDER BY sal, empno ROWS BETWEEN 1 PRECEDING
                                                       AND 1 FOLLOWING) AS c2
    FROM emp
    WHERE deptno = 30
    ORDER BY 3, 1;
    ```
    ```sql
    SELECT empno, ename, sal
         , AVG (sal) OVER (ORDER BY sal RANGE BETWEEN 300 PRECEDING
                                                  AND 300 FOLLOWING) AS c1
         , COUNT(*) OVER (ORDER BY sal  RANGE BETWEEN 300 PRECEDING
                                                  AND 300 FOLLOWING) AS c2
    FROM emp
    WHERE deptno = 30
    ORDER BY 3, 1;
    ```
    ```sql
    CREATE TABLE t1 AS
    SELECT dt, ROWNUM * 100 AS vl
    FROM (SELECT DATE '2050-01-01' + ROWNUM - 1 AS dt FROM XMLTABLE ('1 to 31'))
    WHERE TO_CHAR (dt, 'D') NOT IN ('1', '7');
    
    SELECT dt, vl
         -- ROWS: 영업일 기준 (10 영업일)
         , AVG(vl) OVER (ORDER BY dt ROWS 9 PRECEDING) AS c1
         -- RANGE: 캘린더 기준 (10일)
         , AVG(vl) OVER (ORDER BY dt RANGE 9 PRECEDING) AS c2
    FROM   t1
    ORDER BY 1;
    ```
* 통계함수
  * STDDEV
    * STDDEV([DISTINCT | ALL] expr) OVER (analytic_clause)
    ```sql
    SELECT   job, sal, STDDEV (sal) OVER (PARTITION BY job) AS c1
    FROM     emp
    WHERE    deptno = 30
    ORDER BY 2, 1;
    ```
  * VARIANCE
    * VARIANCE([DISTINCT | ALL] expr) OVER (analytic_clause)
    ```sql
    SELECT   job, sal, VARIANCE (sal) OVER (PARTITION BY job) AS c1
    FROM     emp
    WHERE    deptno = 30
    ORDER BY 2, 1;
    ```
  * STDDEV: 표준펀차
  * STDDEV_POP: 모집단 표준편차
  * STDDEV_SAMP: 누적 표본 표준편차
  * VARIANCE: 분산
  * VAR_POP: 모집단분산
  * VAR_SAMP: 표본분산
  * COVAR_POP: 모집단 공분산
  * COVAR_SAMP: 표본공분산
  * CORR: Pearson’s 상관 계수
  * REGR_*: 선형회귀 (Linear Regression)
* 순위함수
  * RANK
    * RANK() OVER([query_partition_clause] order_by_clause)
    ```sql
    SELECT   empno, ename, sal, RANK () OVER (ORDER BY sal) AS c1
    FROM     emp
    WHERE    deptno = 30
    ORDER BY 3, 1;
    ```
  * DENSE_RANK
    * DENSE_RANK() OVER([query_partition_clause] order_by_clause)
    ```sql
    SELECT   empno, ename, sal, DENSE_RANK () OVER (ORDER BY sal) AS c1
    FROM     emp
    WHERE    deptno = 30
    ORDER BY 3, 1;
    ```
  * ROW_NUMBER
    * ROW_NUMBER() OVER([query_partition_clause] order_by_clause)
    ```sql
    SELECT   empno, ename, sal
             -- sal 값으로만 order by를 하면 동일한 sal을 가진 행들 간에 row_number 값이 변경될 수 있다
           , ROW_NUMBER () OVER (ORDER BY sal) AS c1
             -- 따라서, sal과 empno로 order by를 해서 식별값을 추가해서 사용하는 것이 좋다
           , ROW_NUMBER () OVER (ORDER BY sal, empno) AS c2
    FROM     emp
    WHERE    deptno = 30
    ORDER BY 3, 1;
    ```
    ```sql
    -- 부서별로 가장 최근에 입사한 사원을 반환한다
    SELECT empno, ename, sal, deptno
    FROM (SELECT a.*
               , ROW_NUMBER () OVER (PARTITION BY deptno
                                     ORDER BY hiredate DESC, empno DESC) AS rn
          FROM emp a)
    WHERE rn = 1;
    ```
    ```sql
    SELECT   empno, ename, sal
           , ROW_NUMBER () OVER (ORDER BY sal) AS c1
           , RANK () OVER (ORDER BY sal) AS c2
           , DENSE_RANK () OVER (ORDER BY sal) AS c3
    FROM     emp
    WHERE    deptno = 30
    ORDER BY 3, 1;
    ```
  * NTILE
    * NTILE(expr) OVER([query_partition_clause] order_by_clause)
    ```sql
    SELECT   sal
           , NTILE (1) OVER (ORDER BY sal) AS c1, NTILE (2) OVER (ORDER BY sal) AS c2
           , NTILE (3) OVER (ORDER BY sal) AS c3, NTILE (4) OVER (ORDER BY sal) AS c4
           , NTILE (5) OVER (ORDER BY sal) AS c5, NTILE (6) OVER (ORDER BY sal) AS c6
           , NTILE (7) OVER (ORDER BY sal) AS c7
    FROM     emp
    WHERE    deptno = 30
    ORDER BY 3, 1;
    ```
    ```sql
    -- NTILE: 순차적
    SELECT    c1, COUNT (*) AS c2, SUM (sal) AS c3
    FROM     (SELECT sal, NTILE (4) OVER (ORDER BY sal) AS c1 FROM emp WHERE deptno = 30)
    GROUP BY c1
    ORDER BY c1;
    ```
    ```sql
    -- MOD: 순환적
    SELECT   c1, COUNT (*) AS c2, SUM (sal) AS c3
    FROM     (SELECT sal, MOD(ROW_NUMBER (4) OVER (ORDER BY sal, empno), 4) AS c1 FROM emp WHERE deptno = 30)
    GROUP BY c1
    ORDER BY c1;
    ```
  * CUME_DIST
    * CUME_DIST() OVER([query_partition_clause] order_by_clause)
    ```sql
    -- COUNT: ... OVER(analytic_clause)이기 때문에, RANGE UNBOUNDED PRECEDING으로 Default 세팅된다
    -- 즉, Order By절로 정렬된 상태에서 최선두 값부터 CURRENT_ROW까지 COUNT한다
    SELECT   sal
           , CUME_DIST () OVER (ORDER BY sal) AS c1
           , COUNT (*) OVER (ORDER BY sal) / COUNT (*) OVER () AS c2
    FROM     emp
    WHERE    deptno = 30
    ORDER BY sal;
    ```
  * PERCENT_RANK
    * PERCENT_RANK() OVER([query_partition_clause] order_by_clause)
    ```sql
    SELECT sal
          , PERCENT_RANK() OVER (ORDER BY sal) AS c1
          , (RANK() OVER (ORDER BY sal) - 1 / COUNT(*) OVER (ORDER BY sal) - 1) AS c2
    FROM   emp
    WHERE  deptno = 30
    ORDER BY 1;
    ```
    ```sql
    -- 
    WITH   w1 AS (SELECT LEVEL AS lv FROM DUAL CONNECT BY LEVEL <= 201)
    SELECT *
    FROM (SELECT lv, PERCENT_RANK () OVER (ORDER BY lv) AS c1 FROM w1)
    WHERE lv IN (1, 51 , 101 , 151 , 201);
    ```
  * RATIO_TO_REPORT
    * RATIO_TO_REPORT(expr) OVER([query_partition_clause] order_by_clause)
    ```sql
    SELECT sal
         , RATIO_TO_REPORT (sal) OVER () AS c1
         , sal / SUM (sal) OVER () AS c2
    FROM emp
    WHERE deptno = 30
    ```
* 분포함수
  * PERCENTILE_CONT
    * PERCENTILE_CONT (expr) WITHIHN GROUP (ORDER BY expr [DESC | ASC]) [OVER (query_partition_clause)]
    ```sql
    SELECT   job, ename , sal
           , PERCENTILE_CONT (0.5) WITHIN GROUP (ORDER BY sal) OVER (PARTITION BY job) AS c1
    FROM     emp
    WHERE    deptno = 30
    ORDER BY 1, 3, empno;
    ```
  * PERCENTILE_DIST
    * PERCENTILE_DIST (expr) WITHIHN GROUP (ORDER BY expr [DESC | ASC]) [OVER (query_partition_clause)]
    ```sql
    SELECT   job, ename , sal
           , PERCENTILE_DIST (0.5) WITHIN GROUP (ORDER BY sal) OVER (PARTITION BY job) AS c1
    FROM     emp
    WHERE    deptno = 30
    ORDER BY 1, 3, empno;
    ```
  * MEDIAN
    * MEDIAN (expr) [OVER (query_partition_clause)]
    ```sql
    SELECT job, sal
         , MEDIAN(sal) OVER (PARTITION BY job) AS c1
    FROM   emp
    WHERE  deptno = 30
    ORDER BY 1, 2;
    ```
* 순차 함수
  * FIRST_VALUE
    * FIRST_VALUE (expr) [IGNORE NULLS] OVER (analytic_clause)
    ```sql
    SELECT   job, hiredate, sal
           , FIRST_VALUE (sal) OVER ( PARTITION BY job ORDER BY hiredate ) AS c1
    FROM     emp
    WHERE    deptno = 30
    ORDER BY 1, 2;
    ```
    ```sql
    SELECT sal, comm
         , FIRST_VALUE(comm) OVER (ORDER BY sal) AS c1
         , FIRST_VALUE(comm) IGNORE NULLS OVER (ORDER BY sal) AS c2
         , FIRST_VALUE(comm) IGNORE NULLS OVER (ORDER BY sal RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS c3
    FROM   emp a
    WHERE  deptno = 30
    ORDER BY 1, 2;
    ```
  * LAST_VALUE
    * LAST_VALUE(expr) [IGNORE NULLS] OVER (analytic_clause)
    ```sql
    -- 윈도우 기본값이 RANGE BETWEEN UNBOUNDED PRECEDING이다
    -- 따라서, 보통 LAST_VALUE를 사용할 때, RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING을 사용한다
    SELECT job, hiredate, sal
         , LAST_VALUE(sal) OVER (PARTITION BY job ORDER BY hiredate) AS c1
         , LAST_VALUE(sal) OVER (PARTITION BY job ORDER BY hiredate RANGE BETWEEN CURRENT ROW AND UBOUNDED FOLLOWING) AS c2
    FROM   emp a
    WHERE  deptno = 30
    ORDER BY 1, 2, 3;
    ```
    ```sql
    -- LAST_VALUE는 가독성이 안 좋기 때문에, FIRST_VALUE로 동일 연산을 만드는 것이 좋다
    SELECT job, hiredate, sal
         , FIRST_VALUE(sal) OVER (PARTITION BY job ORDER BY hiredate DESC) AS c1
         , LAST_VALUE(sal) OVER (PARTITION BY job ORDER BY hiredate RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) AS c2
    FROM   emp a
    WHERE  deptno = 30
    ORDER BY job, hiredate DESC;
    ```
  * NTH_VALUE
    * NTH_VALUE (measure_expr, n) [FROM {FIRST | LAST}] [IGNORE NULLS] OVER (analytic_clause)
      * default 세팅
        * FROM FIRST
    ```sql
    SELECT hiredate, sal
         , NTH_VALUE(sal, 1) OVER (ORDER BY hiredate) AS c1
         , NTH_VALUE(sal, 3) OVER (ORDER BY hiredate) AS c2
    FROM   emp
    WHERE  deptno = 30
    ORDER BY hiredate;
    ```
    ```sql
    -- FROM LAST는 가독성이 안 좋기 때문에, FROM FIRST 연산으로 치환해서 사용하는 것이 좋다
    SELECT hiredate, sal
         , NTH_VALUE(sal, 3) FROM LAST OVER (ORDER BY hiredate RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) AS c1
         , NTH_VALUE(sal, 3) OVER (ORDER BY hiredate DESC) AS c2
    FROM   emp
    WHERE  deptno = 30
    ORDER BY 1;
    ```
* 기타 함수
  * LAG
    * LAG (value_expr [, offset [, default]]) [IGNORE NULLS] OVER ([query_partition_clause] order_by_clause)
      * default 세팅
        * offset:1
        * default:null
    ```sql
    SELECT hiredate, sal
         , LAG(sal) OVER (ORDER BY hiredate) AS c1
         , LAG(sal, 3) OVER (ORDER BY hiredate) AS c2
    FROM   emp
    WHERE  deptno = 30
    ORDER BY 1;
    ```
    ```sql
    -- IGNORE NULLS: 의미가 offset 카운팅에 포함하지 않겠다는 것이다
    SELECT ename, hiredate, comm
           -- IGNORE NULLS로 인해, NULL 값들이 보일 때마다 더 위쪽으로 조회한다
         , LAG(comm, 2, 999) IGNORE NULLS OVER (ORDER BY hiredate) AS c1
    FROM   emp
    WHERE  deptno = 30
    ORDER BY 2;
    ```
    ```sql
    -- 만약 계속 NULL 값인데 IGNORE NULLS면, offset은 1이라도 계속 선행 행을 찾게 된다
    SELECT sal, comm
         , NVL(comm, LAG (comm) IGNORE NULLS OVER (ORDER BY sal, empno)) AS comm_n
    FROM   emp
    WHERE  deptno IN (10, 30)
    ORDER BY sal, empno;
    ```
    ```sql
    -- 직전 데이터 대비 증감률 계산
    SELECT hiredate, sal, sal / LAG( sal, 1, sal ) OVER ( ORDER BY hiredate ) AS c1
    FROM   emp
    WHERE  deptno = 30
    ORDER BY hiredate;
    ```
  * LEAD
    * LEAD (value_expr [, offset [, default]]) [IGNORE NULLS] OVER ([query_partition_clause] order_by_clause)
    ```sql
    SELECT hiredate, sal
         , LEAD (sal)    OVER (ORDER BY hiredate) AS c1
         , LEAD (sal, 3) OVER (ORDER BY hiredate) AS c2
    FROM   emp
    WHERE  deptno = 30
    ORDER BY hiredate;
    ```
    ```sql
    -- FIRST_VALUE와 LAST_VALUE처럼 LAG와 LEAD도 ORDER BY 순서를 반대로 하면 동일 결과를 받을 수 있다
    SELECT hiredate, sal
           -- 다만, 논리적으로 생각했을 때, LAG와 LEAD 함수는 오름차순으로 해석하는 것이 편하기 때문에, DESC보다는 ASC로 고정하여 사용하는 것이 좋다
         , LAG (sal) OVER (ORDER BY hiredate DESC) AS c1
         , LEAD(sal) OVER (ORDER BY hiredate) AS c2
    FROM   emp
    WHERE  deptno = 30
    ORDER BY hiredate;
    ```
    ```sql
    -- BAD(행 기준으로 동작하기 때문에 분석 함수의 정렬 값이 고유하지 않으면 값이 무작위로 변경될 수 있다)
    SELECT empno, ename, sal, comm
         , LEAD(comm) OVER (ORDER BY sal) AS c1
    FROM   emp
    WHERE  deptno = 30
    ORDER BY 3, 1;

    -- BAD(행 기준으로 동작하기 때문에 분석 함수의 정렬 값이 고유하지 않으면 값이 무작위로 변경될 수 있다)
    SELECT empno, ename, sal, comm
         , LEAD(comm) OVER (ORDER BY sal) AS c1
    FROM   emp
    WHERE  deptno = 30
    ORDER BY 3, 2;

    -- GOOD(empno 식별값을 포함하므로, 정렬 값이 고유하다)
    SELECT empno, ename, sal, comm
         , LEAD(comm) OVER (ORDER BY sal, empno) AS c1
    FROM   emp
    WHERE  deptno = 30
    ORDER BY 3, 1;
    
    -- GOOD(empno 식별값을 포함하므로, 정렬 값이 고유하다)
    SELECT empno, ename, sal, comm
         , LEAD(comm) OVER (ORDER BY sal, empno) AS c1
    FROM   emp
    WHERE  deptno = 30
    ORDER BY 3, 2;
    ```
  * LISTAGG
    * LISTAGG (measure_expr [, 'delimiter'] [listagg_overflow_clause]) WITHIN GROUP (order_by_clause) [OVER query_partition_clause]
    ```sql
    -- LISTAGG 함수는 원도우 함수가 아니기 때문에 문자열을 누적하여 결합할 수 없다
    SEELCT job, ename
          , LISTAGG(ename, ',') WITHIN GROUP (ORDER BY ename) OVER (PARTITION BY job) AS c1
    FROM   emp
    WHERE  deptno = 30
    ORDER BY jobn, ename;
    ```

<br>

### 활용 예제
* 선분 이력 전환#1 - 점 이력을 선분 이력으로 전환
  * 시작일자만 있는 경우, 후행 시작일자 - 1로 현재 행의 EN_DT를 만들어 준다
  ```sql
  CREATE TABLE t1(cd VARCHAR2(1), dt DATE, vl NUMBER);
  
  SELECT   cd, dt AS bg_dt
           --OFFSET 1만큼 선이동 후 해당 행의 dt 값에 -1 연산을 하고, 만약 결과값이 NULL이면 DATE '9999-12-31' 값이 사용된다
         , LEAD(dt - 1, 1, DATE '9999-12-31') OVER (ORDER BY dt) AS ed_dt, vl
  FROM     t1
  ORDER BY 1, 2;
  ```
* 선분 이력 전환#2 - 월별 이력을 선분 이력으로 전환
  * GROUP BY절을 통해, r1 - r2 결과값이 동일한 행들끼리 행 그룹이 생성된다
    * ROW_NUMBER를 활용한 순번의 차를 이용하여 행그룹을 구분되어 질 수 있게 되었다
  ```sql
  CREATE TABLE t1(cd VARCHAR2(1), ym VARCHAR2(6), vl NUMBER);
  
  -- 그룹핑을 위한 vl 칼럼을 테이블에 만들어서 활용할 수도 있고, ROW_NUMBER 함수를 사용하여 r1, r2 값을 만들어서 활용할 수 있다는 점이 주요한 것 같다
  SELECT cd, MIN (ym) AS bg_ym
       , CASE WHEN MAX (r1) = MAX (cn) THEN '999912' ELSE MAX (ym) END AS ed_ym, vl
  FROM   (SELECT a.*
               , COUNT(*) OVER (PARTITION BY a.cd) AS cn
               , ROW_NUMBER () OVER (PARTITION BY a.cd ORDER BY a.ym) AS r1
               , ROW_NUMBER () OVER (PARTITION BY a.cd, a.vl ORDER BY a.ym) AS r2
          FROM   t1 a)
  GROUP BY cd, vl, r1 - r2
  ORDER BY 1, 2;
  ```
* 선분 이력 병합
  * 동일하게, ROW_NUMBER로 행그룹을 구분지었지만, 특정 그룹만 병합되도록 이번에는 yn 칼럼을 활용했다
  ```sql
  CREATE TABLE t1(cd VARCHAR2(1), bg NUMBER, ed NUMBER, yn VARCHAR2(1));
  
  SELECT cd, MIN (bg) AS bg, MAX (ed) AS ed, yn
  FROM   (SELECT a.*
               , ROW_NUMBER() OVER (PARTITION BY cd ORDER BY bg)     AS r1
               , ROW_NUMBER() OVER (PARTITION BY cd, yn ORDER BY bg) AS r2
          FROM   t1 a)
  GROUP BY cd, yn, CASE WHEN yn = 'N' THEN r1 - r2 ELSE r1 END
  ORDER BY 1, 2;
  ```
* 행 패턴 검색
  * ROW_NUMBER를 활용한 순번의 차를 이용하여 행의 패턴 검색 가능
  ```sql
  WITH w1 AS (
      SELECT a.*
           , NVL( SIGN( vl - LAG (vl) OVER (PARTITION BY cd ORDER BY dt)), 0) AS df
      FROM   t1 a
  )

  SELECT a.*
       , ROW_NUMBER() OVER (PARTITION BY cd ORDER BY dt)     AS r1
       , ROW_NUMBER() OVER (PARTITION BY cd, df ORDER BY dt) AS r2
  FROM   w1 a
  ORDER BY 1, 2;
  ```
* 선형 보간 (Linear Interpolation)
  * 두 지점 사이의 값을 두 지점의 직선 거리에 따라 선형적으로 결정하는 방법
    * 행 복제 기법을 사용하여 데이터가 존재하지 않는 구간의 행을 생성하고, LEAD함수를 사용하여 보간 값을 계산해서 채운다
  ```sql
  SELECT a.dt + b.lv - 1 AS dt
       , ROUND(a.vl + (a.vl_df / a.dn) * (b.lv - 1), 2) AS vl
  FROM  (SELECT a.*,
                NVL( LEAD(a.vl) OVER (ORDER BY a.dt) - a.vl, 0) AS vl_df,
                NVL( LEAD(a.dt) OVER (ORDER BY a.dt) - a.dt, 1) AS dn
         FROM   t1 a) a,
         (SELECT LEVEL AS lv FROM DUAL CONNECT BY LEVEL <= 10) b
  WHERE  b.lv <= a.dn
  ORDER BY 1;
  ```

<br>
<hr>
<br>

## TOP-N 쿼리
#### 상위(Top) N개의 행을 조회하는 쿼리

<br>

### 기본문법
* ROWNUM 방식
  * COUNT STOPKEY 오퍼레이션) ORDER BY 절로 행을 정렬하고， 정렬된 행을 ROWNUM 슈도 칼럼으로 제한한다
  ```sql
  SELECT empno, sal, ROWNUM AS rn
  FROM (SELECT empno, sal FROM emp ORDER BY sal, empno)
  WHERE ROWNUM <= 5;
  ```
  ```sql
  -- v_pr: 페이지 사이즈
  -- v_pn: 특정 페이지
  SELECT empno, sal, rn
  FROM (SELECT empno, sal, ROWNUM AS rn
          FROM (SELECT empno, sal FROM emp ORDER BY sal, empno)
         WHERE ROWNUM <= :v_pr * :v_pn)
  WHERE rn >= (:v_pr * (:v_pn - 1)) + 1;

  -- BAD: BETWEEN절로도 동일한 결과를 만들 수 있다
  -- 다만, ROWNUM 슈도 칼럼을 WHERE 절에 직접 기술하지 않으면 COUNT STOPKEY 오퍼레이션이 동작하지 않을 수 있기 때문에 쿼리 성능 저하 발생 가능
  SELECT  empno, sal, rn
  FROM   (SELECT empno, sal, ROWNUM AS rn
            FROM (SELECT empno, sal FROM emp ORDER BY sal, empno))
  WHERE   rn BETWEEN (:v_pr * (:v_pn - 1)) + AND :v_pr * :v_pn;
  ```
  ```sql
  -- BAD: ROWNUM이 중첩 서브 쿼리에 포함되면 쿼리 변환 (Query Transformation)에 제한이 생겨 쿼리 성능 저하 발생 가능
  SELECT a.*
  FROM   dept a
  WHERE  EXISTS (SELECT 1
                 FROM   emp x
                 WHERE  x.deptno = a.deptno
                   AND  ROWNUM <= 1);
  ```
* 분석 함수 방식
  * WINDOW SORT PUSHED RANK 오퍼레이션) 
  ```sql
  SELECT *
  FROM (SELECT empno, sal
             , ROW_NUMBER () OVER (ORDER BY sal, empno) AS rn
        FROM emp)
  WHERE rn <= 5
  ORDER BY sal, empno;
  ```
  ```sql
  SELECT *
  FROM  (SELECT empno, sal
              , ROW_NUMBER() OVER (ORDER BY sal, empno) AS rn
         FROM   emp)
  WHERE  rn BETWEEN (:v_pr * (:v_pn - 1)) + 1 AND :v_pr * :v_pn
  ORDER BY sal, empno;
  ```
  ```sql
  -- 전체 건수를 조회하는 방안
  SELECT empno, sal , rn , cn
  FROM   (SELECT empno, sal
               , COUNT (*) OVER () AS cn
               , ROW_NUMBER () OVER (ORDER BY sal , empno) AS rn
            FROM emp)
  WHERE CEIL (rn / :v_pr) = :v_pn
  ORDER BY sal, empno;
  ```
  ```sql
  -- 상위 25%
  SELECT *
  FROM  (SELECT empno, sal
              , PERCENT_RANK() OVER (ORDER BY sal, empno) AS pr
         FROM   emp)
  WHERE  pr <= 0.25
  ORDER BY sal, empno;

  -- 6순위 
  SELECT empno, sal, rk
  FROM  (SELECT empno, sal
              , RANK() OVER (ORDER BY sal, empno) AS rk
         FROM   emp)
  WHERE  rk <= 6
  ORDER BY sal, empno;

  -- 6순위 
  SELECT empno, sal, dr
  FROM  (SELECT empno, sal
              , DENSE_RANK() OVER (ORDER BY sal, empno) AS dr
         FROM   emp)
  WHERE  dr <= 6
  ORDER BY sal, empno;
  ```
* Row Limiting절
  * [OFFSET offset {ROW | ROWS}] [FETCH {FIRST | NEXT} [{rowcount | percent PERCENT}] {ROW | ROWS} {ONLY | WITH TIES}]
    * OFFSET offset: 건너뛸 행의 개수
    * FETCH: 반환할 행의 개수나 백분율
    * ONLY: 지정된 행의 개수나 백분율만큼 행 반환
    * WITH TIES: 마지막 행에 대한 동순위를 포함해서 반환
  ```sql
  SELECT empno, sal FROM emp ORDER BY sal, empno FETCH FIRST 5 ROWS ONLY;
  ```
  ```sql
  SELECT empno, sal
  FROM   emp
  ORDER BY sal, empno
  OFFSET :v_pr * (:v_pn - 1) ROWS FETCH NEXT :v_pr ROWS ONlY;
  ```
  ```sql
  SELECT empno, sal FROM emp ORDER BY sal, empno OFFSET 5 ROWS;
  ```
  ```sql
  SELECT empno, sal FROM emp ORDER BY sal, empno FETCH FIRST 25 PERCENT ROWS ONLY;
  ```
  ```sql
  -- RANK 분석 함수와 동일한 결과
  SELECT empno, sal FROM emp ORDER BY sal FETCH FIRST 6 ROWS WITH TIES;
  ```

<br>

### 고급 주제
* Top-N 쿼리와 조인
  * 가능하다면, Top-N 쿼리 수행 후 조인을 해야지 조인 횟수를 줄일 수 있다
  * 다만, 조건절에 따라서 논리적으로 조인을 수행한 이후의 결과집합에 Top-N 쿼리를 수행하는게 올바르다면 그렇게 진행하는 것이 옳다
* Top-N 쿼리와 UNION ALL 연산자
  * UNION ALL 수행시 정렬이 수행되기 때문에 테이블 크기가 크면 연산이 많아진다
  * 따라서, UNION ALL 수행 전에 Order By 후 Top-N 쿼리를 각 테이블에 수행한 이후에 concat하는 방안도 가능하다

<br>
<hr>
<br>

## 계층 쿼리 (Hierarchical Query)
#### 순환(Recursive) 관계를 가진 데이터 조회 가능

<br>

### 계층 쿼리 절 (Hierarchical Query Clause)
* 기본 문법
  * [START WITH condition] CONNECT BY [NOCYCLE] condition
    * START WITH: 루트 노드를 생성하며 1번만 수행
    * CONNECT BY절: 루트 노드의 하위 노드를 생성하며 조회 결과가 없을 때까지 반복 수행
* 유형
  * 연산자
    * PRIOR: 직전 상위 노드의 값 반환
    * CONNECT_BY_ROOT: 루트 노드의 값을 반환
  * 슈도 칼럼
    * LEVEL: 현재 레벨을 반환
    * CONNECT_BY_ISLEAF: 리프 노드인 경우 1, 아니면 0을 반환
    * CONNECT_BY_ISCYCLE: 루프가 발생한 경우 1, 아니면 0을 반환
  * 함수
    * SYS_CONNECT_BY_PATH: 루트 노드에서 현재 노드까지의 경로를 반환
  ```sql
  SELECT     LEVEL AS lv, empno, LPAD(' ', LEVEL - 1, ' ') || ename AS ename, mgr
           , PRIOR empno AS empno_p
  FROM       emp
  START WITH mgr IS NULL
  CONNECT BY mgr = PRIOR empno;
  ```
* SYS_CONNECT_BY_PATH
  * SYS_CONNECT_BY_PATH(column, char)
  ```sql
  SELECT LEVEL AS lv, empno, LPAD(' ', LEVEL - 1, ' ') || ename AS ename, mgr
       , CONNECT_BY_ROOT ename AS rt
       , CONNECT_BY_ISLEAF AS lf
       , SYS_CONNECT_BY_PATH(ename, ',') AS PT
  FROM   emp
  START WITH mgr IS NULL
  CONNECT BY mgr = PRIOR empno;
  ```
* 동작원리
  * START WITH 절로 루트 노드를 생성한 후, 결과가 없을 때까지 CONNECT 절을 반복 수행하여 하위 노드를 생성한다
  * 전개 방향
    * 순환 관계는 순방향 또는 역방향 가능
      * 순방향: 부모 -> 자식
      * 역방향: 자식 -> 부모
    * 순방향 
    ```sql
    SELECT LEVEL AS lv, empno, LPAD(' ', LEVEL - 1, ' ') || ename AS ename, mgr
    FROM   emp
    -- 부모 노드부터
    START WITH mgr IS NULL
    -- PRIOR은 부모 노드부터
    CONNECT BY mgr = PRIOR empno;
    ```
    * 역방향
    ```sql
    SELECT LEVEL AS lv, empno, LPAD(' ', LEVEL - 1, ' ') || ename AS ename, mgr
    FROM   emp
    -- 자식 노드부터
    START WITH ename = 'ADAMS'
    -- PRIOR은 자식 노드부터 시작
    CONNECT BY empno = PRIOR mgr;
    ```
* 계층 정렬
  * 형제 노드의 정렬을 위해 SIBLINGS 키워드를 제공한다
    * ORDER BY: 계층 구조와 상관없이 행 전체가 정렬된다
    * ORDER SIBLINGS BY: 계층 구조를 유지한 채로 형제 노드 내에서만 행이 정렬된다
* 루프 처리
  * 상위 노드가 자신의 자식 노드가 되는 경우 CYCLE이 발생한다
  ```sql
  SELECT LEVEL AS lv, empno, LPAD(' ', LEVEL - 1, ' ') || ename AS ename, mgr
       , CONNECT_BY_ISCYCLE AS ic
  FROM   emp_l
  START WITH empno = 7839
  -- NOCYCLE: 루프가 발생하는 노드는 전개하지 않는다
  CONNECT BY NOCYCLE mgr = PRIOR empno;
  ```

<br>

### 재귀 서브 쿼리 팩토링 (Recursive Subquery Refactoring)
* 기본 문법
  * WITH query_name ([c_alias [, c_alias]...]) AS (subquery) [search_clause] [cycle_clause]
  * 정방향
  ```sql
  WITH w1 (empno, ename, mgr, lv) AS (
       SELECT empno, ename, mgr, 1 AS lv
       FROM   emp   
       WHERE  mgr IS NULL --START WITH절
       UNION ALL
       SELECT c.empno, c.ename, c.mgr, p.lv + 1 AS lv
       FROM   w1 p, emp c
       WHERE  c.mgr = p.empno --CONNECT BY절
  ) 
  SELECT lv, empno, LPAD(' ', lv - 1, ' ') || ename AS ename, mgr 
  FROM w1;
  ```
  * 역방향
  ```sql
  WITH w1 (empno, ename, mgr, lv) AS (
       SELECT empno, ename, mgr, 1 AS lv
       FROM   emp   
       WHERE  empno = 'ADAMS' --START WITH절
       UNION  ALL
       SELECT c.empno, c.ename, c.mgr, p.lv + 1 AS lv
       FROM   w1 p, emp c
       WHERE  c.empno = p.mgr --CONNECT BY절
  ) 
  SELECT lv, empno, LPAD(' ', lv - 1, ' ') || ename AS ename, mgr 
  FROM w1;
  ```
* 계층 정렬
  * SEARCH {DEPTH|BREATH} FIRST BY c_alias, [, c_alias]... SET ordering_column
    * BREATH: 자식 행을 반환하기 전에 형제 행을 반환 (기본값)
    * DEPTH: 형제 행을 반환하기 전에 자식 행을 반환 (=계층 쿼리절)
* 루프 처리
  * CYCLE c_alias [, c_alias]... SET cycle_mark_c_alias TO cycle_value DEFAULT no_cycle_value
    * alias [, c_alias]: 루프 여부를 확인할 열
    * cycle_mark_c_alias: 루프 여부를 반환할 열
    * cycle_value: 루프가 발생한 경우 반환할 값
    * no_cycle_value: 루프가 발생하지 않응 경우 반환할 값

<br>
  
### 고급 주제
* 노드 제거
  * CONNECT BY 절에 조건을 기술하면 조건을 만족하지 않는 노드 제거 가능
    * 만족하지 않는 노드와 그 노드의 하위 노드들 모두 제거된다
  ```sql
  SELECT LEVEL AS lv, empno, LPAD(' ', LEVEL - 1, ' ') || ename AS ename, mgr
  FROM   emp
  START WITH mgr 15 NULL
  CONNECT BY mgr = PRIOR empno
         AND empno <> 7698;
  ```
  * WHERE 절에 조건을 기술하면 조건을 만족하지 않는 노드 제거 가능
    * 만족하지 않는 노드만 제거된다
      * CONNECT BY절 수행 후 WHERE절이 수행되기 때문
  ```sql
  SELECT LEVEL AS lv, empno, LPAD(' ', LEVEL - 1, ' ') || ename AS ename, mgr
  FROM   emp
  WHERE  empno <> 7698
  START WITH mgr 15 NULL
  CONNECT BY mgr = PRIOR empno;
  ```
* 다중 루트 노드
  * 순방향
  ```sql
  SELECT LEVEL AS lv, empno, LPAD (' ', LEVEL - 1, ' ') || ename AS ename, mgr
  FROM emp
  START WITH job = 'MANAGER'
  CONNECT BY mgr = PRIOR empno;
  ```
  * 역방향
  ```sql
  SELECT LEVEL AS lv, a.empno, LPAD (' ', LEVEL - 1, ' ') || a.ename AS ename, a.mgr
  FROM emp a
  START WITH a.deptno = 20
  AND NOT EXISTS (SELECT 1 FROM emp x WHERE x.mgr = a.empno)
  CONNECT BY a.empno = PRIOR a.mgr;
  ```
* 다중 속성 순환 관계
  * 다중 속성이기 때문에, 다중 속성들을 START WITH에만 명시하는게 아니라, CONNECT BY절에도 명싱해줘야 한다
  ```sql
  -- GOOD
  -- compno > pcompno && mgr > empno 이렇게 매핑이 되서 의도한 데이터들끼리 연결된다
  SELECT LEVEL AS lv, compno, empno, LPAD (' ', LEVEL - 1, ' ') || ename AS ename, mgr, pcompno
  FROM emp_c
  START WITH compno = 1
         AND mgr IS NULL
  CONNECT BY pcompno = PRIOR compno
         AND mgr     = PRIOR empno;

  -- BAD
  -- CONNECT BY절에 compno > pcompno 연결이 끊기면서 1이 아닌 pcompno라도 mgr과 empno만 동일하면 연결되어 버린다
  SELECT LEVEL AS lv, compno, empno, LPAD (' ', LEVEL - 1, ' ') || ename AS ename, mgr, pcompno
  FROM emp_c
  START WITH compno = 1
         AND mgr IS NULL
  CONNECT BY mgr     = PRIOR empno;
  ```
* 계층 쿼리와 조인
  * 

<br>

### 활용 예제
* 

<br>
<hr>
<br>
