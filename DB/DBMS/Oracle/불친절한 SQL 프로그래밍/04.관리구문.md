## 관리구문
> 
* 

<hr>
<br>

## DML 문 (Data Manipulation Language)
#### INSERT/UPDATE/DELETE/MERGE

<br>

### INSERT 문
* 단일 테이블 INSERT 문
  * VALUES 절: 단일 행 삽입
  ```sql
  INSERT INTO {table | view | subquery} [t_alias] [(column [, column]...)]
       VALUES ({expr | DEFAULT} [, {expr | DEFAULT}]...)
  ```
  ```sql
  CREATE TABLE t1 (empno NUMBER(4), ename VARCHAR2(10), deptno NUMBER(2) DEFAULT 20);
  
  -- INTO/VALUES절에 지정되지 않은 열: 기본값이 었으면 기본값; 없으면, NULL 삽입
  INSERT INTO t1 (empno, ename, deptno) VALUES (7369, 'SMITH' , 20);
  
  -- INTO절에 열을 지정하지 않으면, VALUES절에 전체 열의 값 기술 필요
  INSERT INTO t1 VALUES (7788, 'SCOTT' , 20);
  
  -- DEFAULT 값이 설정되어 있는 열에는 DEFAULT 키워드 사용 가능
  INSERT INTO t1 VALUES (7876, 'ADAMS' , DEFAULT);
  
  -- 열을 추가하면 상단에서 INTO절에 열을 지정하지 않아서 VALUES절에 전체 열을 기술해야 했던 모든 쿼리에서 에러가 발생한다
  -- 따라서, 하단의 쿼리처럼 INTO절에 열을 지정하는 방식이 쿼리의 안정성 측면에서 바람직하다
  ALTER TABLE t1 ADD job VARCHAR2(9);
  INSERT INTO t1 (empno, ename, deptno) VALUES (7902, 'FORD' , 20);
  ```
  * 서브 쿼리: 서브 쿼리의 결과 삽입
  ```sql
  INSERT INTO {table | view | subquery} [t_alias] [(column [, column]...)]
  subquery
  ```
  ```sql
  -- 서브쿼리 결과가 다중행이면 다중행이 INSERT된다
  INSERT INTO t1 (empno, ename)
  SELECT empno, ename FROM emp WHERE job = 'ANALYST';

  -- 서브쿼리에 UNION ALL 연산자를 사용하면 여러 태이블의 행 삽입 가능
  INSERT INTO t1 (empno, ename)
  SELECT empno, ename  FROM emp  WHERE job = 'PRESIDENT'
  UNION ALL
  SELECT deptno, dname FROM dept WHERE deptno = 10;
  ```
* 다중 테이블 INSERT 문
  * 무조건 INSERT 문: 모든 테이블에 서브 쿼리 결과 삽입
  ```sql
  INSERT ALL {INTO table [(column [, column]...] [VALUES ({expr | DEFAULT} [, {expr | DEFAULT}]...)]}...
  subquery
  ```
  ```sql
  CREATE TABLE t1 (empno NUMBER(4), job VARCHAR2(9));
  CREATE TABLE t2 (empno NUMBER(4), mgr NUMBER(4)  );

  -- t1, t2 테이블 각각에 행3개씩 INSERT
  INSERT ALL
         INTO   t1 (empno, job) VALUES (empno, job)
         INTO   t2 (empno, mgr) VALUES (empno, mgr)
  SELECT * FROM emp WHERE deptno = 10;

  -- PIVOT INSERT문: 서브 쿼리의 1행이 t1 테이블에 4번 삽입된다
  CREATE TABLE t1 (deptno NUMBER(2), tp VARCHAR2(3), sal NUMBER(7,2));
  
  INSERT ALL
         INTO t1 VALUES (deptno, 'MIN', sal_min)
         INTO t1 VALUES (deptno, 'MAX', sal_max)
         INTO t1 VALUES (deptno, 'SUM', sal_sum)
         INTO t1 VALUES (deptno, 'AVG', sal_avg)
  SELECT deptno
       , MIN (sal) AS sal_min
       , MAX (sal) AS sal_max
       , SUM (sal) AS sal_sum
       , AVG (sal) AS sal_avg
  FROM  emp
  GROUP BY deptno;
  ```
* 조건부 INSERT 문: 조건을 만족하는 테이블에 서브 쿼리 결과 삽입
  * ALL: 조건을 만족하는 모든 테이블에 행 삽입
  * FIRST: 조건을 만족하는 첫 번째 테이블에 행 삽입
  ```sql
  INSERT [ALL | FIRST]
    WHEN condition THEN
    INTO table [(column [, column]...)] [VALUES ({expr | DEFAULT} [, {expr | DEFAULT}]...)]
   [WHEN condition THEN
    INTO table [(column [, column]...)] [VALUES ({expr | DEFAULT} [, {expr | DEFAULT}]...)]
   [ELSE
    INTO table [(column [, column]...)] [VALUES ({expr | DEFAULT} [, {expr | DEFAULT}]...)]
  subquery
  ```
  ```sql
  CREATE TABLE t1 AS SELECT empno, ename, sal FROM emp WHERE 0 = 1;
  CREATE TABLE t2 AS SELECT * FROM t1;
  CREATE TABLE t3 AS SELECT * FROM t1;

  -- 조건을 만족하는 모든 테이블에 삽입
  INSERT ALL
        WHEN sal >= 2000 THEN INTO t1
        WHEN sal >= 3000 THEN INTO t2
        ELSE INTO t3
  SELECT empno, ename , sal FROM emp WHERE deptno = 10;

  -- 조건을 만족하는 첫번째 테이블에 삽입
  INSERT FIRST
          WHEN sal >= 2000 THEN INTO t1
          WHEN sal >= 3000 THEN INTO t2
          ELSE INTO t3
  SELECT empno, ename , sal FROM emp WHERE deptno = 10;
  ```

<br>

### UPDATE 문 
* 기본 문법
  ```sql
  UPDATE {table | view | subquery} [t_alias]
     SET {column = {expr | (subquery) | DEFAULT} | (column [, column]...) = (subquery)}
      [, {column = {expr | (subquery) | DEFAULT} | (column [, column]...) = (subquery)}]...
  WHERE condition;
  ```
* t1(deptno):t2(empno)=1:M 비식별 관계
  ```sql
  CREATE TABLE t1 AS SELECT deptno, dname, 0 AS sal, 0 AS comm FROM dept;
  CREATE TABLE t2 AS SELECT empno, ename, sal, comm, deptno    FROM emp;

  ALTER TABLE t1 ADD CONSTRAINT t1_pk PRIMARY KEY (deptno);
  ALTER TABLE t2 ADD CONSTRAINT t2_pk PRIMARY KEY (empno);
  ALTER TABLE t2 ADD CONSTRAINT t2_f1 FOREIGN KEY (deptno) REFERENCES t1 (deptno);
  
  UPDATE t1 SET sal = 10000, comm = 1000 WHERE deptno = 40;
  ```
* 다중 열 서브 쿼리
  ```sql
  UPDATE t1 a
     SET (a.sal, a.comm) =
         (SELECT SUM (x.sal), SUM (x.comm) FROM t2 x WHERE x.deptno = a.deptno);
  ```

<br>
<hr>
<br>

## TCS 문
#### 

<br>

### 

<br>
<hr>
<br>

## DDL 문
#### 

<br>

### 

<br>
<hr>
<br>

## DML문
#### 

<br>

### 

<br>
<hr>
<br>

## DCL 문
#### 

<br>

### 

<br>
<hr>
<br>

## SCS 문
#### 

<br>

### 

<br>
<hr>
<br>
