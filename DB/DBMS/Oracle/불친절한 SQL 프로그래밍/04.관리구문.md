## 관리구문
> 
* 

<hr>
<br>

## DML 문 (Data Manipulation Language)
#### INSERT/UPDATE/DELETE/MERGE

<br>

### INSERT 문
* 단일 테이블 INSERT 문
  * VALUES 절: 단일 행 삽입
  ```sql
  INSERT INTO {table | view | subquery} [t_alias] [(column [, column]...)]
       VALUES ({expr | DEFAULT} [, {expr | DEFAULT}]...)
  ```
  ```sql
  CREATE TABLE t1 (empno NUMBER(4), ename VARCHAR2(10), deptno NUMBER(2) DEFAULT 20);
  
  -- INTO/VALUES절에 지정되지 않은 열: 기본값이 었으면 기본값; 없으면, NULL 삽입
  INSERT INTO t1 (empno, ename, deptno) VALUES (7369, 'SMITH' , 20);
  
  -- INTO절에 열을 지정하지 않으면, VALUES절에 전체 열의 값 기술 필요
  INSERT INTO t1 VALUES (7788, 'SCOTT' , 20);
  
  -- DEFAULT 값이 설정되어 있는 열에는 DEFAULT 키워드 사용 가능
  INSERT INTO t1 VALUES (7876, 'ADAMS' , DEFAULT);
  
  -- 열을 추가하면 상단에서 INTO절에 열을 지정하지 않아서 VALUES절에 전체 열을 기술해야 했던 모든 쿼리에서 에러가 발생한다
  -- 따라서, 하단의 쿼리처럼 INTO절에 열을 지정하는 방식이 쿼리의 안정성 측면에서 바람직하다
  ALTER TABLE t1 ADD job VARCHAR2(9);
  INSERT INTO t1 (empno, ename, deptno) VALUES (7902, 'FORD' , 20);
  ```
  * 서브 쿼리: 서브 쿼리의 결과 삽입
  ```sql
  INSERT INTO {table | view | subquery} [t_alias] [(column [, column]...)]
  subquery
  ```
  ```sql
  -- 서브쿼리 결과가 다중행이면 다중행이 INSERT된다
  INSERT INTO t1 (empno, ename)
  SELECT empno, ename FROM emp WHERE job = 'ANALYST';

  -- 서브쿼리에 UNION ALL 연산자를 사용하면 여러 태이블의 행 삽입 가능
  INSERT INTO t1 (empno, ename)
  SELECT empno, ename  FROM emp  WHERE job = 'PRESIDENT'
  UNION ALL
  SELECT deptno, dname FROM dept WHERE deptno = 10;
  ```
* 다중 테이블 INSERT 문
  * 무조건 INSERT 문: 모든 테이블에 서브 쿼리 결과 삽입
  ```sql
  INSERT ALL {INTO table [(column [, column]...] [VALUES ({expr | DEFAULT} [, {expr | DEFAULT}]...)]}...
  subquery
  ```
  ```sql
  CREATE TABLE t1 (empno NUMBER(4), job VARCHAR2(9));
  CREATE TABLE t2 (empno NUMBER(4), mgr NUMBER(4)  );

  -- t1, t2 테이블 각각에 행3개씩 INSERT
  INSERT ALL
         INTO   t1 (empno, job) VALUES (empno, job)
         INTO   t2 (empno, mgr) VALUES (empno, mgr)
  SELECT * FROM emp WHERE deptno = 10;

  -- PIVOT INSERT문: 서브 쿼리의 1행이 t1 테이블에 4번 삽입된다
  CREATE TABLE t1 (deptno NUMBER(2), tp VARCHAR2(3), sal NUMBER(7,2));
  
  INSERT ALL
         INTO t1 VALUES (deptno, 'MIN', sal_min)
         INTO t1 VALUES (deptno, 'MAX', sal_max)
         INTO t1 VALUES (deptno, 'SUM', sal_sum)
         INTO t1 VALUES (deptno, 'AVG', sal_avg)
  SELECT deptno
       , MIN (sal) AS sal_min
       , MAX (sal) AS sal_max
       , SUM (sal) AS sal_sum
       , AVG (sal) AS sal_avg
  FROM  emp
  GROUP BY deptno;
  ```
* 조건부 INSERT 문: 조건을 만족하는 테이블에 서브 쿼리 결과 삽입
  * ALL: 조건을 만족하는 모든 테이블에 행 삽입
  * FIRST: 조건을 만족하는 첫 번째 테이블에 행 삽입
  ```sql
  INSERT [ALL | FIRST]
    WHEN condition THEN
    INTO table [(column [, column]...)] [VALUES ({expr | DEFAULT} [, {expr | DEFAULT}]...)]
   [WHEN condition THEN
    INTO table [(column [, column]...)] [VALUES ({expr | DEFAULT} [, {expr | DEFAULT}]...)]
   [ELSE
    INTO table [(column [, column]...)] [VALUES ({expr | DEFAULT} [, {expr | DEFAULT}]...)]
  subquery
  ```
  ```sql
  CREATE TABLE t1 AS SELECT empno, ename, sal FROM emp WHERE 0 = 1;
  CREATE TABLE t2 AS SELECT * FROM t1;
  CREATE TABLE t3 AS SELECT * FROM t1;

  -- 조건을 만족하는 모든 테이블에 삽입
  INSERT ALL
        WHEN sal >= 2000 THEN INTO t1
        WHEN sal >= 3000 THEN INTO t2
        ELSE INTO t3
  SELECT empno, ename , sal FROM emp WHERE deptno = 10;

  -- 조건을 만족하는 첫번째 테이블에 삽입
  INSERT FIRST
          WHEN sal >= 2000 THEN INTO t1
          WHEN sal >= 3000 THEN INTO t2
          ELSE INTO t3
  SELECT empno, ename , sal FROM emp WHERE deptno = 10;
  ```

<br>

### UPDATE 문 
* 기본 문법
  * UPDATE > WHERE > SET (행별)
  ```sql
  UPDATE {table | view | subquery} [t_alias]
     SET {column = {expr | (subquery) | DEFAULT} | (column [, column]...) = (subquery)}
      [, {column = {expr | (subquery) | DEFAULT} | (column [, column]...) = (subquery)}]...
  WHERE condition;
  ```
* t1(dept, 갱신할 테이블):t2(emp, 나머지 테이블)=1:M 비식별 관계
  ```sql
  CREATE TABLE t1 AS SELECT deptno, dname, 0 AS sal, 0 AS comm FROM dept;
  CREATE TABLE t2 AS SELECT empno, ename, sal, comm, deptno    FROM emp;

  ALTER TABLE t1 ADD CONSTRAINT t1_pk PRIMARY KEY (deptno);
  ALTER TABLE t2 ADD CONSTRAINT t2_pk PRIMARY KEY (empno);
  ALTER TABLE t2 ADD CONSTRAINT t2_f1 FOREIGN KEY (deptno) REFERENCES t1 (deptno);
  
  UPDATE t1 SET sal = 10000, comm = 1000 WHERE deptno = 40;
  ```
* 다중 열 서브 쿼리: 서브 쿼리의 결과로 갱신
  * UPDATE 기준은 t1의 행 별로 t2와 조인을 해서 얻은 값으로 갱신한다
  * 만약 조인의 결과가 없다면, SUM 집계함수 결과가 NULL이 되기 때문에, (a.sal, a.comm) = (NULL, NULL)로 갱신된다
  ```sql
  UPDATE t1 a
     SET (a.sal, a.comm) =
         (SELECT SUM (x.sal), SUM (x.comm) FROM t2 x WHERE x.deptno = a.deptno);
  ```
  * 조인의 결과가 없어서 NULL값 갱신을 피하기 위해서 EXISTS절을 추가한다
  ```sql
  UPDATE t1 a
  SET    (a.sal, a.comm) =
         (SELECT SUM (x.sal), SUM (x.comm) FROM t2 X WHERE x.deptno = a.deptno)
  WHERE  EXISTS (SELECT 1 FROM t2 X WHERE x.deptno = a.deptno);
  ```
* 인라인뷰 사용 가능
  * GOOD! 갱신할 테이블:나머지 테이블=1:1(차수) - 단일 행이 단일 값으로 갱신되는 것이 보장되어야 한다
    * GROUP BY deptno를 통해서 차수를 1:1로 맞춰줌
  ```sql
  -- 인라인 뷰를 통해 t2 테이블은 1번만 읽게 설계 가능
  UPDATE( SELECT a.sal, a.comm, b.sal AS sal_n, b.comm AS comm_n
            FROM t1 a
               , (SELECT deptno, SUM(sal) AS sal, SUM(comm) AS comm
                    FROM t2
                   GROUP BY deptno) b
            WHERE b.deptno = a.deptno )
  SET sal = sal_n, comm = comm_n;
  ```
    * MERGE문으로 대체 가능
  ```sql
  MERGE
   INTO t1 t
  USING (SELECT deptno, SUM(sal) AS sal, SUM(comm) AS comm
           FROM t2
       GROUP BY deptno) s
     ON (t.deptno = s.deptno)
  WHEN MATCHED THEN
        UPDATE SET t.sal = s.sal, t.comm = s.comm;
  ```
  * BAD! 갱신할 테이블:나머지 테이블=1:M(차수) - ORA-01779(키-보존된 것이 아닌 테이블로 대응한 열을 수정할 수 없습니다) 발생
    * 1쪽 테이블(t1)의 값이 M쪽 테이블(t2)의 값으로 여러 번 갱신될 수 있기 때문
    ```sql
    UPDATE (SELECT a.sal, a.comm, b.sal AS sal_n, b.comm AS comm_n
              FROM t1 a, t2 b
             WHERE b.deptno = a.deptno)
       SET sal = sal_n, c. mm = comm_n;
    ```
  * GOOD! 갱신할 테이블:나머지 테이블=M:1(차수) - 단일 행이 단일 값으로 갱신되는 것이 보장되어야 한다
    * M쪽 테이블(t2)의 값이 1쪽 테이블(t1)의 값으로 1번만 갱신되는 것이 보장된다
    ```sql
    UPDATE (SELECT a.sal, a.comm, b.sal AS sal_n, b.comm AS comm_n
              FROM t2 a, t1 b
             WHERE b.deptno = a.deptno)
       SET sal = sal_n, c. mm = comm_n;
    ```

<br>

### DELETE 문
* 기본 문법
  * FROM > WHERE > DELETE
  ```sql
  DELETE
    FROM { table | view | subquery} [t_alias]
   WHERE condition;
  ```
* 예시
  ```sql
  DELETE FROM t1 WHERE deptno = 10;
  ```
  ```sql
  DELETE
    FROM t1 a
   WHERE NOT EXISTS (SELECT 1 FROM emp x WHERE x.deptno = a.deptno);
  ```
  ```sql
  DELETE FROM t1;
  ```
* 실수 방지
  * 먼저 SELECT문을 작성하고, SELECT문을 UPDATE문이나 DELETE문으로 변경하는 방식을 사용해야 실수 방지 가능
  * UPDATE
  ```sql
  SELECT a.*
       , (SELECT SUM( x.comm )
            FROM emp x
           WHERE x.deptno = a.deptno
    FROM t1 a
   WHERE EXISTS
         (SELECT 1
            FROM emp x
           WHERE x.deptno = a.deptno);
  ```
  ```sql
  UPDATE t1 a
     SET a.sal = (SELECT SUM( x.comm )
                    FROM emp x
                   WHERE x.deptno = a.deptno)
   WHERE EXISTS
         (SELECT 1
            FROM emp x
           WHERE x.deptno = a.deptno);
  ```
  * DELETE
  ```sql
  SELECT a.*
    FROM t1 a
   WHERE NOT EXISTS (SELECT 1
                       FROM emp x
                      WHERE x.deptno = a.deptno);
  ```
  ```sql
  DELETE
    FROM t1 a
   WHERE NOT EXISTS (SELECT 1
                       FROM emp x
                      WHERE x.deptno = a.deptno);
  ```

<br>

### MERGE 문
* 기본 문법
  * INTO절: 갱신 또는 삽입할 타켓 테이블
  * USING절: 갱신 또는 상비에 사용할 소스 테이블
  * ON절: 갱신 또는 삽입을 결정하는 조건
  * MERGE UPDATE절: ON 절의 조건이 만족하는 경우 수행될 구문
  * MERGE INSERT절: ON 절의 조건이 만족하지 않는 경우 수행될 구문
  ```sql
  MERGE 
   INTO { table | view | (subquery) } [t_alias]
  USING { table | view | (subquery) } [t_alias]
     ON ( condition )
   WHEN MATCHED THEN
         UPDATE 
            SET column = { expr | DEFAULT } [, column = { expr | DEFAULT }
         [WHERE condition{
        [DELETE 
          WHERE condition]
   WHEN NOT MATCHED THEN 
         INSERT [(column [, column]...)]
          VALUES ({ expr | DEFAULT } [, { expr | DEFAULT }]...)
          [WHERE condition];
  ```
* 예시
  ```sql
  MERGE
   INTO t1 t
  USING t2 s
     ON (t.empno = s.empno)
   WHEN MATCHED THEN
        UPDATE
           SET t.sal = s.sal - 500
   WHEN NOT MATCHED THEN
        INSERT (t.empno, t.ename, t.job)
        VALUES (s.empno, s.ename, s.job);
  ```
* 선택 작업
  * MERGE UPDATE절
  ```sql
  MERGE
   INTO t1 t
  USING t2 s
     ON (t.empno = s.empno)
   WHEN MATCHED THEN
        UPDATE
           SET t.sal = s.sal - 500;
  ```
  ```sql
  -- 동일 결과 UPDATE문
  UPDATE (SELECT a.sal , b.sal AS sal_n FROM t1 a, t2 b WHERE b.empno = a.empno)
  SET sal = sal n - 500;
  ```
  * MERGE INSERT절
  ```sql
  MERGE
   INTO t1 t
  USING t2 s
     ON (t.empno = s.empno)
   WHEN NOT MATCHED THEN
        INSERT (t.empno, t.ename, t.job)
        VALUES (s.empno, s.ename, s.job);
  ```
  ```sql
  -- 동일 결과 INSERT문
  INSERT INTO t1(empno, ename, job, sal)
      AS SELECT empno, ename, job
           FROM t2 s
          WHERE NOT EXISTS (SELECT 1
                              FROM t1 t
                             WHERE t.empno = s.empno;
  ```
* WHERE 절
  * MERGE UPDATE: 타깃 테이블(t1)의 일반 조건
  ```sql
  MERGE
   INTO t1 t
  USING t2 s
     ON (t.empno = s.empno)
   WHEN MATCHED THEN
         UPDATE
            SET t.sal = s.sal - 500
          WHERE t.job = 'CLERK';
  ```
  ```sql
  -- 동일 결과 인라인뷰 방식
  MERGE
   INTO (SELECT * FROM t1 WHERE job = 'CLERK') t
  USING t2 s
     ON (t.empno = s.empno)
   WHEN MATCHED THEN
         UPDATE
            SET t.sal = s.sal - 500;
  ```
  * MERGE UPDATE: 소스 테이블(t2)의 일반 조건
  ```sql
  MERGE
   INTO t1 t
  USING t2 s
     ON (t.empno = s.empno)
   WHEN MATCHED THEN
         UPDATE
            SET t.sal = s.sal - 500
          WHERE s.job = 'CLERK';
  ```
  ```sql
  -- 동일 결과 인라인뷰 방식
  MERGE
   INTO t1 t
  USING (SELECT * FROM t2 WHERE job = 'CLERK') s
     ON (t.empno = s.empno)
   WHEN MATCHED THEN
         UPDATE
            SET t.sal = s.sal - 500;
  ```
  * MERGE UPDATE: 타깃 테이블(t1)의 일반 조건 && 소스 테이블(t2)의 일반 조건
  ```sql
  MERGE
   INTO t1 t
  USING t2 s
     ON (t.empno = s.empno)
   WHEN MATCHED THEN
         UPDATE
            SET t.sal = s.sal - 500
          WHERE (   ( t.job = 'CLERK' AND s.sal >= 1000 )
                  OR( t.job <> 'CLERK') );
  ```
  * MERGE INSERT: 타겟 테이블(t1)의 일반 조건 `불가능!`
  ```sql
  -- ORA-38102: INSERT WHERE 절에 부적합한 열이 있음 "T"."JOB"
  MERGE
   INTO t1 t
  USING t2 s
     ON (t.empno = s.empno)
   WHEN NOT MATCHED THEN
        INSERT (t.empno, t.ename, t.job)
        VALUES (s.empno, s.ename, s.job)
        WHERE  t.job = 'CLERK';
  ```
  ```sql
  -- ORA-00001: 무결성 제약 조건 (SCOTT.T1_PK)에 위배됩니다
  -- INSERT 대상은 인라인뷰가 아닌 테이블이기 때문에 이미 JONES가 있는데 JONES가 INSERT되서 PK Violation이 발생했다
  MERGE
   INTO (SELECT * FROM t1 WHERE job = 'CLERK') t
  USING t2 s
     ON (t.empno = s.empno)
   WHEN NOT MATCHED THEN
        INSERT (t.empno, t.ename, t.job)
        VALUES (s.empno, s.ename, s.job)
  ```
  * MERGE INSERT: 소스 테이블(t2)의 일반 조건
  ```sql
  MERGE
   INTO t1 t
  USING t2 s
     ON (t.empno = s.empno)
   WHEN NOT MATCHED THEN
        INSERT (t.empno, t.ename, t.job)
        VALUES (s.empno, s.ename, s.job)
        WHERE  s.job = 'CLERK';
  ```
  ```sql
  -- 동일 결과 인라인뷰 방식
  MERGE
   INTO t1 t
  USING (SELECT empno, ename, job FROM t2 WHERE job = 'CLERK') s
     ON (t.empno = s.empno)
   WHEN NOT MATCHED THEN
        INSERT (t.empno, t.ename, t.job)
        VALUES (s.empno, s.ename, s.job)
  ```
* DELETE절
  * DELETE절은 MERGE UPDATE 절로 갱신된 행을 대상으로 수행되며, 갱신된 값을 기준으로 행을 삭제한다
  ```sql
  -- 갱신된 sal가 300인 SMITH가 삭제된다
  MERGE
   INTO t1 t
  USING (SELECT * FROM t2 WHERE job = 'CLERK') s
     ON (t.empno = s.empno)
   WHEN MATCHED THEN
         UPDATE
            SET t.sal = s.sal - 500;
          WHERE t.job = 'CLERK'
         DELETE
           WHERE t.sal < 1000;
  ```
* MERGE UPDATE/DELETE/INSERT
  ```sql
  MERGE
   INTO t1 t
  USING (SELECT * FROM t2 WHERE job = 'CLERK') s
     ON (t.empno = s.empno)
   WHEN MATCHED THEN
         UPDATE
            SET t.sal = s.sal - 500;
          WHERE t.job = 'CLERK'
         DELETE
           WHERE t.sal < 1000;
   WHEN NOT MATCHED THEN
        INSERT (t.empno, t.ename, t.job)
        VALUES (s.empno, s.ename, s.job)
         WHERE s.job = 'CLERK';
  ```

<br>

### 고급 주제
* 조인 차수
  * MERGE 문도 UPDATE 문처럼 조인 치수에 따라 에러가 발생할 수 있다
    * t1(타겟 테이블):t4(소스 테이블)=1:M
      * t1 행이 t4 행들로 여러번 갱신될 수 있기 때문
  ```sql
  -- ORA-30926: 원본 테이블의 고정 행 집함을 가져올 수 없습니다
  -- t:s=차수 1:M
  MERGE
   INTO t1 t
  USING t4 s
     ON (t.empno = s.empno)
   WHEN MATCHED THEN
         UPDATE
            SET t.sal = s.sal - 500;
  ```
  ```sql
  -- 정상처리
  -- 차수 1:1을 맞춰줬기 때문
  MERGE
   INTO t1 t
  USING (SELECT * 
           FROM SELECT a.* 
                     , ROW_NUMBER() OVER (PARTITION BY a.empno
                                                ORDER BY a.yyyy DESC) AS rn
                   FROM t4) a
          WHERE rn = 1) s
     ON (t.empno = s.empno)
   WHEN MATCHED THEN
         UPDATE
            SET t.sal = s.sal - 500;
  ```
* 조인 조건
  * ON절에 기술된 열은 갱신할 수 없다 (무한 루프 발생 가능)
  ```sql
  -- ORA-38104: ON 절에서 참조되는 열은 업데이트할 수 없음: "T"."EMPNO"
  MERGE
   INTO t1 t
  USING (SELECT empno, empno + ROW_NUMBER() OVER (ORDER BY empno) AS empno_n
           FROM t1) s
     ON (t.empno = s.empno)
   WHEN MATCHED THEN
         UPDATE
            SET t.empno = s.empno_n;
  ```
  * 타겟 테이블과 소스 테이블이 동일하면 ROWID 슈도칼럼 사용 가능
  ```sql
  -- 정상처리
  MERGE
   INTO t1 t
  USING (SELECT empno, empno + ROW_NUMBER() OVER (ORDER BY empno) AS empno_n
           FROM t1) s
     ON (t.ROWID = s.ROWID)
   WHEN MATCHED THEN
         UPDATE
            SET t.empno = s.empno_n;
  ```
  * 다른 테이블을 기준으로 ON절에 기술된 열을 갱신하려면 USING절에서 갱신할 테이블을 조인해야 한다
  ```sql
  -- ORA-38104 가 발생하지 않도록 rowid를 ON절에 넣음으로써 우회하는 방법이다
  MERGE
   INTO t1 1
  USING (SELECT a.empno_n, b.ROWID AS rid
           FROM (SELECT empno, empno + ROW_NUMBER() OVER (ORDER BY empno) AS empno_n
                   FROM t3) a
               , t1 b
          WHERE b.empno = a.empno) s
     ON (t.ROWID = s.rid)
   WHEN MATCHED THEN
         UPDATE
            SET t.empno = s.empno_n;
  ```
  * UPDATE문은 분석 함수로 인해 에러 발생
  ```sql
  -- ORA-01779: 키-보존된것이 아닌 테이블로 대응한 열을 수정할 수 없습니다 
  UPDATE (SELECT a.empno, b.empno
            FROM t1 a
               , (SELECT empno, empno + ROW_NUMBER() OVER (ORDER BY empno) AS empno_n
                    FROM t3) b
           WHERE b.empno = a.empno)
     SET empno = empno_n;
  ```
* 일반 조건
  * WHEN MATCHED THEN) ON절에 일반조건을 넣기보다는 인라인뷰에 넣는 것이 가독성에 좋다
  ```sql
  -- 동일 결과
  MERGE
   INTO t1 t
  USING t2 s
     ON (t.job = 'CLERK' AND t.empno = s.empno)
  WHEN MATCHED THEN
        UPDATE
           SET t.sal = s.sal - 500;

  -- 동일 결과
  MERGE
   INTO (SELECT * FROM t1 WHERE job = 'CLERK') t
  USING t2 s
     ON (t.empno = s.empno)
  WHEN MATCHED THEN
        UPDATE
           SET t.sal = s.sal - 500;
  ```
  ```sql
  -- 동일 결과
  MERGE
   INTO t1 t
  USING t2 s
     ON (t.empno = s.empno AND s.job = 'CLERK')
  WHEN MATCHED THEN
        UPDATE
           SET t.sal = s.sal - 500;

  -- 동일 결과
  MERGE
   INTO t1 t
  USING (SELECT * FROM t2 WHERE job = 'CLERK') s
     ON (t.empno = s.empno)
  WHEN MATCHED THEN
        UPDATE
           SET t.sal = s.sal - 500;
  ```
  * WHEN NOT MATCHED THEN) ON절에 일반조건을 넣으면 의도하지 않은 ON절이 TRUE가 되면서 에러가 발생할 수 있다
    * ON절이 FALSE인 행이 삽입되므로, `t.job <> 'CLERK' || t.empno <> s.empno`인 조건이 True인 행들이 업데이트된다
  ```sql
  -- ORA-00001: 무결성 제약 조건 (SCOTT. T1 _PK)에 위배됩니다
  MERGE
   INTO t1 t
  USING t2 s
     ON (t.job = 'CLERK' AND t.empno = s.empno)
   WHEN NOT MATCHED THEN
        INSERT (t.empno, t.ename, t.sal)
        VALUES (s.empno, s.ename, s.sal);

  -- ORA-00001: 무결성 제약 조건 (SCOTT. T1 _PK)에 위배됩니다
  MERGE
   INTO t1 t
  USING t2 s
     ON (t.job = 'CLERK' AND t.empno = s.empno)
   WHEN NOT MATCHED THEN
        INSERT (t.empno, t.ename, t.sal)
        VALUES (s.empno, s.ename, s.sal);
  ```
* 아우터 조인
  * 타깃 테이블의 전체 행을 갱신할 때 사용 가능
  ```sql
  --GOOD: 성능 좋음
  MERGE
   INTO t1 t --기준 테이블
  USING t3 s --아우터 기준
     ON (t.empno = s.empno(+))
   WHEN MATCHED THEN
         UPDATE
            SET t.sal = NVL(s.sal - 500, 0);

  --BAD: 상관 서브쿼리를 사용하면서 쿼리 성능이 저하될 수 있다
  --스칼라 서브쿼리 (Scalar Subquery)처럼 값을 하나 조회해서 SET하는 방식
  UPDATE t1 a
     SET sal = NVL((SELECT x.sal FROM t3 X WHERE x.empno = a.empno) - 500 , 0);

  --GOOD: 인라인뷰를 사용하면 MERGE문과 동일한 성능 보장 가능
  UPDATE (SELECT a.sal, b.sal AS sal_n
            FROM t1 a, t2 b
           WHERE b.empno(+) = a.empno)
     SET sal =  NVL(sal_n - 500, 0);
  ```

<br>

### DML 에러 로깅
* DML문에서 한 건이라도 에러가 발생하면 모든 건이 롤백되기 때문에, 에러건에 대해서 에러를 발생시키자 않되, 에러 테이블에 에러 내역을 쌓고, 다른 건들은 정상 처리하도록 처리 가능
* 기본 문법
  * INTO: 에러 로깅 테이블을 지정
  * simple_expression: 에러 태그로 사용할 값을 지정
  * REJECT LIMIT: integer로 에러의 한계 값을 지정 (기본값은 0 또는 UNLIMITED)
  ```sql
  LOG ERRORS [INTO [schema.] table] [(simple_expression)]
  [REJECT LIMIT {integer | UNLIMITED}]
  ```
* 예시)
  ```sql
  -- ORA-01438: 이 열에 대해 지정된 전체 자릿수보다 큰 값이 허용됩니다
  -- 0 행이 생성되었습니다
  INSERT INTO t1 VALUES (7839, 'KING', 100000)
     LOG ERRORS INTO e1('1') REJECT LIMIT UNLIMITED;
  ```
  ```sql
  -- ORA-00001: 무결성 제약 조건 (SCOTT.T1_PK)에 위배됩니다
  -- 0 행이 생성되었습니다
  INSERT INTO t1 VALUES (7782, 'CLARK', 2450)
     LOG ERRORS INTO e1('2') REJECT LIMIT UNLIMITED;
  ```
  ```sql
  -- ORA-00001: 무결성 제약 조건 (SCOTT.T1_PK)에 위배됩니다
  -- PK위배되는 행들은 제외하고, 위배하지 않는 행들은 INSERT된다
  INSERT INTO t1 SELECT empno, ename, sal FROM emp WHERE deptno = 10
     LOG ERRORS INTO e1('3') REJECT LIMIT UNLIMITED;
  ```
* IGNORE_ROW_ON_DUPKEY_INDEX 힌트
  * 에러가 발생하는 건들은 무시되고, 정상건들은 정상 처리된다
  ```sql
  INSERT /*+ IGNORE_ROW_ON_DUPKEY_INDEX(T1 T1_U1) */
    INTO t1
  SELECT LEVEL FROM DUAL CONNECT BY LEVEL <= 2;
  ```
 
<br>
<hr>
<br>

## TCS 문 (Transaction Control Statement)
#### 트랜잭션, 데이터 동시성, 데이터 일관성

<br>

### 세팅
* ROWDEPENDENCIES
  * row-level dependency tracking 기능 활성화
    * SCN이 행수준으로 저장되며 행의 길이가 6바이트씩 증가한다
* ROWDEPENDENCIES
  * default 세팅으로, SCN이 블록 단위로 저장된다
```sql
CREATE TABLE t1(cd NUMBER, vl NUMBER) ROWDEPENDENCIES;
```

<br>

### 트랜잭션
* 정의
  * 함께 수행해야 하는 작업의 논리적인 단위
* 구조 
  * 트랜잭션 시작
    * DML문 혹은 SET TRANSACTION
    * UNDO Segment가 할당되고, 트랜잭션에 트랜잭션ID (XID)가 부여된다
      * 트랜잭션ID=UNDO Segment의 번호+슬롯+시퀀스
    * V$TRANSACTION 뷰를 통해 트랜잭션 정보 조회 가능
      ```sql
      SELECT xid, xidusn, xidslot, xidsqn, start_date, start_scn 
        FROM v$transaction;
      ```
  * 트랜잭션 종료
    * COMMIT 혹은 ROLLBACK
* SCN (System Change Number)
  * 오라클 데이터베이스의 논리적 TIMESTAMP로 데이터베이스 내부의 작업 순서를 식별하는 용도로 사용된다
  * ORA_ROWSCN
    * 행의 SCN
      * v$transaction 뷰 테이블의 `start_scn` 칼럼과 동일한 값
      * SCN_TO_TIMESTAMP 함수는 SYS.SMON_SCN_TIME 테이블을 참조하는데, 최대 120시간(5일) 동안의 SCN을 저장한다
        * 5일 이전의 SCN을 조회하면, "ORA-08181: 지정된 번호는 적합한 시스템 변경 번호가 아님" 에러 발생 가능
    ```sql
    SELECT cd, vl, ORA_ROWSCN, SCN_TO_TIMESTAMP (ORA_ROWSCN) AS c1 FROM t1;
    ```
    * 현재 SCN
    ```sql
    SELECT checkpoint_change# FROM v$database;
    ```
 * 기본 문법
   * COMMIT 문
     * 현재 트랜잭션의 변경 내용을 데이터베이스에 영구적으로 저장하고 트랜잭션을 종료한다
   ```sql
   COMMIT [WORK] [[COMMENT string] [WRITE [WAIT | NOWAIT] [IMMEDIATE | BATCH]] | FORCE string [, integer]];
   ```
   * ROLLBACK 문
     * 현재 트랜잭션의 변경 내용을 모두 취소하고 트랜잭션을 종료한다
     * 언두 세그먼트에 저장된 변경 이전 데이터를 통해 데이터를 복구한다
   ```sql
   ROLLBACK [WORK] [TO [SAVEPOINT] savepoint | FORCE string];
   ```
   * SAVEPOINT
     * 롤백할 수 있는 저장점을 생성한다
   ```sql
   SAVEPOINT savepoint;
   ```
   ```sql
   UPDATE t1 SET vl = vl - 10 WHERE cd = 2;
   SAVEPOINT s1;
   UPDATE t1 SET vl = vl + 10 WEHRE cd = 1;
   SAVEPOINT s2;

   DELETE FROM t1;
   SELECT * FROM t1;

   -- 정상처리  
   ROLLBACK TO SAVEPOINT s1;
   -- 에러발생 (ORA-01086: 'S2' 저장점이 이 세션에 설정되지 않았거나 부적합합니다)
   ROLLBACK TO SAVEPOINT s2; 
   ```
     * 오라클 데이터베이스는 DML 문이 수행될 때마다 내부적으로 저장점을 생성한다
       * 에러가 발생하면 직전의 저장점으로 문장 수준 롤백 (statement-level rollback)을 수행한다
   ```sql
   UPDATE t1 SET vl = vl + 18 WHERE cd = 1;
   -- 1행이 업데이트되었습니다
   UPDATE t1 SET vl = 'A' WHERE cd = 1;
   -- ORA-81722: 수치가 부적합합니다
   -- 전체 롤백이 아니라, UPDATE t1 SET vl = vl + 18 WHERE cd = 1;까지의 데이터 변경사항까지는 반영되어 있다
   ```
   * 암시적 커밋 (implicit commit)
     * DDL문은 수행 전에 트랜잭션을 커밋하고 종료 후 다시 트랜잭션을 커밋한다
   ```sql
   BEGIN
       COMMIT;
       DDL문;
       COMIIT;
   EXCEPTION
       WHEN OTHERS THEN ROLLBACK; RAISE;
   END;
   ```
   ```sql
   -- 초기 세팅
   DROP TABLE t2 PURGE;
   -- 정상처리
   CREATE TABLE t2 (c1 NUMBER);
   -- 정상처리

   INSERT INTO t2 VALUES(1);
   -- 정상처리
   CREATE TABLE t2 (c1 NUMBER);
   -- ORA-00955: 기존의 객체가 이름을 사용하고 있습니다
   ROLLBACK;
   -- 정상처리 및 트랜잭션 종료

   SELECT *
   FROM t2;
   -- INSERT INTO t2 VALUES(1) 정상처리된 값이 테이블에 적재되어 있다
   -- CREATE TABLE 문에서 선 COMMIT이 되기 때문에 INSERT INTO문은 COMMIT된다
   ```

<br>

### 데이터 동시성 (Data Concurrency)
* 정의
  * 다수의 시용자가 통일한 데이터에 동시에 접근할 수 있는 것을 말한다
* Locking 메커니즘
  * 오라클 데이터베이스는 데이터 동시성을 보장하기 위해 락(Lock)을 사용한다
    * 오라클 데이터베이스는 락 외에도 래치(Latch)와 뮤텍스(Mutex) 등을 사용하여 자원의 사용을 직렬화한다
  * 자동 락(Automatic Lock)
    * 오라클 락 종류
    ```sql
    SELECT type, name, description FROM v$lock_type ORDER BY type;
    ```
    * 락 유형
      * TM(Table Lock) 락: `테이블`에 설정되는 락
      * TX(Row Lock) 락: 로우 레벨 락(Low Level Lock)으로 `트랜잭션`에 설정되는 락
    * 락은 종류에 따라 설정될 수 있는 모드가 있다
      |                           | RS | RX | S | SRX | X |
      |---------------------------|----|----|---|-----|---|
      | RS (Row Share)            | Y  | Y  | Y | Y   |   |
      | RX (Row eXclusive)        | Y  | Y  |   |     |   |
      | S (Share)                 | Y  |    | Y |     |   |
      | SRX (Share Row eXclusive) | Y  |    |   |     |   |
      | X (eXclusive)             |    |    |   |     |   |
    * DML
      * TM 락: RX 모드
      * TX 락: X 모드
    * DDL
      * TM 락: X 모드
      * TX 락: X 모드
    * dba_lock
      * 락 현황 조회 가능
        * blocking_others: 다른 세션의 락을 블로킹하면 Blocking; 아니면, Not Blocking
    ```sql
    UPDATE...
    -- DML
    SELECT USERENV('SID') FROM dual;
    -- 어떤 Session에서 쿼리가 수행되었는지 조회
    -- session_id 값으로 사용

    SELECT lock_type       -- 락 유형
         , mode_held       -- 현재 잡고 있는 모드 
         , mode_requested  -- 현재 잡지 못하고 요청한 모드
         , blocking_others -- 다른 세션을 블로킹하고 있는지
    FROM   dba_lock
    WHERE  session id = 100
    AND    lock_type in ( 'DML' , 'Transaction' );
    ```
    * 블로킹 예시
      * 로우 레벨 락을 설정하기 위해 블록을 방문하며 로우 헤더(c1=1)를 확인
      * 로우 레벨 락이 설정되어 있는 것을 확인
      * 로우 레벨 락과 연결된 S1 세션의 TX 락이 X 모드인 것을 확인
      * 호환되지 않은 모드이므로 대기 목록에 트랜잭션을 등록하고 대기(블로킹)
    ```sql
    --S1(100)
    UPDATE t1 SET vl = vl + 10 WHERE cd = 1;
    --S1 락 획득
    --S2(200)
    UPDATE t1 SET vl = vl - 10 WHERE cd = 1;
    --S2 락 블로킹
    --S3(300)
    DROP TABLE t1;
    -- ORA-00054: 리소스가 사용 중이어서 NOWAIT가 지정되었거나 시간 초과가 만료된 상태로 획득합니다
    -- DDL문은 TM락을 X 모드로 설정한다
    ```
  * LOCK TABLE
    * 수동으로 테이블에 TM락 설정 가능
    ```sql
    LOCK TABLE [schema.] {table|view} [, [schema.] {table|view}]...
            IN lockmode MODE [NOWAIT|WAIT integer];
    ```
    ```sql
    --S1(100)
    LOCK TABLE t1 IN ROW EXCLUSIVE MODE;
    -- 테이블이 잠금되었습니다.

    --S2(100)
    LOCK TABLE t1 IN EXCLUSIVE MODE NOWAIT;
    -- ORA-00054: 리소스가 사용 중이어서 NOWAIT가 지정되었거나 시간 초과가 만료된 상태로 획득합니다.
    ```
* 동시성 제어
  * 개발 환경에 따라 자동 락(Automatic Lock)을 통한 동시성 보장이 불가능한 경우가 있다
  * Lost Update
  ```sql
  --S1(100)
  COLUMN vl NEW_VALUE v_vl
  --S1(100)
  SELECT vl FROM t1 WHERE cd = 1;
  --vl:40

  --S2(200)
  UPDATE t1 SET vl = vl + 10 WHERE cd = 1;
  --S2(200)
  COMMIT;
  --vl:50

  --S1(100)
  UPDATE t1
     SET vl = &v_vl + 10
   WHERE cd = 1;
  --S1(100)
  SELECT vl FROM t1 WHERE cd = 1;
  --vl:50
  ```
* 비관적 동시성 제어 (Pessimistic Concurrency control, Pessimistic Locking)
  * 다수의 사용자가 동일한 데이터를 동시에 갱신하는 일이 빈번하다고 가정하며, FOR UPDATE절을 사용한다
  * SELECT문에 FOR UPDATE절
    * 조회한 행에 로우 레벨 락이 설정된다
  ```sql
  FOR UPDATE [OF [{table|view}.]column [,[{table|view}.]column]...]
  [{NOWAIT|WAIT integer|SKIP LOCKED}]
  ```
  ```sql
  --S1(100)
  SELECT vl FROM t1 WHERE cd = 1 FOR UPDATE;
  --vl:40

  --S2(200)
  SELECT vl FROM t1 WHERE cd = 1 FOR UPDATE;
  --블로킹

  --S1(100)
  UPDATE t1 SET vl = vl + 10 WHERE cd = 1;
  --S1(100)
  COMMIT;
  --vl:50

  --S2(200)
  UPDATE t1 SET vl = vl + 10 WHERE cd = 1;
  --S2(200)
  COMMIT;
  --vl:60
  ```
  ```sql
  --S2(200)
  SELECT vl FROM t1 WHERE cd = 1 FOR UPDATE NOWAIT;
  --ORA-00054: 리소스가 사용 중이어서 NOWAIT가 지정되었거나 시간 초과가 만료된 상태로 획득합니다

  --S2(200)
  SELECT vl FROM t1 WHERE cd = 1 FOR UPDATE WAIT 10;
  --ORA-30006: 리소스 사용 중. WAIT 시간 초과로 획득이 만료됨

  --S2(200)
  SELECT vl FROM t1 FOR UPDATE SKIP LOCKED;
  --락이 잡히지 않은 행들만 조회된다
  ```
  * 조인이 사용된 FOR UPDATE
  ```sql
  --S1(100)
  SELECT *
    FROM emp a, dept b
   WHERE b.deptno = a.deptno
     FOR UPDATE OF a.deptno;
  -- FOR UPDATE절에 지정한 열의 테이블 행에만 락이 설정된다
  -- a.deptno > emp a

  --S2(200)
  SELECT * FROM dept FOR UPDATE NOWAIT;
  --정상조회
  --S2(200)
  SELECT * FROM emp  FOR UPDATE NOWAIT;
  --ORA-00054: 리소스가 사용 중이어서 NOWAIT가 지정되었거나 시간 초과가 만료된 상태로 획득합니다
  
  --S1(100)
  COMMIT;
  --S2(200)
  COMMIT;
  ```
* 낙관적 동시성 제어 (Optimistic Concurrency Control, Optimistic Locking)
  * 다수의 사용자가 동일한 데이터를 동시에 갱신하는 일이 드믈다고 가정한다
  * 칼럼 확인 방식
    * 변경할 값을 조회하여 저장하고, 값을 변경하기 전에 저장한 값의 변경 여부를 확인하는 방식이다
    * 변경할 값이 많은 경우, 모든 값을 비교해야 하기 때문에 쿼리가 길어질 수 있다
  ```sql
  --S1(100)
  COLUMN vl NEW_VALUE v_vl
  --S1(100)
  SELECT vl FROM t1 WHERE cd = 1;
  --vl:40

  --S2(200)
  UPDATE t1 SET vl = vl + 10 WHERE cd = 1;
  --S2(200)
  COMMIT;
  --vl:50

  --S1(100)
  UPDATE t1
     SET vl = vl + 10
   WHERE cd = 1
     AND vl = &v_vl;
  --0행이 업데이트되었습니다.
  ```
  * 버전 확인 방식
    * 버전 정보를 변수에 저장하고, 값을 변경하기 전에 저장한 버전 정보의 변경 여부를 확인하는 방식
      * 쿼리가 간결해지는 장점
      * 버전 속성값이 추가되어야 하는 단점
  ```sql
  --S1(100)
  COLUMN md NEW_VALUE md
  --S1(100)
  SELECT md FROM t1 WHERE cd = 1;
  --md: 특정 일시

  --S2(200)
  UPDATE t1 
     SET vl = vl + 10, md = SYSDATE
   WHERE cd = 1;
  --S2(200)
  COMMIT;
  --vl:50

  --S1(100)
  UPDATE t1
     SET vl = vl + 10
   WHERE cd = 1
     AND md = TO_CHAR(&md,
              , 'YYYY-MM-DD HH24:MI:SS');
  --0행이 업데이트되었습니다.
  ```
* 데이터 일관성 (Data Consistency)
  * 트랜잭션에 의한 변경을 일관된 상태로 볼 수 있음을 의미한다
  * Trade-off 관계
    * 데이터 동시성 vs 데이터 일관성
  * 다중 버전 읽기 일관성 (Multiversion Read Consistency, MVRC), Multiversion Concurrency Control (MVCC)
    * 쿼리가 시작된 시점의 데이터를 조회할 수 있는 기능
      * 쿼리가 시작된 SCN과 블록의 SCN을 비교하여 쿼리가 시작된 시점의 데이터를 반환한다
    * 언두 세그먼트 공간은 일정 시점이 지나면 재사용될 수 있다
      * 쿼리 시작 시점의 변경 이전의 데이터가 저장된 공간이 재사용되면 해당 시점의 데이터를 반환할 수 없게 된다
      * 이때, `ORA-01555: 너무 이전 스냅샷` 발생
      * 이를, 다중 버전 읽기 일관성의 부작용으로 보기도 한다
    ```sql
    --S2
    SELECT vl FROM t1 WHERE cd = 1; --40
    --S1
    UPDATE t1 SET vl = vl + 10 WHERE cd = 1;
    --S1
    SELECT vl FROM t1 WHERE cd = 1; --50
    --S2
    SELECT vl FROM t1 WHERE cd = 1; --40
    --S1
    COMMIT;
    --S2
    SELECT vl FROM t1 WHERE cd = 1; --50
    ```
  * 문장 수준 읽기 일관성 (Statement-level Read Consistency)
    * 오라클은 다중 버전 읽기 일관성을 지원하기 때문에 락을 사용하지 않고 문장 수준 읽기 일관성을 보장한다
  * 트랜잭션 수준 읽기 일관성 (Transaction-level Read Consistency)
    * 오라클은 기본적으로 트랜잭션 수준 읽기 일관성을 보장하지 않는다
    * 따라서, 고립화 수준을 변경해야 한다
  * ANSI/ISO SQL 표준 트랜잭션 고립화 수준 (Transaction Isolation Level)
    * read uncommitted: 커밋되지 않은 데이터를 읽는 것을 허용
      * dirty read, non-repeatable read, phantom read
    * read committed: 커밋된 데이터만 읽는 것을 허용
      * non-repeatable read, phantom read
    * repeatable reads: 트랜잭션 내에서 읽은 데이터는 갱신과 삭제를 금지
      * phantom read
    * serializable: 트랜잭션 내에서 읽은 테이블에 삽입을 금지
  * ANSI/ISO SQL 표준 읽기 이상현상 (read phenomena)
    * dirty read: 동일한 쿼리가 커밋되지 않은 데이터를 읽어 다른 결과를 반환
    * non-repeatable read: 동일한 쿼리가 갱신 또는 삭제에 의해 다른 결과를 반환
    * phantom read: 동일한 쿼리가 삽입에 의해 다른 결과를 반환
  * 오라클 세팅
    * 지원하는 트랜잭션 고립화 수준
      * read committed (default 세팅), serializable
    * repeatable reads 방지 가능
      * SELECT FOR UPDATE 사용
      ```sql
      --S1
      SELECT * FROM t1 FOR UPDATE;
      --S2
      UPDATE t1 SET vl = vl + 10 WHERE cd = 1;
      --블로킹

      --S1
      SELECT SUM(vl) AS vl FROM t1;
      --100
      --S1
      SELECT SUM(vl) AS vl FROM t1;
      --100 (반복 조회시 동일한 값 조회)
      --S1
      COMMIT;
      --S2
      ROLLBACK;
      ```
    * phantom read 방지 불가능
      ```sql
      --S1
      SELECT * FROM t1 FOR UPDATE;
      --S1
      SELECT SUM(vl) AS vl FROM t1;
      --100

      --S2
      INSERT INTO t1(cd, vl) VALUES(3, 50);
      --S2
      COMMIT;

      --S1
      SELECT SUM(vl) AS vl FROM t1;
      --150 (FOR UPDATE를 사용하더라도, phantom read 방지 불가능)
      --S1
      COMMIT;
      ```
* SET TRANSACTION 문
  * READ ONLY: 읽기 전용 트랜잭션으로 설정 (트랜잭션 수준 읽기 일관성 보장)
  * READ WRITE: (Default 세팅) 읽기 쓰기 전용 트랜잭션으로 설정 (문장 수준 읽기 일관성 보장)
  * SERIALIZABLE: 트랜잭션 고립화 수준을 SERIALIZABLE로 설정
  * READ COMMITTED: 트랜잭션 고립화 수준을 READ COMMITTED로 설정
  ```sql
  SET TRANSACTION { {READ {ONLY | WRITE }
                     | ISOLATION LEVEL {SERIALIZABLE | READ COMMITTED}
                     | USE ROLLBACK SEGMENT rollback_segment
                     } [NAME string] 
                   | NAME string};
  ```
  * INSERT 예시)
  ```sql
  --S1
  SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
  --S1
  SELECT SUM(vl) AS vl FROM t1;
  --150

  --S2
  INSERT INTO t1(cd, vl) VALUES(3, 50);
  --S2
  COMMIT;
  
  --S1
  SELECT SUM(vl) AS vl FROM t1;
  --150
  --S1
  COMMIT;
  --트랜잭션 종료되면, 트랜잭션 고립화가 초기화된다
  --즉, 이시점부터는 S1이라는 동일한 세션이 새로운 트랜잭션을 시작하면, 기본값인 READ WRITE로 트랜잭션이 생성된다
  
  --S1
  SELECT SUM(vl) AS vl FROM t1;
  --200
  ```
  * UPDATE 예시)
  ```sql
  --S1
  SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

  --S2
  UPDATE t1 SET vl = vl + 10 WHERE cd = 1;
  --S2
  COMMIT;
  
  --S1
  UPDATE t1 SET vl = vl - 10 WHERE cd = 1;
  --ORA-08177: 이 트랜잭션에 대한 직렬화 액세스를 할 수 없습니다
  --S1
  ROLLBACK;
  ```
  
<br>
<hr>
<br>

## DDL 문 (Data Definition Language)
#### 

<br>

### 테이블
* 기본 문법
  * CREATE TABLE 문
  ```sql
  CREATE TABLE [schema. ]table (
         column datatype [DEFAULT [ON NULL] expr]
      [, column datatype [DEFAULT [ON NULL] expr]]...) [TABLESPACE tablespace]; 
  ```
  ```sql
  CREATE TABLE t1 (
      c1 NUMBER
    , c2 NUMBER(2) DEFAULT 2
    , c3 NUMBER(3) DEFAULT 3 NOT NULL);

  -- 테이블 관련 데이터 딕셔너리 뷰
  -- users_table
  -- user_tab_columns
  ```
  ```sql
  -- 서브쿼리 방식 (CTAS, Create Table As Select)
  CREATE TABLE [schema. ]table [(
         column [DEFAULT [ON NULL] expr]
      [, column [DEFAULT [ON NULL] expr]]...)] [TABLESPACE tablespace]
  AS subquery;
  ```
  ```sql
  -- 타 테이블 칼럼 정보만 가져오기
  -- 데이터 INSERT X
  CREATE TABLE t2 
      AS SELECT * FROM t1 WHERE 0 = 1;
  -- 데이터 타입과 NOT NULL 제약 조건만 참조한다
  -- 기본값 (DEFAULT)값은 참조 X
  ```
  ```sql
  -- 특정 데이터 타입 지정을 위한 CAST 사용
  CREATE TABLE t2 
      AS SELECT 1234 AS c1 -- NUMBER
              , 'AB' AS c2 -- CHAR(2)
              , CAST(1234 AS NUMBER(10)) AS c3 -- NUMBER(10)
              , CAST('AB' AS VARCHAR2(10)) AS c4 -- VARCHAR2(10)
          FROM dual;
  ```
  ```sql
  -- NULL은 데이터 타입의 길이를 결정할 수 없어서 에러 발생
  -- ORA-01723: 길이가 0인 열은 지정할 수 없습니다
  CREATE TABLE t1 AS
  SELECT NULL FROM dual;
  
  -- 정상처리
  DROP TABLE t1 PURGE;
  
  CREATE TABLE t1 AS
  SELECT CAST(NULL AS NUMBER) AS c1
       , CAST(NULL AS VARCHAR2(1)) AS c2
    FROM dual;
  ```
  * 테이블스페이스와 익스텐트
    * 세그먼트 오브젝트
      * 테이블, 인덱스, 파티션
    * 포함 관계
      * 1개의 세그먼트는 1개의 테이블 스페이스에 저장
      * n개의 익스텐트가 1개의 세그먼트 구성
      * n개의 블록이 1개의 익스텐트 구성
    * 세그먼트의 테이블 스페이스 지정
    ```sql
    CREATE TABLE t1 TABLESPACE users AS
    SELECT ROWNUM AS c1 FROM XMLTABLE('1 to 10000');
    
    SELECT tablespace_name FROM user_tables WHERE table_name = 't1';
    -- USERS

    SELECT segment_type, tablespace_name, bytes, blocks
      FROM user_segments
     WHERE segment_name = 't1';
    -- TABLE USERS 196608 24

    SELECT extent_id, bytes, blocks 
      FROM user_extents
     WHERE segment_name = 't1';
    -- 0 extent_id 8 blocks
    -- 1 extent_id 8 blocks
    -- 2 extent_id 8 blocks

    SELECT default_tablespace FROM dba_users WHERE username = 'SCOTT';
    ```
    * SI 단위
      * 킬로(Kilo)
      * 메가(Mega)
      * 기가(Giga)
      * 테라(Tera)
      * 페타(Peta)
      * 엑사(Exa)
      * 제타(Zetta)
      * 요타(Yotta)
  * ALTER TABLE 문
    * RENAME절
    ```sql
    ALTER TABLE [schema.]table RENAME TO new_table_name; 
    ```
    * MOVE절
      * INCLUDING ROWS: 재배치한 데이터의 조건을 지정
      * ONLINE: DDL문이 수행되는 동안 DML문이 수행되도록 허용
      * TABLESPACE: 테이블스페이스를 지정
      * UPDATE INDEXES: 인덱스도 함께 재구성
    ```sql
    ALTER TABLE [schema.]table MOVE
          [INCLUDING ROWS where_clause]
          [ONLINE]
          [TABLESPACE tablespace]
          [UPDATE INDEXES] [(index [, index])];
    ```
    ```sql
    ALTER TABLE t1 MOVE INCLUDING ROWS WHERE c1 <= 5000 TABLESPACE users;
    -- 조건에 미포함되는 데이터는 재배치 되지 않고 제거된다
    ```
    * READ ONLY
      * READ ONLY: 테이블을 읽기 전용으로 변경
      * READ WRITE: 테이블을 읽기 쓰기로 변경 (기본값)
    ```sql
    ALTER TABLE [schema.]table {READ ONLY|READ WRITE};
    ```
    ```sql
    ALTER TABLE t1 READ ONLY;
    INSERT INTO t1(c1) VALUES(1);
    -- ORA-12081: 테이블에 작업을 업데이트하는 것이 허용되지 않습니다
    -- DW 시스템의 경우, 적재가 완료된 소스 테이블을 READ ONLY로 변경하여 소스 테이블을 사용하는 타깃 테이블의 데이터 일관성(Data Consistency)을 높일 수 있다
    SELECT table_name, read_only FROM user_tables WHERE table_name = 't1';
    -- READ ONLY 세팅 확인 가능
    ```
  * DROP TABLE 문
    * CASCADE CONSTRAINTS: 테이블을 참조하는 FK 제약 조건을 함께 삭제
    * PURGE: recycle bin을 사용하지 않고 테이블을 즉시 삭제
  ```sql
  DROP TABLE [schema.]table [CASCADE CONSTRAINTS] [PURGE];
  ```
  ```sql
  DROP TABLE t1 CASCADE CONSTRAINTS PURGE;
  ```
  * TRUNCATE TABLE 문
    * DROP STORAGE (Default): MINEXTENTS 파라미터에 의해 할당된 공간을 제외한 공간을 해제
    * DROP ALL STORAGE: MINEXTENTS 파라미터에 의해 할당된 공간을 포함한 모든 공간을 해제
    * REUSE STORAGE: 삭제된 행의 공간을 유지
    * RECYCLE: ON DELETE CASCADE FK 제약 조건으로 참조하는 테이블을 TRUNCATE
  ```sql
  TRUNCATE TABLE [schema.]table [{DROP[ALL] | REUSE} STORAGE] [CASCADE];
  ```
  ```sql
  TRUNCATE TABLE t1;
  -- DROP ALL STORAGE 사용시, 수행시간을 감소시킬 수 있다
  ```
* 테이블 유형
  * 유형
    * 구조: 힙 구조 테이블, 인덱스 구조 테이블, 익스터널 테이블
    * 분산: 클러스터 테이블, 파티션 테이블
    * 저장: 영구 테이블, 임시 테이블
  * 힙 구조 테이블 (Heap-organized Table)
    * 힙(Heap) 구조로 데이터 저장
      * 임의의 위치에 데이터가 저장된다
  ```sql
  CREATE TABLE [schema.]table (
         column datatype [DEFAULT [ON NULL] expr]
  [,     column datatype [DEFAULT [ON NULL] expr]]...)
  ORGANIZATION HEAP;
  ```
  * 인덱스 구조 테이블 (Index-organized Table, IOT)
    * b-tree 구조로 데이터 저장
      * PK 제약 조건의 열 순서에 따라 데이터가 정렬되어 저장된다
    * IOT는 열의 개수가 많지 않은 테이블에 사용해야 한다
      * 보통, 코드성 테이블 혹은 연관 테이블 (Association Table)에 사용한다
    * 인텍스 외부 영역인 오버플로우 영역에 저장될 수 있다
  ```sql
  CREATE TABLE [schema.]table (
         column datatype [DEFAULT [ON NULL] expr]
  [,     column datatype [DEFAULT [ON NULL] expr]]...
   ,     CONSTRAINT contraint_name PRIMARY KEY (column [, column]...))
  ORGANZATION INDEX;
  ```
  ```sql
  CREATE TABLE t1 (c1 NUMBER, c2 NUMBER, CONSTRAINT t1_pk PRIMARY KEY (c1))
  ORGANIZATION INDEX;
  ```
  ```sql
  SELECT object_name, data_object_id, object_type
  FROM   user_objects
  WHERE  object_name IN ('T1', 'T1_PK');
  -- T1, NULL, TABLE
  -- T1_PK, 109065, INDEX
  
  SELECT segment_name, segment_type
  FROM   user_segments
  WHERE  object_name IN ('T1', 'T1_PK');
  -- IOT는 논리적으로 존재하기 때문에, user_segment에서 조회 X
  -- T1_PK, INDEX
  
  SELECT table_name, iot_type FROM user_tables WHERE table_name = 'T1';
  -- T1, IOT
  ```
  * 익스터널 테이블 (External Table)
    * 외부 데이터를 조회하거나 외부에 데이터를 저장할 수 있는 테이블
      * 주로 DW 시스템의 ETL 작업에 사용된다
    * 액세스 드라이버
      * ORACLE_LOADER: SQL*Loader를 통해 외부 파일에 대한 읽기 전용 작업을 수행
      * ORACLE_DATAPUMP: Data Pump를 통해 데이터를 로드(Load) 또는 언로드(Unload)
  ```sql
  CREATE TABLE [schema.]table (
         column datatype [DEFAULT [ON NULL] expr]
  [,     column datatype [DEFAULT [ON NULL] expr]]...)
  ORGANIZATION EXTERNAL (
         [TYPE access_driver_type]
          DEFAULT DIRECTORY directory
         [ACCESS PARAMETERS (opaque_format_spec)]
          LOCATION ([directory:] 'location_specifier'
                 [, [directory:] 'location_specifier']...)
  ) [REJECT LIMIT {integer | UNLIMITED}];
  ```
  ```sql
  -- 디렉토리 생성
  CREATE OR REPLACE DIRECTORY dir_ext AS 'c:\app\ora12cr2\admin\ora12cr2\ext';
  GRANT ALL ON DIRECTORY dir_ext TO scott;
  ```
  ```sql
  -- _directories 뷰
  SELECT owner, directory_name, directory_path
    FROM all_directories
   WHERE directory_name = 'DIR_EXT';
  -- SYS, DIR_EXT, c:\app\ora12cr2\admin\ora12cr2\ext
  ```
  ```sql
  -- _tab_privs 뷰
  SELECT grantee, owner, table_name, grantor, privilege, type
    FROM user_tab_privs
   WHERE table_name = 'DIR_EXT';
  ```
    * ORACLE LOADER
  ```sql
  CREATE TABLE t1 (deptno NUMBER(2), dname VARCHAR2(14), loc VARCHAR2(13))
  ORGANIZATION EXTERNAL(
          TYPE    ORACLE LOADER
          DEFAULT DIRECTORY dir_ext
          ACCESS  PARAMETERS (
                  RECORDS DELIMITED BY NEWLINE
                  NOBADFILE NOLOGFILE NODISCARDFILE
                  FIELDS TERMINATED BY ',')
          LOCATION ('ext_dept.txt')
  ) REJECT LIMIT UNLIMITED;
  ```
  ```sql
  -- _external_tables 뷰
  SELECT type_name, default_dictionary_name, access_parameters
    FROM user_external_tables
   WHERE table_name = 'T1';
  ```
  ```sql
  -- _external_locations 뷰
  SELECT location, directory_name
    FROM user_external_locations
   WHERE table_name = 'T1';
  ```
    * preprocessor: 데이터베이스 서버의 OS 명령어를 수행하고 수행 결과를 테이블로 조회할 수 있다
  ```sql
  CREATE TABLE t1 (deptno NUMBER(2), dname VARCHAR2(14), loc VARCHAR2(13))
  ORGANIZATION EXTERNAL(
          TYPE    ORACLE LOADER
          DEFAULT DIRECTORY dir_ext
          ACCESS  PARAMETERS (
                  RECORDS DELIMITED BY NEWLINE
                  PREPROCESSOR dir_ext:'ext_unzip.cmd'
                  NOBADFILE NOLOGFILE NODISCARDFILE
                  FIELDS TERMINATED BY ',')
          LOCATION ('ext_dept.txt')
  ) REJECT LIMIT UNLIMITED;
  ```
<br>

### 클러스터 테이블 (Clustered Table)
* 클러스터 키가 동일하 데이터는 동일한 위치에 저장하는 세그먼트
  * INDEX: 인덱스 클러스터
  * HASHKEYS integer: 해시 클러스터
  * SINGLE TABLE: 단일 테이블 해시 클러스터
  * SORT: 정렬 해시 클러스터
```sql
CREATE CLUSTER [schema.]cluster (
       column datatype [SORT]
[,     column datatype [SORT]]...)
[{{INDEX | [SINGLE TABLE] HASHKEYS integer [HASH IS expr]}}...]
[TABLESPACE tablespace];
```
```sql
DROP CLUSTER [schema.]cluster [INCLUDING TABLES [CASCADE CONSTRAINTS]];
```
```sql
TRUNCATE CLUSTER [schema.]cluster [{DROP | REUSE} STORAGE];
```
```sql
CREATE TABLE [schema.]table (
       column datatype [DEFAULT [ON NULL] expr]
[,     column datatype [DEFAULT [ON NULL] expr]]...)
CLUSTER cluster (column [, column]...)
```
* 인덱스 클러스터 (Indexed Cluster)
  * 데이터 저장 및 조회에 인덱스 사용
```sql
-- 인덱스 클러스터 생성
DROP CLUSTER c1# INCLUDING TABLES;
CREATE CLUSTER c1# (c1 NUMBER) INDEX;

-- 클러스터 인덱스 생성
DROP INDEX c1#_x1;
CREATE INDEX c1#_x1 ON CLUSTER c1#;

-- 클러스터 테이블 생성
DROP TABLE t1 PURGE;
DROP TABLE t2 PURGE;

CREATE TABLE t1 (c1 NUMBER, c2 NUMBER) CLUSTER c1# (c1);
CREATE TABLE t2 (c1 NUMBER, c2 NUMBER) CLUSTER c1# (c1);
```
```sql
-- 클러스터 정보
SELECT cluster_name, cluster_type 
  FROM user_clusters 
 WHERE cluster_name = 'C1#';

-- 클러스터 테이블 + 클러스터 키
SELECT cluster_name, clu_column_name, table_name, tab_column_name 
  FROM user_clu_columns 
 WHERE cluster_name = 'C1#';

-- 테이블의 클러스터 정보
SELECT table_name, cluster_name 
  FROM user_tables
 WHERE table_name IN ('T1', 'T2');

-- 클러스터 인덱스 정보
SELECT index_type, table_owner, table_name, table_type
  FROM user_indexes
 WHERE index_name = 'C1#_X1';
```
```sql
-- 불가능) 클러스터 테이블은 동일한 클러스터에 속한 다른 테이블과 블록을 공유하기 때문에 개별 테이블 TRUNCATE 불가능
TRUNCATE TABLE t1;
-- ORA-03292: 잘릴 테이블이 클러스터의 일부입니다

-- 가능)
TRUNCATE CLUSTER c1#;
```
* 해시 클러스터 (Hash Cluster)
  * 데이터 저장 및 조회에 해시 알고리즘 사용
```sql
-- 인덱스 클러스터 생성
DROP CLUSTER c1# INCLUDING TABLES;
CREATE CLUSTER c1# (c1 NUMBER) HASHKEYS 100;

CREATE TABLE t1 (c1 NUMBER, c2 NUMBER) CLUSTER c1# (c1);
CREATE TABLE t2 (c1 NUMBER, c2 NUMBER) CLUSTER c1# (c1);
```
```sql
-- 클러스터 정보
SELECT cluster_name, cluster_type, function, hashkeys
  FROM user_clusters 
 WHERE cluster_name = 'C1#';
```
* 단일 테이블 해시 클러스터 (Single-table Hash Cluster)
  * 클러스터에 단일 테이블만 저장할 수 있는 해시 클러스터
```sql
-- 단일 테이블 해시 클러스터 생성
DROP CLUSTER c1# INCLUDING TABLES;
CREATE CLUSTER c1# (c1 NUMBER) SINGLE TABLE HASHKEYS 100;

DROP TABLE t1 PURGE;
CREATE TABLE t1 (c1 NUMBER, c2 NUMBER) CLUSTER c1# (c1);
```
```sql
-- 클러스터 정보
SELECT cluster_name, single_table
  FROM user_clusters 
 WHERE cluster_name = 'C1#';
```
* 정렬 해시 클러스터 (Sorted Hash Cluster)
  * SORT 키워드를 지정한 열로 데이터를 정렬하여 클러스터에 저장한다
```sql
-- 정렬 해시 클러스터 생성
DROP CLUSTER c1# INCLUDING TABLES;
CREATE CLUSTER c1# (c1 NUMBER, c2 NUMBER SORT) HASHKEYS 100 HASH IS c1;

DROP TABLE t1 PURGE;
CREATE TABLE t1 (c1 NUMBER, c2 NUMBER, c3 NUMBER) CLUSTER c1# (c1, c2);
```
```sql
-- 클러스터 정보
SELECT hash_expression
  FROM user_cluster_hash_expression
 WHERE cluster_name = 'C1#';
```

<br>

### 임시 테이블 (Temporary Table)
* 트랜잭션 혹은 세션 레벨로 관리되는 테이블
* OLAP 혹은 DW 시스템에서 중간 집계를 저장하는 용도의 테이블
  * ON COMMIT DELETE ROWS: 트랜잭션 레벨로 데이터를 저장
  * ON COMMIT PRESERVE ROWS: 세션 레벨로 데이터를 저장
```sql
CREATE GLOBAL TEMPORARY TABLE [schema.]table(
       column datatype [DEFAULT [ON NULL] expr]
[,     column datatype [DEFAULT [ON NULL] expr]]...)
[ON COMMIT [DELETE | PRESERVE] ROWS];
```
```sql
--트랜잭션 레벨 관리
DROP TABLE t1 PURGE;
CREATE GLOBAL TEMPORARY TABLE t1(c1 NUMBER) ON COMMIT DELETE ROWS;
INSERT INTO t1 VALUES(1);
SELECT * FROM t1;
--1
COMMIT;
SELECT * FROM t1;
--선택된 래코드가 없습니다
```
```sql
--세션 레벨 관리
DROP TABLE t1 PURGE;
CREATE GLOBAL TEMPORARY TABLE t1(c1 NUMBER) ON COMMIT PRESERVE ROWS;
INSERT INTO t1 VALUES(1);
COMMIT;
SELECT * FROM t1;
--1
--다시 접속
SELECT * FROM t1;
--선택된 래코드가 없습니다
```
* 트랜잭션 혹은 세션 레벨로 관리되기 때문에, 1개의 임시 테이블을 n개의 세션에서 동시에 사용할 수 있다
  * java의 threadlocal 같이 사용되는 듯
  * 각 세션은 자신이 넣은 데이터 1 or 2 중 1개만 조회됨
```sql
--S1
INSERT INTO t1 VALUES(1);
--S2
INSERT INTO t1 VALUES(2);
--S1
COMMIT;
--S2
COMMIT;
--S1
SELECT * FROM t1;
--1
--S2
SELECT * FROM t1;
--2
```

<br>
  
### 열
* 기본 문법
  * ADD절
  ```sql
  ALTER TABLE [schema.]table ADD (column datatype [DEFAULT [ON NULL] expr] 
                              [, column datatype [DEFAULT [ON NULL] expr]]...);
  ```
  ```sql
  DROP TABLE t1 PURGE;
  CREATE TABLE t1 (c1 NUMBER);
  ALTER TABLE t1 ADD (c2 NUMBER(2), c3 VARCHAR2(2));
  ```
  ```sql
  SELECT column_name, data_type, data_length, data_precision, data_scale
    FROM user_tab_columns
   WHERE table_name = 'T1';
  ```
  * MODIFY절
  ```sql
  ALTER TABLE [schema.]table MODIFY (column datatype [DEFAULT [ON NULL] expr] 
                              [, column datatype [DEFAULT [ON NULL] expr]]...);
  ```
  ```sql
  DROP TABLE t1 PURGE;
  CREATE TABLE t1 (c1 NUMBER(2), c2 NUMBER(2), c3 VARCHAR2(2), c4 DATE);
  INSERT INTO t1 VALUES (1, 1, 'A', DATE '2050-01-01');
  COMMIT;

  ALTER TABLE t1 MODIFY (c1 DEFAULT 1);
  -- 정상처리
  ALTER TABLE t1 MODIFY (c2 NUMBER(1));
  -- ORA-01440: 정도 또는 자리수를 축소할 열은 비어 있어야 합니다
  -- NUMBER 타입은 열에 값이 존재하는 경우, 데이터 타입의 길이를 축소할 수 없다
  ALTER TABLE t1 MODIFY (c3 VARCHAR2(1));
  -- 정상처리
  -- VARCHAR2 타입은 열에 값이 존재하는 하더라도 값의 실제크기까지 데이터 타입의 길이를 축소할 수 있다
  ALTER TABLE t1 MODIFY (c2 NUMBER(3), c3 VARCHAR2(3));
  -- 정상처리
  -- 데이터 타입의 길이 늘이는 것은 값의 유무 및 크기와 상관없이 가능
  ALTER TABLE t1 MODIFY (c4 TIMESTAMP);
  -- 정상처리
  -- DATE와 TIMESTAMP 간의 상호변경 가능
  -- 다만, TIMESTAMP -> DATE의 경우, 소수점 이하 초가 유실된다
  ```
  ```sql
  SELECT column_name, data_type, data_length, data_precision, data_scale
    FROM user_tab_columns
   WHERE table_name = 'T1';
  ```
  * RENAME절
  ```sql
  ALTER TABLE [schema.]table RENAME COLUMN old_name TO new_name;
  ```
  ```sql
  ALTER TABLE t1 RENAME COLUMN c4 TO c5;
  ```
  * DROP절
  ```sql
  ALTER TABLE [schema.]table DROP (column [, column]...) 
               [CASCADE CONSTRAINTS] [CHECKPOINT integer];
  ```
  ```sql
  ALTER TABLE t1 DROP (c3, c5);
  ```
  * SET UNUSED절
  ```sql
  ALTER TABLE [schema.]table SET UNUSED (column [, column]...) 
               [CASCADE CONSTRAINTS] [ONLINE];
  ```
  ```sql
  ALTER TABLE t1 SET UNUSED (c2);
  ```
  ```sql
  SELECT * FROM user_unused_col_tabs;

  SELECT column_name, hidden_column FROM user_tab_cols WHERE table_name = 'T1';
  ```
  * DROP절 (UNUSED COLUMNS)
    * UNUSED COLUMNS: 테이블의 미사용 열 모두 삭제
    * COLUMNS CONTINUE: 중단된 지점에서부터 미사용 열의 삭제 작업을 다시 진행
    * CHECKPOINT integer: 체크포인트를 수행할 행의 개수를 지정 (기본값 512)
  ```sql
  ALTER TABLE [schema.]table DROP {UNUSED COLUMNS | COLUMNS CONTINUE}
               [CHECKPOINT integer];
  ```
  ```sql
  ALTER TABLE t1 DROP UNUSED COLUMNS;
  ```
  * DDL 작업
    * TM락 X모드
    * 이슈) 일반 열 삭제
      * 장시간 소요되면 테이블 사용이 제한되면서 장애 발생 가능
    * 차선책) SET UNUSED 변경 후 운영 외 시간에 미사용 열 DROP 하기
    * 일정 규모 이상의 시스템은 정기 PM(Prevention Maintenance) 시점에 DDL 작업 수행
* 데이터 타입
  * 타입 목록
    * 문자: CHAR, VARCHAR2, CLOB, LONG, NCHR, NVARCHAR2, NCLOB
    * 숫자: NUMBER, BINARY_FLOAT, BINARY_DOUBLE
    * 날짜: DATE, TIMESTAMP, INTERVAL
    * 이진: BLOB, BFILE, LONG RAW, RAW
    * 기타: ROWID, UROWID
  * VARCHAR2
    * 가변 길이 문자 데이터 타입 (1 ~ 4000)
      * BYTE: 바이트 크기
      * CHAR: 문자의 길이
    ```sql
    VARCHAR2(size [BYTE|CHAR])
    ```
    ```sql
    SELECT parameter, value
    FROM   v$nls_parameters
    WHERE  parameter IN ('NLS_CHARACTERSET', 'NLS_LENGTH_SEMANTICS');
    ```
    ```sql
    DROP TABLE t1 PURGE;
    CREATE TABLE t1 (c1 VARCHAR2(1), c2 VARCHAR2(1 CHR), c3 VARCHAR2(1 BYTE);

    INSERT INTO t1(c1) VALUES('가');
    -- ORA-12899: ... "C1" 열에 대한 값이 너무 큼 (실제: 2, 최대값: 1)
    INSERT INTO t1(c2) VALUES('가');
    -- 정상처리
    ```
    ```sql
    SELECT column_name, data_type, data_length
      FROM user_tab_columns
      WHERE table_name = 'T1';
    -- c1 1
    -- c2 2
    -- c3 1
    ```
  * NUMBER
    * 가변 길이 숫자 데이터 타입 (1 ~ 22 바이트)
      * p: 정밀도(precision) (범위: 1 ~ 38)
      * s: 스케일(scale) (범위: -84 ~ 127, 기본값: 0)
    ```sql
    NUMBER[(p[,s])];
    ```
      * NUMBER: 부동 소수점
      * NUMBER(2): 정수(-99 ~ 99)
        * 정수부: 2
        * 소수부: 0
      * NUMBER(2,1): 고정 소수점 수(-9.9 ~ 9.9)
        * 정수부: 1
        * 소수부: 1
      * NUMBER(2,2): 고정 소수점 수(-0.99 ~ 0.99)
        * 정수부: 0
        * 소수부: 2
      * NUMBER(1,1): 고정 소수점 수(-0.9 ~ 0.9)
        * 정수부: 0
        * 소수부: 1
      * NUMBER(1,2): 고정 소수점 수(-0.09 ~ 0.09)
        * 정수부: -1
        * 소수부: 2
      * NUMBER(2,-1): 정수(-90 ~ 90)
        * 정수부: 3
        * 소수부: -1
      * NUMBER(2,-2): 정수(-9900 ~ 9900)
        * 정수부: 4
        * 소수부: -2
      * NUMBER(1,-1): 정수(-90 ~ 90)
        * 정수부: 2
        * 소수부: -1
      * NUMBER(1,-2): 정수(-900 ~ 900)
        * 정수부: 3
        * 소수부: -2
    ```sql
    DROP TABLE t1 PURGE;
    CREATE TABLE t1 (c1 NUMBER, c2 NUMBER(3,2));
  
    SELECT column_name, data_type, data_precision, data_scale
      FROM user_tab_columns
     WHERE table_name = 'T1';
    ```
    ```sql
    INSERT INTO t1 (c2) VALUES(9.995);
    -- ORA-01438: 이 열에 대해 지정된 전체 자릿수보다 큰 값이 허용됩니다.
    ```
    ```sql
    INSERT INTO t1 VALUES(4/3, 4/3);
    COMMIT;
  
    SELECT * FROM t1;
    -- c1: 1.3333333333333333333
    -- c2: 1.33
    ```
    ```sql
    SELECT VSIZE(c1) AS c1, VSIZE(c2) AS c2 FROM t1;
    -- c1: 21 (바이트)
    -- c2: 3 (3)
    ```
  * DATE 타입
    * 고정 길이 날짜 데이터 타입 (B.C 4712년 1월 1일 ~ A.D 9999년 12월 31일)
    * 저장 공간 7바이트 사용
  ```sql
    DROP TABLE t1 PURGE;
    CREATE TABLE t1 (c1 DATE);
  
    SELECT column_name, data_type, data_length
      FROM user_tab_columns
     WHERE table_name = 'T1';
    --- C1 DATE 7
  ```
  * TIMESTAMP
    * 가변 길이 날짜 데이터 타입 (소수점 이하 초 단위의 날짜 값 저장 가능)
    * fractional_seconds_precision: 0~9, default(6)
    * 정밀도에 따라 7 ~ 11 바이트 저장 공간 사용
  ```sql
  TIMESTAMP[(fractional_seconds_precision)]
  ```
  ```sql
  DROP TABLE t1 PURGE;
  CREATE TABLE t1 (c1 TIMESTAMP);
  
  SELECT column_name, data_type, data_length, data_scale
    FROM user_tab_columns
   WHERE table_name = 'T1';
  --- C1 TIMESTAMP(6) 11 6
  ```
  * INTERVAL 타입
    * 날짜 값의 기간 저장
    * INTERVAL YEAR TO MONTH: 연, 월 단위의 기간 저장
      * year_precision: 0 ~ 9 default(2)
      * 저장 공간 5바이트 사용
    * INTERVAL DAY TO SECOND: 일, 시, 분, 초 단위의 기간 저장
      * day_precision: 0 ~ 9 default(2)
      * fractional_seconds_precision: 0 ~ 9 default(6)
      * 저장 공간 11바이트 사용
  ```sql
  INTERVAL YEAR[(year_precision)] TO MONTH;
  
  INTERVAL DAY[(day_precision)] TO SECOND[(fractional_seconds_precision)]
  ```
  ```sql
  DROP TABLE t1 PURGE;
  CREATE TABLE t1 (c1 INTERVAL YEAR TO MONTH, c2 INTERVAL DAY TO SECONDS);
  
  INSERT INTO t1 VALUES (INTERVAL '1-11' YEAR TO MONTH
                        ,INTERVAL '1 12:34:56.789' DAY TO SECOND);
  COMMIT;
  ```
  ```sql
  SELECT column_name, data_type, data_length, data_precision, data_scale
    FROM user_tab_columns
   WHERE table_name = 'T1';
  --- C1 INTERVAL YEAR(2) TO MONTH 5 2 0
  --- C2 INTERVAL DAY(2) TO SECONDS(6) 11 2 6
  ```
  ```sql
  -- 날짜 값 연산을 위한 기간 값을 저장하기 위해 사용된다
  SELECT c1, c2
       , TIMESTAMP '2025-01-01 00:00:00' + c1 AS c3
       , TIMESTAMP '2025-01-01 00:00:00' + c2 AS c4
  FROM t1;
  -- c1: +01-11
  -- c2: +01 12:34:56.789000 
  -- c3: 2051-12-01 00:00:00.000000000
  -- c4: 2050-01-02 12:34:56.789000000
  ```
  * CLOB 타입 (Character Large OBject)
    * 가변 길이 문자 타입
    * 최대 (4GB - 1B) * block size 크기의 문자열 저장 가능
  ```sql
  CLOB
  ```
  ```sql
  DROP TABLE t1 PURGE;
  CREATE TABLE t1 (c1 CLOB);
  
  INSERT INTO t1 VALUES (TO_CLOB(LPAD('A', 4000, 'A')) || LPAD('B', 4000, 'B'));
  COMMIT;
  ```
  ```sql
  -- LOB 타입은 별도의 segment와 index가 생성된다
  SELECT column_name, segment_name, index_name
    FROM user_lobs
   WHERE table_name = 'T1';
  
  SELECT segment_name, segment_type
    FROM user_segments
   WHERE segment_name IN (:segment_name, :index_name);
  
  SELECT index_type
    FROM user_indexes
   WHERE index_name = :index_name;
  ```
  ```sql
  --ENABLE STORAGE IN ROW: 4000바이트 이하면 테이블 세그먼트에 저장
  --DISABLE STORAGE IN ROW: 4000바이트 이하도 별도 세그먼트에 저장
  DROP TABLE t2 PURGE;
  CREATE TABLE t2 (c1 CLOB, c2 CLOB)
  LOB(c1) STORE AS (ENABLE STORAGE IN ROW)
  LOB(c2) STORE AS (DISABLE STORAGE IN ROW);
  
  SELECT column_name, in_row 
    FROM user_lobs 
   WHERE table_name = 'T2';
  -- C1 YES
  -- C2 NO
  ```
  ```sql
  -- CLOB 값은 비교 조건 사용 불가능
  SELECT *
   FROM t1
  WHERE c1 = 'A';
  
  -- CLOB 값은 LIKE 조건 사용 가능
  SELECT *
   FROM t1
  WHERE c1 LIKE 'A%';
  ```
  * EMPTY_CLOB 함수
    * null: 로케이터(Locator)와 값(Value)이 없음
    * empty: 로케이터(Locator)는 있음, 값(Value)이 없음
    * populated: 로케이터(Locator)와 값(Value)이 있음
  ```sql
  DROP TABLE PURGE;
  CREATE TABLE t1 (c1 NUMBER, c2 CLOB);
  
  INSERT INTO t1 VALUES (1, NULL);
  INSERT INTO t1 VALUES (2, EMPTY_CLOB());
  INSERT INTO t1 VALUES (3, 'X');
  COMMIT;
  
  SELECT *
    FROM t1
   WHERE c2 IS NULL;
  --null: 1
  
  SELECT *
    FROM t1
   WHERE c2 IS NOT NULL;
  --empty: 2
  --populated: 3 X
  
  SELECT *
    FROM t1
   WHERE length(c2) = 0;
  --empty: 2
  
  SELECT *
    FROM t1
   WHERE NULLIF(length(c2),0) IS NULL;
  --null: 1
  --empty: 2
  ```
  * CHAR타입
    * 고정 길이 문자 데이터 타입
      * 문자열이 데이터 타입의 크기보다 작은 경우 분자열의 뒤쪽을 공백으로 채워서 저장
    * size 범위: 1 ~ 2000 (Default: 1)
      * 크기가 다른 CHAR 타입은 크기가 작은 열의 뒤쪽을 공백으로 채워 동일한 크기로 만든 후 문자열 비교
  ```sql
  CHAR[(size [BYTE | CHAR])]
  ```
  ```sql
    DROP TABLE t1 PURGE;
  CREATE TABLE t1 (c1 CHAR(2), c2 CHAR(3));
  
  INSERT INTO t1 VALUES ('A', 'A');
  INSERT INTO t1 VALUES ('B', 'B ');
  COMMIT;
  
  SELECT c1, c2, c2 || 'Z' AS c3 FROM t1 WHERE c1 = c2;
  -- 데이터 타입의 크기가 다른 CHAR 타입은 크기가 작은 열의 뒤쪽을 공백으로 채워 동일한 크기로 만든 후 문자열을 비교한다
  -- c1(CHAR(2)) vs c2(CHAR(3))
  -- 'A'와 'A'도 동일
  -- 'B'와 'B '도 동일
  -- A A  A  Z
  -- B B  B  Z
  ```
  ```sql
    DROP TABLE t1 PURGE;
  CREATE TABLE t1 (c1 CHAR(2), c2 VARCHAR2(2));
  
  INSERT INTO t1 VALUES ('A', 'A');
  INSERT INTO t1 VALUES ('B', 'B ');
  COMMIT;
  
  SELECT c1, c2, c2 || 'Z' AS c3 FROM t1 WHERE c1 = c2;
  -- 크기가 작은 열의 뒤쪽을 공백으로 채워 동일한 크기로 만든 후 문자열을 비교한다
  -- 'B'와 'B '만 동일
  -- B B
  
  SELECT c1, c2 FROM t1 WHERE TRIM(c1) = c2;
  -- CHAR 타입과 VARCHAR2을 함께 사용하면 TRIM()을 사용하여 불필요한 처리가 필요하다
  -- A A
  ```
  * LONG 타입
    * 가변 길이 문자 타입
    * 저장 공간: 최대 2GB나 (2^31 - 1) 바이
  ```sql
  LONG
  ```
  ```sql
    DROP TABLE t1 PURGE;
  CREATE TABLE t1 (c1 LONG);
  INSERT INTO t1 VALUES ('A');
  COMMIT;
  ```
  ```sql
  -- WHERE 절에 LONG 타입을 사용하면 에러 발생
  SELECT * FROM t1 WHERE c1 ='A' ;
  -- ORA-00997: LONG 데이터 유형은 사용할 수 없습니다
  ```
  ```sql
  -- CREATE TABLE 문에 TO_LOB 함수를 사용하면 LONG 타입을 CLOB 타입으로 변환 가능
  -- INSERT AS SELECT 문에서도 사용 가능
    DROP TABLE t2 PURGE;
  CREATE TABLE t2 AS SELECT TO_LOB(c1) AS c1 FROM t1;
  ```
* 기본값
  * DEFAULT: 지정되지 않거나 DEFAULT 키워드가 기술된 경우 expr을 입력
  * DEFAULT ON NULL: 지정되지 않거나 DEFAULT 키워드나 NULL이 기술된 경우 expr을 입력
  ```sql
    DROP TABLE t1 PURGE;
  CREATE TABLE t1 (c1 NUMBER , c2 NUMBER DEFAULT 2, c3 NUMBER DEFAULT ON NULL 3);
  INSERT INTO t1 (c1) VALUES (1);
  INSERT INTO t1 VALUES (2, DEFAULT , DEFAULT);
  INSERT INTO t1 VALUES (3, NULL , NULL);
  COMMIT;
  
  ALTER TABLE t1 MODIFY c2 DEFAULT 1 NOT NULL;
  -- ORA-02296: () 사용으로 설정 불가 - 널 값이 발견되었습니다.
  ```
  ```sql
  -- MODIFY: 새로운 열부터 DEFAULT 값 적용되어 적재
  ALTER TABLE t1 MODIFY c3 DEFAULT 1;
  - ADD: 기존 열과 새로운 열 모두 DEFAULT 값 적용되어 적재
  ALTER TABLE t1 ADD (c4 NUMBER DEFAULT 1 NOT NULL);
  ALTER TABLE t1 ADD (c5 NUMBER DEFAULT 1 NULL);
  INSERT INTO t1 (c1) VALUES (2);
  COMMIT;
  ```
* Metadata-Only DEFAULT
  * 테이블에 기본값이 지정된 열을 추가하면 기존 행을 갱신해야 하기 때문에 DDL문이 장시간 수행되어 장애 발생 가능
  * 따라서, 11.1버전부터는 NOT NULL 칼럼을 추가하면 메타데이터만 반영하고, 12.1버전부터는 NULLABLE 칼럼도 베마타데이터반 반영한다
* 열 유형
  * VIRTUAL 칼럼
    * 물리적으로 저장되지 않는 칼럼
  ```sql
  column [datatype] [GENERATED ALWAYS] AS (column_expression) [VIRTUAL]
  ```
  ```sql
  DROP TABLE t1 PURGE;
  CREATE TABLE t1 (
    c1 NUMBER
  , c2 NUMBER
  , c3 NUMBER GENERATED ALWAYS AS (c1 + c2) VIRTUAL);
  INSERT INTO t1 (c1, c2) VALUES (1, 2);
  
  SELECT * FROM t1;
  -- 1 2 3

  INSERT INTO t1 (c3) VALUES (3);
  -- ORA-54013: INSERT 작업은 가상 열에서 허용되지 않습니다.
  ```
  ```sql
  SELECT column_name, data_type, column_id, data_default, virtual_column, segment_column_id
  FROM   user_tab_cols
  WHERE  table_name = 'T1'
  ORDER BY internal co1umn id;
  -- c1 NUMBER 1       NO  1
  -- c2 NUMBER 2       NO  2
  -- c3 NUMBER 2 C1+C2 YES 2
  ```
  * INVISIBLE 칼럼
    * 숨겨진 칼럼
  ```sql
  column [datatype] [VISIBLE|INVISIBLE]
  ```
  ```sql
    DROP TABLE t1 PURGE;
  CREATE TABLE t1 (c1 NUMBER INVISIBLE, c2 NUMBER);

  -- INSERT문에 열 목록을 지정하지 않으면 VISIBLE 칼럼에만 데이터가 입력된다
  INSERT INTO t1 VALUES (1);
  INSERT INTO t1 (c1, c2) VALUES (2, 2);

  -- 조회칼럼: c2
  SELECT * FROM t1;
  -- 1
  -- 2
  -- 조회칼럼: c1, c2
  SELECT c1, c2 FROM t1;
  --   1
  -- 2 2
  ```
  ```sql
  SELECT column_name, column_id, segment_column_id, internal_column_id, hidden_co1umn
  FROM   user_tab_cols
  WHERE  table_name = 'T1'
  ORDER BY interna1_co1umn_id;
  -- C1   1 1 YES
  -- C2 1 2 2 NO

  ALTER TABLE t1 MODIFY c1 VISIBlE;

  -- column_id 값이 마지막 column_id 값에 이어서 부여된다
  SELECT column_name, column_id, segment_column_id, internal_column_id, hidden_co1umn
  FROM   user_tab_cols
  WHERE  table_name = 'T1'
  ORDER BY interna1_co1umn_id;
  -- C1 2 1 1 NO
  -- C2 1 2 2 NO

  -- 오라클은 column_id 순서대로 열을 반환한다
  SELECT * FROM t1;
  -- 1
  -- 2 2

  ALTER TABLE t1 MODIFY c2 INVISIBLE;
  ALTER TABLE t1 MODIFY c2 VISIBLE;

  SELECT * FROM t1;
  --   1
  -- 2 2
  
  -- column_id 열이 변경된 것을 확인할수 있다
  SELECT column_name, column_id, internal_column_id
    FROM user_tab_cols
   WHERE table_name = 'T1'
   ORDER BY internal_column_id;
  -- C1 1 1 
  -- C2 2 2
  ```
<br>

### 제약 조건 (constraint)
* 데이터 무결성을 보장할 수 있는 기능
* 테이블에 다수의 제약 조건 생성 가능
* 기본 문법
  * inline 방식 (열 레벨)
    ```sql
    DROP TABLE t1 PURGE;
    CREATE TABLE t1(c1 NUMBER CONSTRAINT t1_c1 NOT NULL);
    ```
  * out of line 방식 (테이블 레벨)
    ```sql
    DROP TABLE t1 PURGE;
    CREATE TABLE t1(c1 NUMBER, c2 NUMBER, CONSTRAINT t1_c1 CHECK(c1 > c2));
    
    DROP TABLE t1 PURGE;
    CREATE TABLE t1(c1 NUMBER);
    ALTER TABLE t1 ADD CONSTRAINT t1_pk PRIMARY KEY(c1);
    ```
  * ADD 절
    ```sql
    ALTER TABLE [schema.]table ADD {out_of_line_constraint}...;
    ```
    ```sql
    DROP TABLE t1 PURGE;
    CREATE TABLE t1 (c1 NUMBER NOT NULL, c2 NUMBER);
    ALTER TABLE t1 ADD CONTRAINT t1_pk PRIMARY KEY(c1);
    ```
  * MODIFY 절
    ```sql
    ALTER TABLE [schema.]table MODIFY CONTRAINT constraint_name [INITIALLY {IMMEDIATE|DEFERRED}] [ENABLE|DISABLE] [VALIDATE|NOVALIDATE] [CASCADE];
    ```
  * RENAME 절
    ```sql
    ALTER TABLE [schema.]table RENAME CONTRAINT old_name TO new_name;
    ```
    ```sql
    ALTER TABLE t1 RENAME CONTRAINT t1_pk TO t1_u1;
    ```
  * DROP 절
    * CASCADE: 참조하고 있는 FK 제약 조건을 함께 삭제
    * KEEP INDEX: 제약 조건을 삭제할 때 제약 조건이 사용하고 있는 인덱스 유지 
    * DROP INDEX: 제약 조건을 삭제할 때 제약 조건이 사용하고 있는 인덱스 삭제
    ```sql
    ALTER TABLE [schema.]table DROP CONTRAINT constraint_name 
    [CASCADE] 
    [{KEEP|DROP} INDEX]
    [ONLINE];
    ```
* 제약 조건 유형
  * NOT NULL 제약 조건
    * 지정한 열에 널이 존재하지 않는 것을 보장
      ```sql
      ALTER TABLE [schema.]table MODIFY column [CONSTRAINT constraint_name] [NOT] NULL;
      ```
      ```sql
      DROP TABLE t1 PURGE;
      CREATE TABLE t1 (c1 NUMBER CONSTRAINT t1_n1 NOT NULL, c2 NUMBER, c3 NUMBER);
      INSERT INTO t1 (c1) VALUES(NULL);
      -- ORA-01400: NULL을 ("SCOTT"."T1"."C1") 안에 삽입할 수 없습니다
      ```
      ```sql
      ALTER TABLE t1 MODIFY (c2 NOT NULL , c3 DEFAULT 0 NOT NULL);
      INSERT INTO t1 (c1, c2) VALUE5 (1, 1);
      ```
      ```sql
      SELECT column_name, nullable
        FROM user_tab_columns
       WHERE table_name = 'T1';
      ```
      ```sql
      SELECT constraint_name, constraint_type, search_condition_vc, generated
        FROM user_constraints
       WHERE table name = 'T1'
       ORDER BY search_condition_vc;
      -- C: NOT NULL 제약 조건 13 ， CHECK 제약 조건
      -- U: UNIQUE 제약 조건
      -- P: PK 제약 조건
      -- R: FK 제약 조건
      -- V: 뷰에 대한 WITH CHECK OPTION
      -- O: 뷰에 대한 WITH READ ONLY
      ```
  * UNIQUE 제약 조건
    * 열이나 열의 조합이 고유한 것을 보장
      ```sql
      ALTER TABLE [schema.]table ADD CONSTRAINT contraint_name UNIQUE (column [, column]...);
      ```
      ```sql
        DROP TABLE t1 PURGE;
      CREATE TABLE t1 (c1 NUMBER, c2 NUMBER, CONSTRAINT t1_u1 UNIQUE (c1, c2));
      ```
      ```sql
      INSERT INTO t1 VALUES (NULL, NULL);
      INSERT INTO t1 VALUES (NULL, NULL);
      INSERT INTO t1 VALUES (1, NULL);
      INSERT INTO t1 VALUES (1, NULL);
      -- ORA-00001: 무결성 제약 조건 (SCOTT.T1_U1) 에 위배됩니다
      ```
      ```sql
      SELECT constraint_name, constraint_type, index_owner, index_name
        FROM user_constraints
       WHERE table_name = 'T1'
       ORDER BY constraint_name;
      ```
  * PK 제약 조건
    * 열이나 열의 조합으로 행을 고유하게 식별할 수 있는 것을 보장
      * UNIQUE 제약조건과 달리 PK 제약조건은 테이블에 하나만 생성
      ```sql
      ALTER TABLE [schema.]table ADD CONSTRAINT contraint_name PRIMARY KEY (column [, column]...);
      ```
      ```sql
        DROP TABLE t1 PURGE;
      CREATE TABLE t1 (c1 NUMBER , c2 NUMBER);
       ALTER TABLE t1 ADD CONSTRAINT t1_pk PRIMARY KEY (c1);

      INSERT INTO t1 VALUES (1, 1);
      INSERT INTO t1 VALUES (1, 2);
      -- ORA-00001 : 무결성 제약 조건 (SCOTT.T1_PK)에 위배됩니다

      INSERT INTO t1 VALUES (NULL, 3);
      -- ORA-01400: NULL을 ("SCOTT" . "T1". "C1")안에 삽입할 수 없습니다
      ```
      ```sql
      SELECT constraint_name, constraint_type, index_owner, index_name
        FROM user_constraints
       WHERE table_name = 'T1';
      ```
      ```sql
      SELECT column_name, nullable FROM user_tab_columns WHERE table_name = 'T1';
      ```
      ```sql
        DROP TABLE t1 PURGE;
      CREATE TABLE t1 (c1 NUMBER NOT NULL, c2 NUMBER, CONSTRAINT t1_pk PRIMARY KEY (c1));
      ```
    * PK 제약 조건과 NOT NULL 제약 조건
      * PK 제약 조건과 NOT NULL 제약 조건은 별도의 제약 조건이다
    * 중복 값 삭제
      * 중복 값이 존재하지 않아야 PK 제약 조건 생성 가능
      * 중복 값이 존재한다면 중복값 삭제 필요
  * FK 제약 조건
    * 모 테이블과 자식 테이블의 참조 무결성 보장
      * NO ACTION: 에러가 발생함
      * CASCADE: 자식 테이블의 행을 갱신 또는 삭제함
      * SET NULL: 자식 테이블의 행의 값을 널로 설정함
      * SET DEFAULT: 자식 테이블의 행의 값을 기본값으로 설정함
      * RESTRICT: 참조하는 행을 갱신 또는 삭제할 수 없음
      ```sql
      ALTER TABLE [schema.]table ADD CONSTRAINT contraint_name
      FOREIGN KEY (column [, column]...)
      REFERENCES [schema.]object [(column [, column]...)
      [ON DELETE {CASCADE | SET NULL}];
      ```
      ```sql
      DROP TABLE t1 CASCADE CONSTRAINTS PURGE;
      DROP TABLE t2 CASCADE CONSTRAINTS PURGE;
      DROP TABLE t3 CASCADE CONSTRAINTS PURGE;
      DROP TABLE t4 CASCADE CONSTRAINTS PURGE;

      CREATE TABLE t1 (c1 NUMBER, c2 NUMBER, CONSTRAINT t1_pk PRIMARY KEY (c1));
      CREATE TABLE t2 (c1 NUMBER);
      CREATE TABLE t3 (c1 NUMBER);
      CREATE TABLE t4 (c1 NUMBER);
      ```
    * FK 제약 조건에서 참조하는 부모 테이블의 열은 UNIQUE 제약조건이나 PK 제약조건이 생성되어 있어야 한다
      ```sql
      ALTER TABLE t2 ADD CONSTRAINT t2_f1 FOREIGN KEY (c1) REFERENCES t1 (c2);
      -- ORA-02270: 이 열목록에 대해 일치하는 고유 또는 기본 키가 없습니다.
      ```
      ```sql
      ALTER TABLE t2 ADD CONSTRAINT t2_f1 FOREIGN KEY (c1) REFERENCES t1 (c1);
      ALTER TABLE t3 ADD CONSTRAINT t3_f1 FOREIGN KEY (c1) REFERENCES t1 (c1)
      ON DELETE CASCADE;
      ALTER TABLE t4 ADD CONSTRAINT t4_f1 FOREIGN KEY (c1) REFERENCES t1 (c1)
      ON DELETE SET NULL;
      ```
    * 부모 태이블에 존재하지 않는 값을 자식 테이블에 입력 불가능
      ```sql
      INSERT INTO t2 VALUES (1);
      -- ORA-02291 : 무결성 제약조건(SCOTT.T1_F1)이 위배되었습니다- 부모 키가 없습니다`
      ```
    * 자식 테이블이 참조하고 있는 부모 테이블의 값은 갱신 불가능
      ```sql
      INSERT INTO t1 VALUES (1, 1);
      INSERT INTO t2 VALUES (1);
      UPDATE t1 SET c1=2 WHERE c1=1;
      -- ORA-02292: 무결성 제약조건(SCOTT.T2_F1)이 위배되었습니다- 자식 레코드가 발견되었습니다
      ```
    * 자식 테이블이 참조하고 있는 부모 테이블의 값은 삭제 불가능
      ```sql
      DELETE FROM t1 WHERE c1 = 1;
      -- ORA-02292: 무결성 제약조건(SCOTT.T2_F1)이 위배되었습니다- 자식 레코드가 발견되었습니다
      ```
      ```sql
      INSERT INTO t1 VALUES (2, 2);
      INSERT INTO t3 VALUES (2);
      INSERT INTO t4 VALUES (2);

      DELETE FROM t1 WHERE c1 = 2;
      SELECT * FROM t3;
      -- 선택된 레코드가 없습니다
      SELECT * FROM t4;
      -- NULL
      ```
    * DELETE_RULE
      * NO ACTION: 자식 테이블이 참조하고 있는 부모 테이블의 값은 삭제 불가능
      * CASCADE: 자식 테이블이 참조하고 있는 부모 테이블의 값이 삭제되면 자식 테이블의 값도 삭제
      * SET NULL: 자식 테이블이 참조하고 있는 부모 테이블의 값이 삭제되면 자식 테이블의 값은 NULL값으로 갱신
      ```sql
      SELECT constraint_name, constraint_type, r_owner, r_constraint_name, delete_rule
        FROM user_constraints
       WHERE table_name IN ('T2','T3','T4')
       ORDER BY constraint_name;
      ```
    * 삭제할 열을 참조하고 있는 자식 테이블의 FK 제약 조건을 함께 삭제 가능
      ```sql
      ALTER TABLE t1 DROP COLUMN c1;
      -- ORA-12992: 부모 키 열을 삭제할 수 없습니다

      ALTER TABLE t1 DROP COLUMN c1 CASCADE CONSTRAINTS;
      ```
    * 삭제할 태이블을 참조하는 자식 테이블의 FK 제약 조건을 함께 삭제 가능
      ```sql
      DROP TABLE t1 PURGE;
      -- ORA-02449: 외래 키에 의해 참조되는 고유/기본 키가 테이블에 있습니다

      DROP TABLE t1 CASCADE CONSTRAINTS PURGE;
      ```
    * FK 제약 조건과 인덱스
      * FK 제약 조건을 생성한 열은 반드시 인덱스를 생성해야 한다
        * 인덱스를 생성하지 않으면 블로킹으로 인한 장애가 발생할 수 있다
      * 서로 다른 값을 갱신해도 블로킹이 발생하는 것을 확인할 수 있다
      ```sql
      DROP TABLE t1 CASCADE CONSTRAINTS PURGE;
      DROP TABLE t2 CASCADE CONSTRAINTS PURGE;

      CREATE TABLE t1 (c1 NUMBER, CONSTRAINT t1_pk PRIMARY KEY(c1));
      CREATE TABLE t2 (c1 NUMBER, c2 NUMBER
                      , CONSTRAINT t2_PK PRIMARY KEY (c1)
                      , CONSTRAINT t2_F1 FOREIGN KEY (c2) REFERENCES t1 (c1));

      INSERT INTO t1 VALUES (1);
      INSERT INTO t1 VALUES (2);
      INSERT INTO t1 VALUES (3);
      INSERT INTO t2 VALUES (1, 1);
      
      COMMIT;
      ```
      ```sql
      --S1
      UPDATE t2 SET c2=2 WHERE c1=1;
      --S2
      UPDATE t1 SET c1=4 WHERE c1=3;
      --블로킹 발생 O
      --S1
      ROLLBACK;
      --S2
      ROLLBACK;
      ```
      ```sql
      CREATE INDEX t2_x1 ON t2(c2);

      --S1
      UPDATE t2 SET c2=2 WHERE c1=1;
      --S2
      UPDATE t1 SET c1=4 WHERE c1=3;
      --블로킹 발생 X
      --S1
      ROLLBACK;
      --S2
      ROLLBACK;
      ```
  * CHECK 제약 조건
    * 열에 저장된 값이 condition 을 만족하는 것을 보장
      ```sql
      ALTER TABLE [schema.]table ADD CONSTRAINT constraint_name CHECK (condition);
      ```
      ```sql
      DROP TABLE t1 PURGE;
      CREATE TABLE t1 (c1 NUMBER, c2 NUMBER, CONSTRAINT t1_c1 CHECK (c1 < c2));

      INSERT INTO t1 VALUES (1, 2);
      INSERT INTO t1 VALUES (2, NULL);
      INSERT INTO t1 VALUES (3, 2);
      -- ORA-02290: 체크 제약조건(SCOTT.T1_C1)이 위배되었습니다
      ```
      ```sql
      DROP TABLE t1 PURGE;
      CREATE TABLE t1 (c1 VARCHAR2(8));
      
      ALTER TABLE t1 ADD CONSTRAINT t1_c1
                              CHECK (c1=TO_CHAR(TO_DATE(c1, 'YYYYMMDD'), 'YYYYMMDD'));
      ALTER TABLE t1 ADD CONSTRAINT t1_c1
                              CHECK (VALIDATE_CONVERSION(c1 AS DATE , 'YYYYMMDD')=1);
      
      INSERT INTO t1 VALUES ('20500131');
      INSERT INTO t1 VALUES ('20500132');
      -- ORA-01847: 달의 날짜는 1 에서 말일 사이어야 합니다
      ```
      ```sql
      SELECT constraint_name, constraint_type, search_condition_vc
      FROM   user constraints
      WHERE  table_name = 'T1';
      ```
* 제약 조건 상태
  * 제약 조건 지연 
    * NOT DEFERRABLE: IMMEDIATE > 지연 불가, 즉시 검사 (기본값)
    * DEFERRABLE: IMMEDIATE > 지연 가능, 즉시 검사
    * DEFERRABLE: DEFERRED > 지연 가능, 커밋 수행 시 검사
    ```sql
    ALTER TABLE [schema.]table MODIFY CONSTRAINT constraint_name INITIALLY {IMMEDIATE|DEFERRED};
    ```
    ```sql
    DROP TABLE t1 PURGE;
    CREATE TABLE t1 (c1 NUMBER CON5TRAINT t1_n1 NOT NULL);
    
    SELECT deferrable, deferred FROM user_constraints WHERE table_name = 'T1';
    -- NOT DEFERRABLE, IMMEDIATE
    ```
    ```sql
    ALTER TABLE t1 DROP CONSTRAINT t1_n1;
    ALTER TABLE t1 MODIFY c1 CONSTRAINT t1_n1 NOT NULL DEFERRABLE;

    SELECT deferrable, deferred FROM user_constraints WHERE table_name = 'T1';
    -- DEFERRABLE, IMMEDIATE

    INSERT INTO t1 VALUE5 (NULL);
    -- ORA-02290: 체크 제약조건 (SCCOT.T1_N1) 위배되었습니다
    ```
    ```sql
    ALTER TABLE t1 DROP CONSTRAINT t1_n1;
    ALTER TABLE t1 MODIFY c1 CONSTRAINT t1 n1 NOT NULL DEFERRED;

    SELECT deferrable, deferred FROM user_constraints WHERE table_name = 'T1';
    -- NOT DEFERRABLE, DEFERRED

    INSERT 1NTO t1 VALUES (NULL);
    COMMIT;
    -- ORA-02091: 트랜잭션이 롤백되었습니다
    -- ORA-02290: 체크 제약조건(SCOTT.T1_N1)이 위배되었습니다
    ```
  * 제약조건 활성
    * ENABLE VALIDATE > 제약 조건 활성, 데이터 검증 (기본값)
    * DISABLE NOVALIDATE > 제약 조건 비활성, 데이터 미검증
    * ENABLE NOVALIDATE > 제약 조건 활성, 데이터 미검증
    * DISABLE VALIDATE > 제약 조건 비활성, 데이터 검증
    ```sql
    ALTER [schema.]table MODIFY CONSTRAINT constraint_name
    [ENABLE|DISABLE] [VALIDATE | NOVALIDATE];
    ```
    ```sql
    DROP TABLE t1 PURGE;
    CREATE TABLE t1 (c1 NUMBER, c2 NUMBER CONSTRAINT t1_n1 NOT NULL);
    
    SELECT status, validated 
      FROM user_constraints 
     WHERE table_name='T1';
    -- ENABLE, VALIDATE
    
    INSERT INTO t1 VALUES (1, 1);
    INSERT INTO t1 VALUES (2, NULL);
    -- ORA-01400: NULL을 ("SCOTT", "T1", "C2")안에 삽입할 수 없습니다
    ```
    ```sql
    ALTER TABLE t1 MODIFY CONSTRAINT t1_n1 DISABLE;
    
    SELECT status, validated 
      FROM user_constraints 
     WHERE table_name='T1';
    -- DISABLE, NOVALIDATE

    INSERT INTO t1 VALUES (1, 1);
    -- DISABLED NOVALIDATE --> 제약 조건을 위배한 데이터를 입력해도 에러 발생 X
    INSERT INTO t1 VALUES (2, NULL);
    -- 다시 활성화하면 검증에 걸린다; 이미 NULL값이 INSERT되어 있기 때문
    ALTER TABLE t1 MODIFY CON5TRAINT t1_n1 ENABLE;
    -- ORA-02293: (SCOTT.t1_n1)을 검증할 수 없습니다-잘못된 제약을 확인합니다

    -- ENABLE NOVALIDATE --> 이미 INSERT된 데이터에 대한 제약 조건 검증 X -->  검증 에러 발생 X
    ALTER TABLE t1 MODIFY CONSTRAINT t1_n1 ENABLE NOVALIDATE;

    -- ENABLE NOVALIDATE --> 앞으로 INSERT될 데이터에 대한 제약 조건 검증 O --> 검증 에러 발생 O
    INSERT INTO t1 VALUES(3, NULL);
    -- ORA-01400: NULL을 ("SCOTT"."T1"."C2") 안에 삽입할 수 없습니다

    DELETE FROM t1 WHERE c2 1S NULL;
    -- ENABLE VALIDATE --> 이미 INSERT된 데이터에 대한 제약 조건 검증 O --> 앞선 DELETE문에서 NULL값 제거 --> 검증 에러 발생 X
    ALTER TABLE t1 MODIFY CONSTRA1NT t1_n1 ENABLE;

    -- DISABLE VALIDATE --> 
    ALTER TABLE t1 MODIFY CONSTRAINT t1_n1 DISABLE VALIDATE

    INSERT INTO t1 VALUES (4, 4);
    -- ORA-25128: 사용 안함으로 설정되고 검증된 제약 조건(SCOTT.T1_N1)을 사용하여 테이블에서 삽입/갱신/삭제 작업이 수행되지 않았습니다
    ```

<br>

### 인덱스
* 유형
  * 일반 인덱스: b-tree 구조에 정렬된 열 값과 ROWID를 저장하는 인덱스
    * IOT: 인덱스 구조 테이블 (index-organized table)
    * 리버스 키 인덱스: 열 값이 반전(reverse) 되어 저장된 인덱스
    * 내림차순 인덱스: 열의 일부가 역순으로 정렬된 인덱스
    * 클러스터 인덱스: 인텍스 클러스터의 검색을 위해 사용되는 인덱스
  * 비트맵 인덱스: 비트맵을 사용하여 열 값을 저장하는 인덱스
  * 함수 기반 인덱스: 열의 일부에 함수나 표현식을 사용한 인덱스
  * 도메인 인덱스: 애플러케이션 도메인에 따라 사용자가 생성할 수 있는 인덱스
* 열의 개수
  * 단일(Single) 인덱스: 1개의 열로 구성된 인덱스
  * 복합(Composite) 인덱스: 2개 이상의 열로 구성된 인덱스
* 값의 고유성
  * UNIQUE 인덱스: 고유한 값으로 구성된 인덱스
  * NON-UNIQUE 인덱스: 고유하지 않을 수 있는 값으로 구성된 인텍스
* 기본 문법
  * CREATE INDEX
    ```sql
    CREATE [UNIQUE] INDEX [schema.]index ON [schema.]table [t_alias]
           ({column | column_expression} [ASC | DESC]
         [, {column | column_expression} [ASC | DESC]]...)
            [USABLE | UNUSABLE] [{ONLINE | REVERSE}] [TABLESPACE tablespace];
    ```
    ```sql
    DROP TABLE t1 PURGE;
    CREATE TABLE t1 (c1 NUMBER, c2 NUMBER, c3 NUMBER);

    CREATE UNIQUE INDEX t1_u1 ON t1 (c1);
    CREATE INDEX t1_x1 ON t1 (c2, c3);

    SELECT index_name, index_type, uniqueness
    FROM   user_indexes
    WHERE  table_name = 'T1';
    -- T1_U1 NORMAL UNIQUE
    -- T1_X1 NORMAL NONUNIQUE

    -- 인덱스 열 구성도 조회 가능
    SELECT index_name, column_name, column_position, descend
    FROM user_ind_columns
    WHERE table name = 'T1'
    ORDER BY index_name, column_position;
    ```
  * ALTER INDEX
    * UNUSABLE (인덱스 사용 불가능 && DML 불가능)
      ```sql
      ALTER INDEX [schema.]index UNUSABLE [ONLINE];
      ```
      ```sql
      ALTER INDEX t1_x1 UNUSABLE;

      SELECT index_name, status
      FROM   user_indexes
      WHERE  table_name = 'T1';
      -- T1_U1 VALID
      -- T1_X1 UNUSABLE

      INSERT INTO t1 VALUES (1, 1, 1);

      ALTER INDEX t1_u1 UNUSABLE;
      -- UNIQUE 인텍스가 비활성화되면 테이블에 데이터를 입력 불가능
      INSERT INTO t1 VALUES (2, 2, 2);
      -- ORA-01502: 인덱스 SCOTT.T1_U1 또는 인덱스 분할영역은 사용할 수 없은 상태입니다
      ```
    * REBUILD (단편화 해소 or 테이블스페이스 변경)
      ```sql
      ALTER INDEX [schema.]index REBUILD [ONLINE] [TABLESPACE tablespace];
      ```
      ```sql
      ALTER INDEX t1_u1 REBUILD;
      ALTER INDEX t1_x1 REBUILD;

      -- UNUSABLE --> VALID로 상태 변경
      SELECT index_name, status
      FROM   user_indexes
      WHERE  table_name = 'T1';
      -- T1_U1 VALID
      -- T1_X1 VALID
      ```
    * 인덱스와 DML 작업
      * 인덱스는 DML 작업의 성능을 저하시킨다
      * 대량 데이터를 입력해야 하는 경우, 인덱스를 UNUSABLE 상태로 변경하고, 데이터를 입력한 후, 다시 인덱스를 REBUILD하는 방식 사용 가능
      * 하지만, UNIQUE 인덱스를 UNUSABLE 상태로 변경하면 데이터 입력할 수 없기 때문에 삭제 후 재성생해야 한다
      * 재생성을 위회하기 위해서 DW 시스템에서는 NONUNIQUE 인덱스로 PK 제약 조건을 생성하기도 한다
    * RENAME
      ```sql
      ALTER INDEX [schema.]index RENAME TO new_name;
      ```
      ```sql
      ALTER INDEX t1_x1 RENAME TO t1_x2;

      SELECT index_name
      FROM   user_indexes
      WHERE  table name = 'T1';
      ```
  * DROP INDEX
    ```sql
    DROP INDEX [schema.]index [ONLINE];
    ```
    ```sql
    DROP INDEX t1_x2;
    ```
    ```sql
    SELECT index_name
    FROM   user_indexes
    WHERE  table name = 'T1';
    ```
* 인덱스 유형
  * 비트맵 인덱스 (Bitmap Index)
    * 비트맴을 사용하여 인덱스 열 값을 저장하는 인덱스
    * 보통, DW 시스템에서 사용되며, OLTP 시스템에서는 사용하지 않는 것이 일반적
      ```sql
      DROP TABLE t1 PURGE;
      DROP TABLE t2 PURGE;
      
      CREATE TABLE t1 (c1 NUMBER, c2 NUMBER, CONSTRAINT t1_pk PRIMARY KEY (c1));
      CREATE TABLE t2 (c1 NUMBER, c2 NUMBER, CONSTRAINT t2_pk PRIMARY KEY (c1));
  
      CREATE BITMAP INDEX t1_x1 ON t1 (c2);
      CREATE BITMAP INDEX t1_x2 ON t1 (t2.c2) FROM t1, t2 WHERE t2.c1 = t1.c1;
      ```
      ```sql
      SELECT index_name, index_type, uniqueness, join_index
      FROM   user_indexes
      WHERE  table_name = 'T1';
      -- T1_PK NORMAL UNIQUE    NO
      -- T1_X1 B1TMAP NONUNIQUE NO
      -- T1_X2 B1TMAP NONUNIQUE YES
      ```
      ```sql
      SELECT index name, inner_table_name, inner_table_column, outer_table_name, outer_table_column
      FROM   user_join_ind_columns;
      ```
      ```sql
      DROP TABLE t1 PURGE;
      CREATE TABLE t1 (c1 NUMBER, c2 NUMBER, CONSTRAINT t1_pk PRIMARY KEY (c1))
      ORGANIZATION INDEX;
      CREATE BITMAP INDEX t1_x1 ON t1 (c2);
      -- ORA-28669: 매핑 테이블이 없는 I0T에 비트맴 인덱스를 생성할 수 없음
      ```
      ```sql
      DROP TABLE t1 PURGE;
      CREATE TABLE t1 (c1 NUMBER, c2 NUMBER, CONSTRAINT t1_pk PRIMARY KEY (c1))
      ORGANIZATION INDEX
      MAPPING TABLE;
      CREATE BITMAP INDEX t1_x1 ON t1 (c2);
      ```
      ```sql
      SELECT b.object_name, b.object_id, b.object_type
      FROM   user_objects a, user_objects b
      WHERE  a.object_name = 'T1'
      AND    b.object_name = 'SYS_IOT_MAP' || a.object_id;
      ```
  * 함수 기반 인덱스 (Function-based Index)
    * 인덱스 열의 일부에 함수나 표현식을 사용한 인덱스
      ```sql
      DROP TABLE t1 PURGE;
      CREATE TABLE t1 (c1 NUMBER , c2 NUMBER);
      
      CREATE INDEX t1_x1 ON t1 (c1 + c2);
      CREATE BITMAP INDEX t1_x2 ON t1(TRUNC(c1));
      ```
      ```sql
      SELECT index_name, index_type
      FROM   user_indexes
      WHERE  table_name = 'T1';
      -- T1_X1, FUNCTION-BASED NORMAL
      -- T1_X2, FUNCTION-BASED BITMAP
  
      SELECT *
      FROM   user_ind_expressions
      WHERE  table_name = 'T1';
      -- T1_X1, T1, "C1"+"C2", 1
      -- T1_X2, T1, TRUNC("C1"), 1
  
      SELECT index_name, column_name
      FROM   user_ind_columns
      WHERE  table_name = 'T1';
      -- T1_X1, SYS_NC00003$
      -- T1_X2, SYS_NC00004$
  
      SELECT column_name, data_default, hidden_column, virtual_column, user_generated
      FROM   user_tab_cols
      WHERE  table name = 'T1';
      -- C1,,NO,NO,YES
      -- C2,,NO,NO,YES
      -- SYS_NC00003$,"C1"+"C2",YES,YES,NO
      -- SYS_NC00004$,TRUNC("C1"),YES,YES,NO
      ```
  * 내림차순 인텍스 (Descending Index)
    * 인덱스 열의 일부를 내림차순으로 정렬한 인덱스
      ```sql
      DROP TABLE t1 PURGE;
      CREATE TABLE t1 (c1 NUMBER, c2 NUMBER);
      CREATE INDEX t1_x1 ON t1 (c1, c2 DESC);
      ```
      ```sql
      SELECT index_name, index_type
      FROM   user_indexes
      WHERE  table_name = 'T1';
      -- T1_X1, FUNCTION-BASED NORMAL
      ```
  * 리버스 키 인덱스 (Reverse Key Index)
    * 인덱스 열의 바이트를 반전시킨 일반 인덱스
      ```sql
      DROP TABLE t1 PURGE;
      CREATE TABLE t1 (c1 NUMBER, c2 NUMBER);
      CREATE INDEX t1_x1 ON t1 (c1) REVERSE;
      CREATE INDEX t1_x2 ON t1 (c1 + c2) REVERSE;
      ```
      ```sql
      SELECT index_name, index_type
      FROM   user_indexes
      WHERE  table_name = 'T1';
      -- T1_X1, NORMAL/REV
      -- T1_X2, FUNCTION-BASED NORMAL/REV
      ```
* 인덱스와 제약 조건
  * 정의
    * PK 제약 조건과 UNIQUE 제약 조건은 내부적으로 인덱스를 사용한다
    * 인덱스를 사용하지 않으면 제약 조건을 검증할 때마다 전체 테이블을 읽어야 하기 때문
  * 자동 생성
    * PK 제약 조건과 UNIQUE 제약 조건은 생성 시 사용할 수 있는 인덱스가 없으면 자동으로 인덱스가 생성된다
      ```sql
      DROP TABLE t1 PURGE;
      
      CREATE TABLE t1 (
          c1 NUMBER PRIMARY KEY
        , c2 NUMBER CONSTRAINT t1_u1 UNIQUE
        , c3 NUMBER UNIQUE DEFERRABLE
        , c4 NUMBER CONSTRAINT t1_u2 UNIQUE DEFERRABLE
      );
      ```
      ```sql
      SELECT index_name, uniqueness
        FROM user_indexes
       WHERE table_name = 'T1';
      -- SYS_C0000001, UNIQUE
      -- T1_U1, UNIQUE
      -- SYS_C0000002, NONUNIQUE
      -- T1_U2, NONUNIQUE
      ```
      ```sql
      ALTER TABLE t1 MODIFY CONSTRAINT SYS_C0000001 DISABLE;
      ALTER TABLE t1 MODIFY CONSTRAINT t1_u1        DISABLE KEEP INDEX;
      ALTER TABLE t1 MODIFY CONSTRAINT SYS_C0000002 DISABLE;
      ALTER TABLE t1 MODIFY CONSTRAINT t1_u2        DISABLE DROP INDEX;

      SELECT index_name, uniqueness
        FROM user_indexes
       WHERE table_name = 'T1';
      -- T1_U1, UNIQUE
      -- T1_U2, NOUNIQUE
      ```
  * 수동 생성
    * PK 제약 조건과 UNIQUE 제약 조건은 생성 시 사용할 수 있는 인덱스가 있으면 해당 인덱스를 사용
      ```sql
        DROP TABLE t1 PURGE;
      CREATE TABLE t1 (c1 NUMBER NOT NULL, c2 NUMBER NOT NULL, c3 NUMBER, c4 NUMBER);
      CREATE UNIQUE INDEX t1_pk ON t1 (c1, c2);
      CREATE INDEX t1_x1 ON t1 (c3, c4);
      ```
      ```sql
      ALTER TABLE t1 ADD CONSTRAINT t1_pk PRIMARY KEY (c1, c2) USING INDEX t1_pk;
      ALTER TABLE t1 ADD CONSTRAINT t1_u1 UNIQUE (c3, c4) USING INDEX t1_u1;
      -- ORA-01418: 지정한 인댁스는 존재하지 않습니다

      SELECT index_name
        FROM user_constraints
       WHERE constraint_name='T1_PK';
      -- T1_PK

      ALTER TABLE t1 MODIFY CONSTRAINT t1_pk DISABLE;
      -- 수동으로 생성된 인덱스는 제약 조건이 비활성화되어도 삭제되지 않는다
      -- 인텍스를 생성한 후 제약 조건을 생성하는 편이 관리 측면에서 바람직

      SELECT index_name
        FROM user_indexes
       WHERE table_name='T1_PK';
      -- T1_PK

      ALTER TABLE t1 ADD CONSTRAINT t1_u1 UNIQUE (c4, c3);
      -- UNIQUE 제약 조건이 NONUNIQUE 인덱스 사용 가능
      -- 열 순서가 다르더라도 제약 조건을 검증할 수 있는 인덱스라면 사용 가능

      SELECT index_name
        FROM user_constraints
       WHERE constraint_name='T1_U1';
      -- T1_X1
      ```
      ```sql
      DROP TABLE t1 PURGE;
      CREATE TABLE t1 (c1 NUMBER NOT NULL, c2 NUMBER, c3 NUMBER);
      CREATE INDEX t1_x1 ON t1 (c1, c2);
      CREATE UNIQUE INDEX t1_pk ON t1 (c1);

      -- 제약 조건을 검증할 수 있는 인덱스가 다수라면 먼저 생성된 인덱스 사용
      ALTER TABLE t1 ADD CONSTRAINT t1_pk PRIMARY KEY (c1);

      SELECT index_name
        FROM user_indexes
       WHERE table_name='T1_PK';
      -- T1_X1
      ```
      ```sql
      DROP TABLE t1 PURGE;
      CREATE TABLE t1 (c1 NUMBER NOT NULL, c2 NUMBER);
      CREATE UNIQUE INDEX t1_pk ON t1 (c1);
      ALTER TABLE t1 ADD CONSTRAINT t1_pk PRIMARY KEY (c1);
      ALTER TABLE t1 ADD CONSTRAINT t1_u1 UNIQUE (c2);

      SELECT name, spare1
        FROM sys.obj$
       WHERE name LIKE 'T1_%';
      -- T1_PK, 6  -- 수동 생성
      -- T1_U1, 0 -- 자동 생성
      ```
  * 테이블명 변경
    * 지속적인 서비스를 위해서 기존 테이블명을 변경하고 신규 테이블명을 기존 테이블명으로 변경하는 전략을 택하는 경우가 있다
      ```sql
      DROP TABLE t1 PURGE;
      DROP TABLE t2 PURGE;
      DROP TABLE t3 PURGE;

      CREATE TABLE t1 (c1 NUMBER);
      CREATE TABLE t2 (c1 NUMBER);
      
      CREATE UNIQUE INDEX t1_PK ON t1(c1);
      CREATE UNIQUE INDEX t2_PK ON t2(c1);

      ALTER TABLE t1 ADD CONSTRAINT t1_pk PRIMARY KEY (c1) USING INDEX t1_pk;
      ALTER TABLE t2 ADD CONSTRAINT t2_pk PRIMARY KEY (c1) USING INDEX t2_pk;

      ALTER TABLE t1 RENAME CONSTRAINT t1_pk TO t3_pk;
      ALTER TABLE t1 RENAME TO t3;
      ALTER INDEX t1_pk RENAME TO t3_pk;

      ALTER TABLE t2 RENAME CONSTRAINT t2_pk TO t1_pk;
      ALTER TABLE t2 RENAME TO t1;
      ALTER INDEX t2_pk RENAME TO t1_pk;
      ```

<br>

### 파티션
* 파티션(Partition)은 서브 오브젝트(Subobject)
  * 다수의 물리적 파티션이 하나의 논리적 오브젝트로 관리된다
* 파티션 테이블 (Partitioned Table)
  * 파티션 목적
    * OLTP 시스템의 DML 경합 해소
    * DW 시스템의 조회 성능 개선
    * 효율적인 ILM(Information Lifecycle Management)
  * 파티션 유형
    * RANGE
    * HASH
    * SYSTEM
    * INTERVAL
    * REFERENCE
    * INTERVAL-REFERENCE
* RANGE 파티션
  * 파티션 키 값의 범위로 파티션을 분할한다
    ```sql
    PARTITION BY RANGE (column [, column]...) (
      PARTITION [partition] VALUES LESS THAN ({literal|MAXVALUE} [,{...}...])
    [, PARTITION [partition] VALUES LESS THAN ({literal|MAXVALUE} [,{...}...])
    ```
  * 예시) 사용할 수 있는 파티션이 정의되어 있지 않을 때
    ```sql
    DROP TABLE t1 PURGE;
    CREATE TABLE t1 (c1 NUMBER, c2 DATE) 
    PARTITION BY RANGE (c2) {
      PARTITION p1 VALUES LESS THAN '2050-02-01'
    , PARTITION p2 VALUES LESS THAN '2050-03-01'));
  
    INSERT INTO t1 VALUES (1, DATE '2050-01-01');
    INSERT INTO t1 VALUES (2, DATE '2050-02-01');
    INSERT INTO t1 VALUES (3, DATE '2050-03-01');
    -- ORA-14400: 삽입된 분할 영역 키와 매핑되는 분할 영역이 없음
    ```
  * 예시) 사용할 수 있는 파티션이 정의되어 있을 때 (MAXVALUE 사용)
    ```sql
    DROP TABLE t1 PURGE;
    CREATE TABLE t1 (c1 NUMBER, c2 DATE) 
    PARTITION BY RANGE (c2) (
      PARTITION p1 VALUES LESS THAN (DATE '2050-02-01')
    , PARTITION p2 VALUES LESS THAN (DATE '2050-03-01')
    , PARTITION p3 VALUES LESS THAN (MAXVALUE));
  
    INSERT INTO t1 VALUES (1, DATE '2050-01-01');
    INSERT INTO t1 VALUES (2, DATE '2050-02-01');
    INSERT INTO t1 VALUES (3, DATE '2050-03-01');
    -- 정상처리
    COMMIT;
    ```
  * 예시) 생성된 파티션에 대한 데이터 딕셔너리
    ```sql
    SELECT partitioning_type, partition_count, partitioning_key_count
    FROM user_part_tables
    WHERE table_name = 'T1';
    -- RANGE, 3, 1
    ```
    ```sql
    SELECT partition_name, high_value
    FROM user_tab_partitions
    WHERE table_name = 'T1'
    ORDER BY partition_column;
    -- P1, TO_DATE('2050-01-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', ... );
    -- P2, TO_DATE('2050-02-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', ... );
    -- P3, MAXVALUE
    ```
    ```sql
    SELECT object_type, column_name, column_position
    FROM user_part_key_columns
    WHERE name = 'T1';
    -- TABLE, C2, 1
    ```
    ```sql
    SELECT object_name, subobject_name, object_type
    FROM   user_objects
    WHERE  object_name = 'T1';
    -- T1,  ,TABLE
    -- T1,P1,TABLE PARTTION
    -- T1,P2,TABLE PARTTION
    -- T1,P3,TABLE PARTTION
    ```
    ```sql
    -- T1 테이블은 비 세그먼트 오브젝트로 논리적으로만 존재한다
    -- 데이터는 물리적인 태이블 파티션에 저장된다
    SELECT segment_name, partition_name, segment_type, tablespace_name
    FROM   user_segments
    WHERE  segment_name = 'T1';
    -- T1,P1,TABLE PARTITION, USERS
    -- T1,P2,TABLE PARTITION, USERS
    -- T1,P3,TABLE PARTITION, USERS
    ```
  * 예시) 파티션 확장절 (Partition Extension Clause)
    ```sql
    { PARTITION (partition)
    | PARTITION FOR (partition_key_value [, partition_key_value]...)
    | SUBPARTITION (subpartition)
    | SUBPARTITION FOR (subpartition_key_value [, subpartition_key_value]...)}
    ```
    ```sql
    SELECT * FROM t1 PARTITION (p1);
    -- 1, 2050-01-01
  
    SELECT * FROM t1 PARTITION FOR (DATE '2050-02-01');
    -- 2, 2050-02-01
    ```
  * 예시) 다중 열
    * BAD 예시) (c1, c2) 중 후열인 c2에 대한 MAXVALUE 세팅도 필요
      ```sql
      DROP TABLE t1 PURGE;
      CREATE TABLE t1 (c1 NUMBER, c2 NUMBER)
      PARTITION BY RANGE (c1, c2) (
          PARTITION p1 VALUES LESS THAN (1, 1)
        , PARTITION p2 VALUES LESS THAN (1, 2)
        , PARTITION p3 VALUES LESS THAN (2, 1)
        , PARTITION p4 VALUES LESS THAN (2, 2)
        , PARTITION p5 VALUES LESS THAN (MAXVALUE, MAXVALUE)
      );
    
      INSERT INTO t1 VALUES (0, 0);
      INSERT INTO t1 VALUES (0, 1);
      INSERT INTO t1 VALUES (0, 2);
      INSERT INTO t1 VALUES (1, 0);
      -- P1 
      INSERT INTO t1 VALUES (1, 1);
      -- P2
      INSERT INTO t1 VALUES (1, 2);
      INSERT INTO t1 VALUES (2, 0);
      -- P3
      INSERT INTO t1 VALUES (2, 1);
      -- P4
      INSERT INTO t1 VALUES (2, 2);
      INSERT INTO t1 VALUES (3, 0);
      INSERT INTO t1 VALUES (3, 1);
      INSERT INTO t1 VALUES (3, 2);
      -- P5
      COMMIT;
      ```
    * BETTER 예시) MAXVALUE를 활용하면, 첫번째 열은 동일하되, 두번째 열은 다른 값들만 추출하여 저장 가능 
      ```sql
      DROP TABLE t1 PURGE;
      CREATE TABLE t1 (c1 NUMBER, c2 NUMBER)
      PARTITION BY RANGE (c1, c2) (
          PARTITION p1 VALUES LESS THAN (1, 1)
        , PARTITION p2 VALUES LESS THAN (1, MAXVALUE)
        , PARTITION p3 VALUES LESS THAN (2, 1)
        , PARTITION p4 VALUES LESS THAN (2, MAXVALUE)
        , PARTITION p5 VALUES LESS THAN (MAXVALUE, MAXVALUE)
      );
    
      INSERT INTO t1 VALUES (0, 0);
      INSERT INTO t1 VALUES (0, 1);
      INSERT INTO t1 VALUES (0, 2);
      INSERT INTO t1 VALUES (1, 0);
      -- P1
      INSERT INTO t1 VALUES (1, 1);
      INSERT INTO t1 VALUES (1, 2);
      -- P2
      INSERT INTO t1 VALUES (2, 0);
      -- P3
      INSERT INTO t1 VALUES (2, 1);
      INSERT INTO t1 VALUES (2, 2);
      -- P4
      INSERT INTO t1 VALUES (3, 0);
      INSERT INTO t1 VALUES (3, 1);
      INSERT INTO t1 VALUES (3, 2);
      -- P5
      COMMIT;
      ```
* HASH 파티션
  * 파티션 키 값에 대한 해시 함수의 결과 값으로 파티션을 분할한다
    * OLTP 시스템의 블록 경합을 해소하기 위해 사용 가능
    ```sql
    PARTITION BY HASH (column [, column]...) PARTITIONS hash_partition_quantity
    ```
  * 예시) 파티션명을 명시해주지 않으면, 무작위로 생성된다
    ```sql
    DROP TABLE t1 PURGE;
    CREATE TABLE t1 (
        c1 NUMBER
      , c2 NUMBER
    ) PARTITION BY HASH (c1) PARTITIONS 3;
    
    SELECT partition_name, high_value
      FROM user_tab_partitions
     WHERE table_name = 'T1';
    -- SYS_P####
    -- SYS_P####
    -- SYS_P####
    ```
  * 예시) 파티션명을 명시해주면, 명시된 파티션명이 생성된다
    ```sql
    PARTITION BY HASH (column [, column]...) (
        PARTITION [partition]
     [, PARTITION [partition]]...)
    ```
    ```sql
    DROP TABLE t1 PURGE;
    CREATE TABLE t1 (
        c1 NUMBER
      , c2 NUMBER
    ) PARTITION BY HASH (c1) (PARTITION p1, PARTITION p2, PARTITION p3);
    ```
* LIST 파티션
  * 파티션 키 값의 목록으로 파티션을 분할한다
    * 키 값이 고정적이며 데이터 분포가 균등하지 않은 데이터를 분할할때 사용
    ```sql
    PARTITION BY LIST (column) (
        PARTITION [partition] VALUES ({literal | NULL} [, {literal | NULL}]... | DEFAULT)
     [, PARTITION [partition] VALUES ({literal | NULL} [, {literal | NULL}]... | DEFAULT)]...)
    ```
  * 예시) 단일 행
    ```sql
    DROP TABLE t1 PURGE;
    CREATE TABLE t1 (c1 NUMBER, c2 NUMBER)
    PARTITION BY LIST (c2) (
        PARTITION p1 VALUES (1, 2)
      , PARTITION p2 VALUES (3, 4)
      , PARTITION p3 VALUES (DEFAULT));
    ```
  * 예시) 다중 행
    ```sql
    DROP TABLE t1 PURGE;
    CREATE TABLE t1 (c1 NUMBER, c2 NUMBER)
    PARTITION BY LIST (c1, c2) (
        PARTITION p1 VALUES ((1, 1), (1, 2))
      , PARTITION p2 VALUES ((2, 1), (2, 2))
      , PARTITION p3 VALUES (DEFAULT));
    ```
  * 예시) 자동 LIST 파티션 태이블 생성
    ```sql
    DROP TABLE t1 PURGE;
    CREATE TABLE t1 (c1 NUMBER, c2 NUMBER)
    PARTITION BY LIST (c2) AUTOMATIC (
        PARTITION p1 VALUES (1)
      , PARTITION p2 VALUES (2));
    ```
    ```sql
    SELECT partition_name, high_value
      FROM user_tab_partitions
     WHERE table_name = 'T1';
    -- P1, 1
    -- P2, 2
    -- SYS_PXXXX, 3
    ```
* SYSTEM 파티션
  * 파티션 키가 없는 파티션이다
    * 애플리케이션에서 임의로 데이터를 분할할 때 사용 가능
    ```sql
    PARTITION BY SYSTEM (PARTITION [partition[ [, PARTITION[partition]...)]
    ```
  * 예시) 명시적으로 파티션 생성 후 명시적으로 특정 파티션에 INSERT 필요
    ```sql
    DROP TABLE t1 PURGE;
    
    CREATE TABLE t1 (c1 NUMBER)
    PARTITION BY SYSTEM (PARTITION p1, PARTITION p2, PARTITION p3);
    ```
    ```sql
    -- 에러처리
    INSERT INTO t1 VALUES (1);
    -- ORA-14701: 시스템 방식에 의해 분할된 테이블의 DML에는 분할 영역으로 확장된 이름 또는 바인드 변수를 사용해야 합니다
    ```
    ```sql
    -- 정상처리
    INSERT INTO t1 PARTITION (p1) VALUES (1);
    ```
  * 예시) 테이블 조회 및 파티션 조회 모두 가능
    ```sql
    -- 세션1
    SELECT * FROM t1;
    -- 1
    -- 세션2
    SELECT * FROM t1 PARTITION(p1);
    -- 1
    ```
  * 예시) 명시적으로 파티션을 생성하는 것이 아니라, 개수를 지정해서 자동으로 파티션 생성 가능
    ```sql
    PARTITION BY SYSTEM PARTITIONS integer;
    ```
    ```sql
    DROP TABLE t1 PURGE;
    CREATE TABLE t1 (c1 NUMBER) PARTITION BY SYSTEM PARTITIONS 3;
    ```
* INTERVAL 파티션
  * 기간에 해당하는 데이터가 입력되면 파티션이 자동으로 추가된다
    * RANGE 파티션의 확장 기능
    ```sql
    PARTITON BY RANGE (column [, column]...) [INTERVAL (expr)] (
        PARTITION [partition] VALUES LESS THAN ({literal | MAXVALUE} [, {...}...])
     [, PARTITION [partition] VALUES LESS THAN ({literal | MAXVALUE} [, {...}...])...)
    ```
   * 예시) 1달 주기 INTERVAL
     ```sql
     DROP TABLE t1 PURGE;
     
     CREATE TABLE t1 (c1 NUMBER, c2 DATE)
     PARTITION BY RANGE (c2) INTERVAL (NUMTOYMINTERVAL (1, 'MONTH')) (
         PARTITION p1 VALUES LESS THAN (DATE '2050-02-01')
     );
     ```
     ```sql
     SELECT partition_name, high_value
     FROM   user_tab_partitions
     WHERE  table name = 'T1'
     ORDER BY partition_position;
     -- P1, TO_DATE('2050-02-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', ... )
     ```
     ```sql
     INSERT INTO t1 VALUES (1, DATE '2050-01-01');
     INSERT INTO t1 VALUES (3, DATE '2050-03-01');
     INSERT INTO t1 VALUES (2, DATE '2050-02-01');
     COMMIT;
     ```
     ```sql
     SELECT partition_name, high_value
     FROM   user_tab_partitions
     WHERE  table name = 'T1'
     ORDER BY partition_position;
     -- P1, TO_DATE('2050-02-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', ... )
     -- SYS_PXXXX, TO_DATE('2050-03-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', ... )
     -- SYS_PXXXX, TO_DATE('2050-04-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', ... )
     ```
* REFERENCE 파티션
  * FK 제약 조건을 통해 부모 테이블과 동일한 구조의 파티션을 생성한다
    * 부모 테이블의 파티션이 변경되면 REFERENCE 파티션 태이블도 함께 변경
    ```sql
    PARTITION BY REFERENCE (constraint) [(reference_partition_desc...)]
    ```
  * 예시) t1의 Partition Key가 t2에는 없는 칼럼이고, t2의 c1 칼럼이 Foreign Key로 t1의 c1 칼럼을 REFERENCE한다
    ```sql
    DROP TABLE t2 CASCADE CONSTRAINTS PURGE;
    DROP TABLE t1 CASCADE CONSTRAINTS PURGE;
    
    CREATE TABLE t1 (
        c1 NUMBER NOT NULL
      , c2 DATE
      , CONSTRAINT t1_pk PRIMARY KEY (c1))
    PARTITION BY RANGE (c2) (
        PARTITION p1 VALUES LESS THAN (DATE '2050-02-01' )
      , PARTITION p2 VALUES LESS THAN (DATE '2050-03-01' )
      , PARTITION p3 VALUES LESS THAN (MAXVALUE));
    
    CREATE TABLE t2 (
        c1 NUMBER NOT NULL
      , c2 NUMBER NOT NULL
      , c3 NUMBER
      , CONSTRAINT t2_pk PRIMARY KEY (c1, c2)
      , CONSTRAINT t2_f1 FOREIGN KEY (c1) REFERENCES t1 (c1))
    PARTITION BY REFERENCE (t2_f1);
    ```
    ```sql
    SELECT partition_name, high_value
      FROM user_tab_partitions
     WHERE table name = 'T2'
    ORDER BY partition_position;
     -- P1
     -- P2
     -- P3
     ```
     ```sql
     INSERT INTO t1 VALUES (1, DATE '2050-01-01');
     INSERT INTO t1 VALUES (2, DATE '2050-02-01');
     INSERT INTO t1 VALUES (3, DATE '2050-02-02');
     INSERT INTO t2 VALUES (1, 1, 1);
     INSERT INTO t2 VALUES (2, 2, 2);
     INSERT INTO t2 VALUES (3, 3, 3);
     COMMIT;
     ```
     ```sql
     SELECT * 
     FROM t1 PARTITION(p2);
     -- 2, 2050-02-01
     -- 3, 2050-02-02

     SELECT * 
     FROM t2 PARTITION(p2);
     -- 2, 2, 2
     -- 3, 3, 3

     SELECT * FROM t2 PARTITION FOR (DATE '2050-02-01');
     -- ORA-14093: 식의 데이터 유형은 열을 분할영역한 것과 상반됩니다
     ```
* INTERVAL-REFERENCE 파티션
  * INTERVAL 파티션도 REFERENCE 파티션 사용 가능
    ```sql
    DROP TABLE t2 CASCADE CONSTRAINTS PURGE;
    DROP TABLE t1 CASCADE CONSTRAINTS PURGE;

    CREATE TABLE t1 (c1 NUMBER NOT NULL, c2 DATE, CONSTRAINT t1_pk PRIMARY KEY (c1))
    PARTITION BY RANGE (c2) INTERVAL (NUMTOYMINTERVAL (1, 'MONTH')) (
        PARTITION p1 VALUES LESS THAN (DATE '2050-02-01'));

    CREATE TABLE t2 (c1 NUMBER NOT NULL, c2 NUMBER NOT NULL, c3 NUMBER
                      , CONSTRAINT t2_pk PRIMARY KEY (c1, c2)
                      , CONSTRAINT t2_f1 FOREIGN KEY (c1) REFERENCES t1 (c1))
    PARTITION BY REFERENCE (t2_f1);
    ```
* COMPOSITE 파티션
  * 파티션의 조합
    * RANGE
      * HASH
      * LIST
      * RANGE
    * LIST
      * HASH
      * LIST
      * RANGE
    * INTERVAL
      * HASH
      * LIST
      * RANGE
    * HASH
      * HASH
      * LIST
      * RANGE
  * RANGE-HASH
    ```sql
    DROP TABLE t2 CASCADE CONSTRAINTS PURGE;
    DROP TABLE t1 CASCADE CONSTRAINTS PURGE;

    CREATE TABLE t1 (c1 NUMBER, c2 DATE, c3 NUMBER)
    PARTITION BY RANGE (c2) SUBPARTITION BY HASH (c3) SUBPARTITIONS 2 (
          PARTITION p1 VALUES LESS THAN (DATE '2050-02-01')
        , PARTITION p2 VALUES LESS THAN (DATE '2050-03-01')
        , PARTITION p3 VALUES LESS THAN (MAXVALUE));
    ```
    ```sql
    SELECT partitioning_type, subpartitioning_type, partition_count
         , def_subpartition_count
    FROM   user_part_tables
    WHERE  table_name = 'T1';
    -- RANGE, HASH, 3, 2
    ```
    ```sql
    SELECT   composite, partition_name, subpartition_count, partition_position
    FROM     user_tab_partitions
    WHERE    table name = 'T1'
    ORDER BY partition_position;
    -- YES, P1, 2, 1
    -- YES, P2, 2, 2
    -- YES, P3, 2, 3
    ```
    ```sql
    SELECT   partition_name, subpartition_name, partition_position, subpartition_position
    FROM     user_tab_subpartitions
    WHERE    table_name = 'T1'
    ORDER BY partition_position, subpartition_position;
    ```
    ```sql
    SELECT column_name, column_position FROM dba_subpart_key_columns WHERE name = 'T1' ;
    ```
  * RANGE-LIST
    ```sql
    DROP TABLE t1 PURGE;
    CREATE TABLE t1 (c1 NUMBER , c2 DATE , c3 NUMBER)
    PARTITION BY RANGE (c2) SUBPARTITION BY LIST (c3) (
        PARTITION p1 VALUES LESS THAN (DATE '2050-02-01') (
            SUBPARTITION p1_s1 VALUES (1, 2)
            , SUBPARTITION p1_s2 VALUES (DEFAULT))
      , PARTITION p2 VALUES LESS THAN (DATE '2050-03-01') (
            SUBPARTITION p2_s1 VALUES (1, 2)
            , SUBPARTITION p2_s2 VALUES (DEFAULT))
      , PARTITION p3 VALUES LESS THAN (MAXVALUE) (
            SUBPARTITION p3_s1 VALUES (1, 2)
            , SUBPARTITION p3_s3 VALUES (DEFAULT))
    );
    ```
    ```sql
    SELECT partition_name, subpartition_name
    FROM   user_tab_subpartitions
    WHERE  table_name = 'T1';
    -- P1, P1_S1
    ```
    ```sql
    SELECT * FROM t1 SUBPARTITION (p1_51);
    -- 1,2050-01-01,1
    ```
    ```sql
    SELECT * FROM t1 SUBPARTITION FOR (DATE '2050-01-10', 2);
    ```
* 파티션 IOT (Partitioned Index-organized Table)
  ```sql
  DROP TABLE t1 PURGE;
  CREATE TABLE t1 (c1 NUMBER, c2 DATE, c3 NUMBER, CONSTRAINT t1_pk PRIMARY KEY (c1, c2))
  ORGANIZATION INDEX
  PARTITION BY RANGE (c2) (
        PARTITION p1 VALUES LESS THAN (DATE '2050-02-01')
      , PARTITION p2 VALUES LESS THAN (DATE '2050-03-01')
      , PARTITION p3 VALUES LESS THAN (MAXVALUE));
  ```
* 파티션 해시 클러스터 테이블 (Partitioned Hash Clustered Table)
  ```sql
  DROP CLUSTER c1# INCLUDING TABLES;
  DROP TABLE t1 PURGE;
  
  CREATE CLUSTER c1# (c1 NUMBER, c2 NUMBER) HASHKEYS 100 HASH IS c1
  PARTITION BY RANGE (c2) (
        PART1T10N p1 VALUES LESS THAN (100)
      , PART1T10N p2 VALUES LESS THAN (200)
      , PARTITION p3 VALUES LESS THAN (MAXVALUE));

  CREATE TABLE t1 (c1 NUMBER , c2 NUMBER , c3 NUMBER) CLUSTER c1# (c1, c2);
  ```
  ```sql
  SELECT partition_name, high_value FROM user_tab_partitions WHERE table_name = 'T1';
  -- SYS_P####, 100
  -- SYS_P####, 200
  -- SYS_P####, MAXVALUE
  ```
* 파티션 인덱스
  * 다수의 물리적 인덱스 파티션을 하나의 논리적 인덱스로 사용할 수 있는 오브젝트
  * 유형
    * 비 파티션 인덱스
      * 파티셔닝 X
    * 로컬 파티션 인덱스
       * 파티셔닝 O && 파티션 테이블과 동일한 구조 O
    * 글로벌 파티션 인덱스
       * 파티셔닝 O && 파티션 테이블과 동일한 구조 X
  * 테이블 유형별 사용 가능 인덱스
    * 파티션 테이블
      * 비파티션 인덱스
      * 로컬 파티션 인덱스
      * 글로벌 파티션 인덱스
    * 비파티션 테이블
      * 비파티션 인덱스
      * 글로벌 파티션 인덱스
* Prefixed: 테이블 파티션 키 == 파티션 인덱스의 선두 칼럼
  * 로컬 파티션 인덱스
    * Prefixed
    * Nonprefixed
  * 글로벌 파티션 인덱스
    * Prefixed
* Unique 로컬 파티션 인덱스
  * 예시 환경 세팅
    ```sql
    DROP TABLE t1 PURGE;
    
    CREATE TABLE t1 (c1 NUMBER, c2 NUMBER, c3 NUMBER)
        PARTITION BY RANGE (c1) SUBPARTITION BY HASH (c2) SUBPARTITIONS 2 (
            PARTITION p1 VALUES LESS THAN (1)
            , PARTITION p2 VALUES LESS THAN (2)
            , PARTITION p3 VALUES LESS THAN (3)
            , PARTITION p4 VALUES LESS THAN (MAXVALUE)
    );
    INSERT INTO t1 VALUES (1, 1, 1);
    INSERT INTO t1 VALUES (2, 2, 2);
    INSERT INTO t1 VALUES (3, 3, 3);
    INSERT INTO t1 VALUES (4, 4, 4);
    COMMIT;
    ```
  * 인덱스 열에 파티션 키가 포함되어야 한다
    ```sql
    CREATE UNIQUE INDEX t1_u1 ON t1 (c1);
    CREATE UNIQUE INDEX t1_u2 ON t1 (c1, c2) LOCAL;
    CREATE UNIQUE INDEX t1_u3 ON t1 (c2)     LOCAL;
    -- ORA-14039: 열을 분할영역한 것은 UNIQUE 인텍스로 키 열의 부분 집합을 폼 합니다
    ```
* Nonunique 인덱스 파티션 인덱스
  * 글로벌 파티션 인덱스는 Prefixed 인덱스만 생성 가능
    ```sql
    CREATE INDEX t1_x1 ON t1 (c2, c3) LOCAL;
    CREATE INDEX t1_x2 ON t1 (c3)     LOCAL;
    CREATE INDEX t1_x3 ON t1 (c3, c2) GLOBAL PARTITION BY HASH (c3) PARTITIONS 2;
    CREATE INDEX t1_x4 ON t1 (c1, c3) GLOBAL PARTITION BY HASH (c3) PARTITIONS 2;
    -- ORA-14038: GLOBAL 로 분할영역된 인텍스는 접두사이어야 합니다
    ```
* 데이터 딕셔너리
  * 인덱스의 파티션 여부
    ```sql
    SELECT   index_name, uniqueness, partitioned, status
    FROM     user_indexes
    WHERE    table_name = 'T1'
    ORDER BY index_name;
    ```
  * 파티션 인덱스 정보
    ```sql
    SELECT   index_name, partitioning_type, subpartitioning_type, locality, alignment
    FROM     user_part_indexes
    WHERE    table name = 'T1'
    ORDER BY index_name;
    
    -- T1_U2, RANGE, HASH, LOCAL,  PREFIXED
    -- T1_X1, RANGE, HASH, LOCAL,  NON PREFIXED
    -- T1_X2, RANGE, HASH, LOCAL,  NON PREFIXED
    -- T1_X3, HASH,  NONE, GLOBAL, PREFIXED
    ```
  * 인덱스 파티션 정보
    ```sql
    SELECT index_name, composite, partition_name, partition_position, status
    FROM   user_ind_partitions
    WHERE  index_name IN ( 'T1_U2', 'T1_X3' )
    ORDER BY index_name, partition_position;

    -- T1_U2, YES, P1       , 1, N/A
    -- T1_U2, YES, P2       , 2, N/A
    -- T1_U2, YES, P3       , 3, N/A
    -- T1_U2, YES, P4       , 4, N/A
    -- T1_X3, NO,  SYS_P####, 1, USABLE
    -- T1_X3, NO,  SYS_P####, 2, USABLE
    ```
  * 인덱스 서브파티션 정보
    ```sql
    SELECT   partition_name, subpartition_name, partition_position, subpartition_position, status
    FROM     user_ind_subpartitions
    WHERE    index name = 'T1_U2'
    ORDER BY partition_position, subpartition_position;
    -- P1, SYS_SUBP####, 1, 1, USABLE
    -- P1, SYS_SUBP####, 1, 2, USABLE
    -- P2, SYS_SUBP####, 2, 1, USABLE
    ```

<br>

### 관리구문
* 환경 세팅
  ```sql
  DROP TABLE t1 PURGE;
  
  CREATE TABLE t1 (c1 NUMBER , c2 NUMBER)
      PARTITION BY RANGE (c2) (
          PARTITION p1 VALUES LESS THAN (2)
        , PARTITION p2 VALUES LESS THAN (3)
  );
  
  CREATE INDEX t1_x1 ON t1 (c1);
  CREATE INDEX t1_x2 ON t1 (c2) LOCAL;
  
  INSERT INTO t1 VALUES (1, 1);
  INSERT INTO t1 VALUES (2, 2);
  
  COMMIT ;
  ```
* ADD절
  ```sql
  ALTER [schema.]table ADD PARTITION [partition] partition_clause
                        [, PARTITION [partition] partition_clause]...;
  ```
  ```sql
  ALTER TABLE t1 ADD PARTITION p4 VALUES LESS THAN (MAXVALUE);
  INSERT INTO t1 VALUES (3, 1);
  COMMIT;
  ```
  ```sql
  SELECT partition_name, high_value
  FROM   user_tab_partitions
  WHERE  table_name = 'T1';
  -- P1, 2
  -- P2, 3
  -- P4, MAXVALUE
  ```
  ```sql
  -- 마지막 파티션보다 키 값이 큰 파티션만 추가 가능
  ALTER TABLE t1 ADD PARTITION p3 VALUES LESS THAN (4);
  -- ORA-14074: 분할영역 유지 작업에 분할영역 범위가 너무 적습니다
  ```
* DROP절
  ```sql
  ALTER [schema.]table DROP {PARTITION | PARTITIONS} {partition [, partition]}
  [update_index_clauses];
  ```
  ```sql
  -- [update_index_clauses]절 
  {UPDATE | INVALIDATE} GLOBAL INDEXES | UPDATE INDEXES [(index [, index]...)
  ```
  * INVALIDATE GLOBAL INDEXES: 글로벌 인덱스를 갱신하지 않고 UNUSABLE로 변경 (기본값)
  * UPDATE GLOBAL INDEXES: 글로벌 인덱스를 갱신
  * UPDATE INDEXES: 모든 글로벌 인덱스와 로컬 인덱스를 갱신
  * UPDATE INDEXES (...): 지정된 인덱스를 갱신
  ```sql
  ALTER TABLE t1 DROP PARTITION p4;

  ALTER TABLE t1 DROP PARTITION FOR(5);
  ```
  ```sql
  SELECT partition_name, high_value
  FROM   user_tab_partitions
  WHERE  table_name = 'T1';
  -- P1 2
  -- P2 3
  ```
  ```sql
  ALTER TABLE t1 ADD PARTITION p3 VALUES LESS THAN (5);
  
  INSERT INTO t1 VALUES (3, 3);
  INSERT INTO t1 VALUES (4, 4);
  
  COMMIT;
  ```
* MERGE절
  ```sql
  ALTER [schema.]table MERGE PARTITIONS
        partition {, partition [, partition]... | TO partition}
        [INTO partition]
        [INCLUDING ROWS where_clause]
        [update_index_clauses]
  ```
  ```sql
  ALTER TABLE t1 MERGE PARTITIONS p2, p3 INTO PARTITION p3;
  
  ALTER TABLE t1 MERGE PARTITIONS p2 TO p3 INTO PARTITION p3;
  ```
  ```sql
  SELECT partition_name, high_value
  FROM   user_tab_partitions
  WHERE  table_name = 'T1';
  -- P1 2
  -- P3 5
  ```
* SPLIT절
  ```sql
  ALTER [schema.]table SPLIT partition
        {AT (literal [, literal]...) | VALUES (list_values)} [INTO (partition, partition)]
        [INCLUDING ROWS where_clause]
        [update_index_clauses]
        [ONLINE];
  ```
  ```sql
  ALTER TABLE t1 SPLIT PARTITION p3 AT (3) INTO (PARTITION p2, PARTITION p3);
  ```
  ```sql
  SELECT partition_name, high_value
  FROM   user_tab_partitions
  WHERE  table_name = 'T1';
  -- P1, 2
  -- P2, 3
  -- P3, 5
  ```
  ```sql
  SPLIT partition INTO (partition [, partition]..., partition)
  ```
  ```sql
  ALTER TABLE t1 SPLIT PARTITION p3 INTO (
      PARTITION p3 VALUES LESS THAN (4)
    , PARTITION p4
  );
  ```
  ```sql
  SELECT partition_name, high_value
  FROM   user_tab_partitions
  WHERE  table_name = 'T1';
  -- P1, 2
  -- P2, 3
  -- P3, 4
  -- P4, 5
  ```
* EXCHANGE절
  ```sql
  ALTER [schema.]table EXCHANGE {partition | subpartition} WITH TABLE [schema.] table
        [{INCLUDING | EXCLUDING} INDEXES]
        [{WITH | WITHOUT} VALIDATION]
        [EXCEPTIONS INTO [schema.]table]
        [update_index_clauses]
        [CASCADE];
  ```
    * {INCLUDING | EXCLUDING} INDEXES: 인덱스 포함 여부를 결정
    * {WITH | WITHOUT} VALIDATION: 검증 여부를 결정
    * EXCEPTIONS INTO [schema.]table: 예외 처리
    * CASCADE: REFERENCE 파티션에 대한 종속 작업을 수행
  ```sql
  DROP TABLE t2 PURGE;
  
  CREATE TABLE t2 AS
  SELECT * FROM t1 WHERE 0 = 1;
  
  CREATE INDEX t2_x1 ON t2 (c2);
  
  INSERT INTO t2 VALUES (5, 1);
  INSERT INTO t2 VALUES (6, 2);
  COMMIT;
  ```
  ```sql
  ALTER TABLE t1 EXCHANGE PARTITION p1 WITH TABLE t2 INCLUDING INDEXES WITHOUT VALIDATION;

  SELECT * FROM t1 PARTITION (p1);
  -- 5, 1
  -- 6, 2
  ```
* MOVE절
  ```sql
  ALTER [schema.]table MOVE PARTITION  partition
        [TABLESPACE tablespace]
        [INCLUDING ROWS where_clause]
        [update_index_clauses]
        [ONLINE];
  ```
  ```sql
  ALTER TABLE t1 MOVE PARTITION p1 INCLUDING ROWS WHERE c2 < 2;
  ```
  ```sql
  SELECT * FROM t1 PARTITION (p1);
  -- 5, 1
  ```
* RENAME절
  ```sql
  ALTER [schema.]table RENAME {PARTITION partition | SUBPARTITION subpartition} TO new_name;
  ```
  ```sql
  ALTER TABLE t1 RENAME PARTITION p4 TO p5;
  ```
  ```sql
  ALTER INDEX t1_x2 RENAME PARTITION p4 TO p5;
  ```
* TRUNCATE절
  ```sql
  ALTER [schema.]table TRUNCATE {PARTITION | PARTITIONS}  {partition [, partition]}
        [{DROP [ALL] | REUSE} STORAGE]
        [update_index_clauses]
        [CASCADE];
  ```
  ```sql
  ALTER TABLE t1 TRUNCATE PARTITION p5;
  ```
* MODIFY절
  ```sql
  ALTER [schema.]table MODIFY partition
        [{ADD | DROP} VALUES (list_values)
        | [REBUID] UNUSABLE LOCAL INDEXES
        | {READ ONLY | READ WRITE}
        | INDEXING {ON | OFF}};
  ```
    * {ADD | DROP} VALUES (list_values): 리스트 파티션에 값을 추가하거나 삭제함
    * [REBUID] UNUSABLE LOCAL INDEXES: 로컬 인덱스를 비활성화하거나 재구축함
    * {READ ONLY | READ WRITE}: 읽기 전용 또는 읽기 쓰기를 설정
    * INDEXING {ON | OFF}: 인덱싱 여부를 설정
  ```sql
  ALTER TABLE t1 MODIFY PARTITION p1 READ ONLY;
  ```
  ```sql
  INSERT INTO t1 VALUES (1, 3);
  -- ORA-14466: 읽기 전용 분할 영역이나 하위 분할 영역의 데이터는 수정할 수 없습니다.
  ```
* 관리 구문과 인덱스
  * 관리 구문을 수행하면 인텍스가 UNUSABLE 상태로 변경될 수 있다
    ```sql
    SELECT status
    FROM   user_indexes
    WHERE  index_name = 'T1_X1';
    -- UNUSABLE
    ```
    ```sql
    SELECT partition_name, status
    FROM   user_ind_partitions
    WHERE  index_name = 'T1 _X2';
    -- P1 UNUSABLE
    -- P2 UNUSABLE
    -- P3 UNUSABLE
    -- P5 USABLE
    ```
  * 관리 구문은 아래와 같이 인덱스의 상태를 변경한다
    |절|글로벌|로컬|비고|
    |------|---|---|---|
    |ADD||||
    |DROP|UNUSABLE|||
    |MERGE|UNUSABLE|UNUSABLE||
    |SPLIT|UNUSABLE|UNUSABLE|ONLINE 사용시 모두 갱신|
    |EXCHANGE|UNUSABLE|UNUSABLE|INCLUDING INDEXES 사용시 로컬 인덱스 갱신|
    |MOVE|UNUSABLE|UNUSABLE|ONLINE 사용시 모두 갱신|
    |RENAME||||
    |TRUNCATE|UNUSABLE|||
    |MODIFY||||
* 신규 기능
  * 비동기 글로벌 인덱스 관리
    ```sql
    DROP TABLE t1 PURGE;
    
    CREATE TABLE t1 (c1 NUMBER, c2 NUMBER)
        PARTITION BY RANGE (c2) (
              PARTITION p1 VALUES LESS THAN (2)
            , PARTITION p2 VALUES LESS THAN (MAXVALUE)
    );
    CREATE INDEX t1_x1 ON t1 (c1);
    INSERT INTO t1 VALUES (1, 1);
    INSERT INTO t1 VALUES (2, 2);
    COMMIT;
    ```
    ```sql
    ALTER TABLE t1 TRUNCATE PARTITION p1 UPDATE GLOBAL INDEXES;
    ```
    ```sql
    SELECT status, orphaned_entries
    FROM   user_indexes
    WHERE  index_name = 'T1_X1';
    -- VALID YES
    ```
    ```sql
    ALTER INDEX t1_x1 REBUILD;
    ALTER INDEX t1_x1 COALESCE CLEANUP;
    ```
  * 부분 인덱스
    * 일부 테이블 파티션에 생성할 수 있는 인덱스
      ```sql
      DROP TABLE t1 PURGE;

      CREATE TABLE t1 (c1 NUMBER, c2 NUMBER)
      PARTITION BY RANGE (c2) (
          PARTITION p1 VALUES LESS THAN (2) INDEXING ON
        , PARTITION p2 VALUES LESS THAN (MAXVALUE) INDEXING OFF
      );

      INSERT INTO t1 VALUES (1, 1);
      INSERT INTO t1 VALUES (2, 2);
      COMMIT;
      ```
      ```sql
      CREATE INDEX t1_x1 ON t1 (c1) GLOBAL INDEXING FULL;
      CREATE INDEX t1_x2 ON t1 (c2) GLOBAL INDEXING PARTIAL; -- INDEXING OFF된 파티션은 조회 불가능
      CREATE INDEX t1_x3 ON t1 (c1, c2) LOCAL INDEXING FULL;
      CREATE INDEX t1_x4 ON t1 (c2, c1) LOCAL INDEXING PARTIAL; -- INDEXING OFF된 파티션은 조회 불가능
      ```
      ```sql
      SELECT index_name, partitioned, indexing, status
      FROM user_indexes
      WHERE table_name = 'T1';
      -- T1_X1, NO , FULL   , VALID
      -- T1_X2, NO , PARTIAL, VALID
      -- T1_X3, YES, FULL   , N/A
      -- T1_X4, YES, PARTIAL, N/A
      ```
      ```sql
      SELECT index_name, partition_name, status
      FROM   user_ind_partitions
      WHERE  index_name IN ('T1_X3', 'T1_X4');
      -- T1_X3, P1, USABLE
      -- T1_X3, P2, USABLE
      -- T1_X4, P1, USABLE
      -- T1_X4, P2, UNUSABLE
      ```
  * 온라인 전환
    * ALTER TABLE문을 사용하면 비 파티션 테이블을 파티션 태이블로 변환 가능
      ```sql
      DROP TABLE t1 PURGE;

      CREATE TABLE t1 (c1 NUMBER, c2 NUMBER);
      CREATE INDEX t1_x1 ON t1 (c1);
      CREATE INDEX t1_x1 ON t1 (c2);

      INSERT INTO t1 VALUES (1, 1);
      INSERT INTO t1 VALUES (2, 2);
      INSERT INTO t1 VALUES (3, 2);
      COMMIT;
      ```
      ```sql
      ALTER TABLE t1 MODIFY
      PARTITION BY RANGE (c2) (
            PARTITION p1 VALUES LESS THAN (2)
          , PARTITION p2 VALUES LESS THAN (3)
          , PARTITION p3 VALUES LESS THAN (MAXVALUE)
      )
      ONLINE
      UPDATE INDEXES (
            t1 x1 GLOBAL
          , t1_x2 LOCAL
      );
      ```

<br>

### 뷰 (View)
* SELECT 문을 데이터베이스에 저장한 오브젝트
* 기본 문법
  * CREATE VIEW 문
    ```sql
    CREATE [OR REPLACE] [[NO] FORCE] VIEW [schema.]view [(alias [, alias]...)]
    AS subquery
    [WITH {READ ONLY | CHECK OPTION} [CONSTRAINT constraint]];
    ```
    ```sql
    DROP TABLE t1 PURGE;
    
    CREATE TABLE t1 (c1 NUMBER, c2 NUMBER, CONSTRAINT t1_pk PRIMARY KEY (c1));
    
    INSERT INTO t1 VALUES (1, 1);
    INSERT INTO t1 VALUES (2, 2);

    COMMIT;
    ```
    ```sql
    CREATE OR REPLACE VIEW v1 AS SELECT * FROM t1 WHERE c2 = 1;
    ```
    ```sql
    SELECT * FROM v1;
    -- 1, 1
    ```
    ```sql
    INSERT INTO v1 VALUES (3, 3);
    INSERT INTO v1 VALUES (4, 1);
    COMMIT;
    ```
    ```sql
    SELECT * FROM v1;
    -- 1, 1
    -- 4, 1
    ```
    ```sql
    SELECT text_length, text_vc
    FROM   user_views
    WHERE  view_name = 'V1';
    -- 37, SELECT "C1"."C2" FROM t1 WHERE c2 = 1
    ```


<br>
<hr>
<br>

## DCL 문
#### 

<br>

### 

<br>
<hr>
<br>

## SCS 문
#### 

<br>

### 

<br>
<hr>
<br>
