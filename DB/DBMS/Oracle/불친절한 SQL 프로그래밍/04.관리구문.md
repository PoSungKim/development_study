## 관리구문
> 
* 

<hr>
<br>

## DML 문 (Data Manipulation Language)
#### INSERT/UPDATE/DELETE/MERGE

<br>

### INSERT 문
* 단일 테이블 INSERT 문
  * VALUES 절: 단일 행 삽입
  ```sql
  INSERT INTO {table | view | subquery} [t_alias] [(column [, column]...)]
       VALUES ({expr | DEFAULT} [, {expr | DEFAULT}]...)
  ```
  ```sql
  CREATE TABLE t1 (empno NUMBER(4), ename VARCHAR2(10), deptno NUMBER(2) DEFAULT 20);
  
  -- INTO/VALUES절에 지정되지 않은 열: 기본값이 었으면 기본값; 없으면, NULL 삽입
  INSERT INTO t1 (empno, ename, deptno) VALUES (7369, 'SMITH' , 20);
  
  -- INTO절에 열을 지정하지 않으면, VALUES절에 전체 열의 값 기술 필요
  INSERT INTO t1 VALUES (7788, 'SCOTT' , 20);
  
  -- DEFAULT 값이 설정되어 있는 열에는 DEFAULT 키워드 사용 가능
  INSERT INTO t1 VALUES (7876, 'ADAMS' , DEFAULT);
  
  -- 열을 추가하면 상단에서 INTO절에 열을 지정하지 않아서 VALUES절에 전체 열을 기술해야 했던 모든 쿼리에서 에러가 발생한다
  -- 따라서, 하단의 쿼리처럼 INTO절에 열을 지정하는 방식이 쿼리의 안정성 측면에서 바람직하다
  ALTER TABLE t1 ADD job VARCHAR2(9);
  INSERT INTO t1 (empno, ename, deptno) VALUES (7902, 'FORD' , 20);
  ```
  * 서브 쿼리: 서브 쿼리의 결과 삽입
  ```sql
  INSERT INTO {table | view | subquery} [t_alias] [(column [, column]...)]
  subquery
  ```
  ```sql
  -- 서브쿼리 결과가 다중행이면 다중행이 INSERT된다
  INSERT INTO t1 (empno, ename)
  SELECT empno, ename FROM emp WHERE job = 'ANALYST';

  -- 서브쿼리에 UNION ALL 연산자를 사용하면 여러 태이블의 행 삽입 가능
  INSERT INTO t1 (empno, ename)
  SELECT empno, ename  FROM emp  WHERE job = 'PRESIDENT'
  UNION ALL
  SELECT deptno, dname FROM dept WHERE deptno = 10;
  ```
* 다중 테이블 INSERT 문
  * 무조건 INSERT 문: 모든 테이블에 서브 쿼리 결과 삽입
  ```sql
  INSERT ALL {INTO table [(column [, column]...] [VALUES ({expr | DEFAULT} [, {expr | DEFAULT}]...)]}...
  subquery
  ```
  ```sql
  CREATE TABLE t1 (empno NUMBER(4), job VARCHAR2(9));
  CREATE TABLE t2 (empno NUMBER(4), mgr NUMBER(4)  );

  -- t1, t2 테이블 각각에 행3개씩 INSERT
  INSERT ALL
         INTO   t1 (empno, job) VALUES (empno, job)
         INTO   t2 (empno, mgr) VALUES (empno, mgr)
  SELECT * FROM emp WHERE deptno = 10;

  -- PIVOT INSERT문: 서브 쿼리의 1행이 t1 테이블에 4번 삽입된다
  CREATE TABLE t1 (deptno NUMBER(2), tp VARCHAR2(3), sal NUMBER(7,2));
  
  INSERT ALL
         INTO t1 VALUES (deptno, 'MIN', sal_min)
         INTO t1 VALUES (deptno, 'MAX', sal_max)
         INTO t1 VALUES (deptno, 'SUM', sal_sum)
         INTO t1 VALUES (deptno, 'AVG', sal_avg)
  SELECT deptno
       , MIN (sal) AS sal_min
       , MAX (sal) AS sal_max
       , SUM (sal) AS sal_sum
       , AVG (sal) AS sal_avg
  FROM  emp
  GROUP BY deptno;
  ```
* 조건부 INSERT 문: 조건을 만족하는 테이블에 서브 쿼리 결과 삽입
  * ALL: 조건을 만족하는 모든 테이블에 행 삽입
  * FIRST: 조건을 만족하는 첫 번째 테이블에 행 삽입
  ```sql
  INSERT [ALL | FIRST]
    WHEN condition THEN
    INTO table [(column [, column]...)] [VALUES ({expr | DEFAULT} [, {expr | DEFAULT}]...)]
   [WHEN condition THEN
    INTO table [(column [, column]...)] [VALUES ({expr | DEFAULT} [, {expr | DEFAULT}]...)]
   [ELSE
    INTO table [(column [, column]...)] [VALUES ({expr | DEFAULT} [, {expr | DEFAULT}]...)]
  subquery
  ```
  ```sql
  CREATE TABLE t1 AS SELECT empno, ename, sal FROM emp WHERE 0 = 1;
  CREATE TABLE t2 AS SELECT * FROM t1;
  CREATE TABLE t3 AS SELECT * FROM t1;

  -- 조건을 만족하는 모든 테이블에 삽입
  INSERT ALL
        WHEN sal >= 2000 THEN INTO t1
        WHEN sal >= 3000 THEN INTO t2
        ELSE INTO t3
  SELECT empno, ename , sal FROM emp WHERE deptno = 10;

  -- 조건을 만족하는 첫번째 테이블에 삽입
  INSERT FIRST
          WHEN sal >= 2000 THEN INTO t1
          WHEN sal >= 3000 THEN INTO t2
          ELSE INTO t3
  SELECT empno, ename , sal FROM emp WHERE deptno = 10;
  ```

<br>

### UPDATE 문 
* 기본 문법
  * UPDATE > WHERE > SET (행별)
  ```sql
  UPDATE {table | view | subquery} [t_alias]
     SET {column = {expr | (subquery) | DEFAULT} | (column [, column]...) = (subquery)}
      [, {column = {expr | (subquery) | DEFAULT} | (column [, column]...) = (subquery)}]...
  WHERE condition;
  ```
* t1(dept, 갱신할 테이블):t2(emp, 나머지 테이블)=1:M 비식별 관계
  ```sql
  CREATE TABLE t1 AS SELECT deptno, dname, 0 AS sal, 0 AS comm FROM dept;
  CREATE TABLE t2 AS SELECT empno, ename, sal, comm, deptno    FROM emp;

  ALTER TABLE t1 ADD CONSTRAINT t1_pk PRIMARY KEY (deptno);
  ALTER TABLE t2 ADD CONSTRAINT t2_pk PRIMARY KEY (empno);
  ALTER TABLE t2 ADD CONSTRAINT t2_f1 FOREIGN KEY (deptno) REFERENCES t1 (deptno);
  
  UPDATE t1 SET sal = 10000, comm = 1000 WHERE deptno = 40;
  ```
* 다중 열 서브 쿼리: 서브 쿼리의 결과로 갱신
  * UPDATE 기준은 t1의 행 별로 t2와 조인을 해서 얻은 값으로 갱신한다
  * 만약 조인의 결과가 없다면, SUM 집계함수 결과가 NULL이 되기 때문에, (a.sal, a.comm) = (NULL, NULL)로 갱신된다
  ```sql
  UPDATE t1 a
     SET (a.sal, a.comm) =
         (SELECT SUM (x.sal), SUM (x.comm) FROM t2 x WHERE x.deptno = a.deptno);
  ```
  * 조인의 결과가 없어서 NULL값 갱신을 피하기 위해서 EXISTS절을 추가한다
  ```sql
  UPDATE t1 a
  SET    (a.sal, a.comm) =
         (SELECT SUM (x.sal), SUM (x.comm) FROM t2 X WHERE x.deptno = a.deptno)
  WHERE  EXISTS (SELECT 1 FROM t2 X WHERE x.deptno = a.deptno);
  ```
* 인라인뷰 사용 가능
  * GOOD! 갱신할 테이블:나머지 테이블=1:1(차수) - 단일 행이 단일 값으로 갱신되는 것이 보장되어야 한다
    * GROUP BY deptno를 통해서 차수를 1:1로 맞춰줌
  ```sql
  -- 인라인 뷰를 통해 t2 테이블은 1번만 읽게 설계 가능
  UPDATE( SELECT a.sal, a.comm, b.sal AS sal_n, b.comm AS comm_n
            FROM t1 a
               , (SELECT deptno, SUM(sal) AS sal, SUM(comm) AS comm
                    FROM t2
                   GROUP BY deptno) b
            WHERE b.deptno = a.deptno )
  SET sal = sal_n, comm = comm_n;
  ```
    * MERGE문으로 대체 가능
  ```sql
  MERGE
   INTO t1 t
  USING (SELECT deptno, SUM(sal) AS sal, SUM(comm) AS comm
           FROM t2
       GROUP BY deptno) s
     ON (t.deptno = s.deptno)
  WHEN MATCHED THEN
        UPDATE SET t.sal = s.sal, t.comm = s.comm;
  ```
  * BAD! 갱신할 테이블:나머지 테이블=1:M(차수) - ORA-01779(키-보존된 것이 아닌 테이블로 대응한 열을 수정할 수 없습니다) 발생
    * 1쪽 테이블(t1)의 값이 M쪽 테이블(t2)의 값으로 여러 번 갱신될 수 있기 때문
    ```sql
    UPDATE (SELECT a.sal, a.comm, b.sal AS sal_n, b.comm AS comm_n
              FROM t1 a, t2 b
             WHERE b.deptno = a.deptno)
       SET sal = sal_n, c. mm = comm_n;
    ```
  * GOOD! 갱신할 테이블:나머지 테이블=M:1(차수) - 단일 행이 단일 값으로 갱신되는 것이 보장되어야 한다
    * M쪽 테이블(t2)의 값이 1쪽 테이블(t1)의 값으로 1번만 갱신되는 것이 보장된다
    ```sql
    UPDATE (SELECT a.sal, a.comm, b.sal AS sal_n, b.comm AS comm_n
              FROM t2 a, t1 b
             WHERE b.deptno = a.deptno)
       SET sal = sal_n, c. mm = comm_n;
    ```

<br>

### DELETE 문
* 기본 문법
  * FROM > WHERE > DELETE
  ```sql
  DELETE
    FROM { table | view | subquery} [t_alias]
   WHERE condition;
  ```
* 예시
  ```sql
  DELETE FROM t1 WHERE deptno = 10;
  ```
  ```sql
  DELETE
    FROM t1 a
   WHERE NOT EXISTS (SELECT 1 FROM emp x WHERE x.deptno = a.deptno);
  ```
  ```sql
  DELETE FROM t1;
  ```
* 실수 방지
  * 먼저 SELECT문을 작성하고, SELECT문을 UPDATE문이나 DELETE문으로 변경하는 방식을 사용해야 실수 방지 가능
  * UPDATE
  ```sql
  SELECT a.*
       , (SELECT SUM( x.comm )
            FROM emp x
           WHERE x.deptno = a.deptno
    FROM t1 a
   WHERE EXISTS
         (SELECT 1
            FROM emp x
           WHERE x.deptno = a.deptno);
  ```
  ```sql
  UPDATE t1 a
     SET a.sal = (SELECT SUM( x.comm )
                    FROM emp x
                   WHERE x.deptno = a.deptno)
   WHERE EXISTS
         (SELECT 1
            FROM emp x
           WHERE x.deptno = a.deptno);
  ```
  * DELETE
  ```sql
  SELECT a.*
    FROM t1 a
   WHERE NOT EXISTS (SELECT 1
                       FROM emp x
                      WHERE x.deptno = a.deptno);
  ```
  ```sql
  DELETE
    FROM t1 a
   WHERE NOT EXISTS (SELECT 1
                       FROM emp x
                      WHERE x.deptno = a.deptno);
  ```

<br>

### MERGE 문
* 기본 문법
  * INTO절: 갱신 또는 삽입할 타켓 테이블
  * USING절: 갱신 또는 상비에 사용할 소스 테이블
  * ON절: 갱신 또는 삽입을 결정하는 조건
  * MERGE UPDATE절: ON 절의 조건이 만족하는 경우 수행될 구문
  * MERGE INSERT절: ON 절의 조건이 만족하지 않는 경우 수행될 구문
  ```sql
  MERGE 
   INTO { table | view | (subquery) } [t_alias]
  USING { table | view | (subquery) } [t_alias]
     ON ( condition )
   WHEN MATCHED THEN
         UPDATE 
            SET column = { expr | DEFAULT } [, column = { expr | DEFAULT }
         [WHERE condition{
        [DELETE 
          WHERE condition]
   WHEN NOT MATCHED THEN 
         INSERT [(column [, column]...)]
          VALUES ({ expr | DEFAULT } [, { expr | DEFAULT }]...)
          [WHERE condition];
  ```
* 예시
  ```sql
  MERGE
   INTO t1 t
  USING t2 s
     ON (t.empno = s.empno)
   WHEN MATCHED THEN
        UPDATE
           SET t.sal = s.sal - 500
   WHEN NOT MATCHED THEN
        INSERT (t.empno, t.ename, t.job)
        VALUES (s.empno, s.ename, s.job);
  ```
* 선택 작업
  * MERGE UPDATE절
  ```sql
  MERGE
   INTO t1 t
  USING t2 s
     ON (t.empno = s.empno)
   WHEN MATCHED THEN
        UPDATE
           SET t.sal = s.sal - 500;
  ```
  ```sql
  -- 동일 결과 UPDATE문
  UPDATE (SELECT a.sal , b.sal AS sal_n FROM t1 a, t2 b WHERE b.empno = a.empno)
  SET sal = sal n - 500;
  ```
  * MERGE INSERT절
  ```sql
  MERGE
   INTO t1 t
  USING t2 s
     ON (t.empno = s.empno)
   WHEN NOT MATCHED THEN
        INSERT (t.empno, t.ename, t.job)
        VALUES (s.empno, s.ename, s.job);
  ```
  ```sql
  -- 동일 결과 INSERT문
  INSERT INTO t1(empno, ename, job, sal)
      AS SELECT empno, ename, job
           FROM t2 s
          WHERE NOT EXISTS (SELECT 1
                              FROM t1 t
                             WHERE t.empno = s.empno;
  ```
* WHERE 절
  * MERGE UPDATE: 타깃 테이블(t1)의 일반 조건
  ```sql
  MERGE
   INTO t1 t
  USING t2 s
     ON (t.empno = s.empno)
   WHEN MATCHED THEN
         UPDATE
            SET t.sal = s.sal - 500
          WHERE t.job = 'CLERK';
  ```
  ```sql
  -- 동일 결과 인라인뷰 방식
  MERGE
   INTO (SELECT * FROM t1 WHERE job = 'CLERK') t
  USING t2 s
     ON (t.empno = s.empno)
   WHEN MATCHED THEN
         UPDATE
            SET t.sal = s.sal - 500;
  ```
  * MERGE UPDATE: 소스 테이블(t2)의 일반 조건
  ```sql
  MERGE
   INTO t1 t
  USING t2 s
     ON (t.empno = s.empno)
   WHEN MATCHED THEN
         UPDATE
            SET t.sal = s.sal - 500
          WHERE s.job = 'CLERK';
  ```
  ```sql
  -- 동일 결과 인라인뷰 방식
  MERGE
   INTO t1 t
  USING (SELECT * FROM t2 WHERE job = 'CLERK') s
     ON (t.empno = s.empno)
   WHEN MATCHED THEN
         UPDATE
            SET t.sal = s.sal - 500;
  ```
  * MERGE UPDATE: 타깃 테이블(t1)의 일반 조건 && 소스 테이블(t2)의 일반 조건
  ```sql
  MERGE
   INTO t1 t
  USING t2 s
     ON (t.empno = s.empno)
   WHEN MATCHED THEN
         UPDATE
            SET t.sal = s.sal - 500
          WHERE (   ( t.job = 'CLERK' AND s.sal >= 1000 )
                  OR( t.job <> 'CLERK') );
  ```
  * MERGE INSERT: 타겟 테이블(t1)의 일반 조건 `불가능!`
  ```sql
  -- ORA-38102: INSERT WHERE 절에 부적합한 열이 있음 "T"."JOB"
  MERGE
   INTO t1 t
  USING t2 s
     ON (t.empno = s.empno)
   WHEN NOT MATCHED THEN
        INSERT (t.empno, t.ename, t.job)
        VALUES (s.empno, s.ename, s.job)
        WHERE  t.job = 'CLERK';
  ```
  ```sql
  -- ORA-00001: 무결성 제약 조건 (SCOTT.T1_PK)에 위배됩니다
  -- INSERT 대상은 인라인뷰가 아닌 테이블이기 때문에 이미 JONES가 있는데 JONES가 INSERT되서 PK Violation이 발생했다
  MERGE
   INTO (SELECT * FROM t1 WHERE job = 'CLERK') t
  USING t2 s
     ON (t.empno = s.empno)
   WHEN NOT MATCHED THEN
        INSERT (t.empno, t.ename, t.job)
        VALUES (s.empno, s.ename, s.job)
  ```
  * MERGE INSERT: 소스 테이블(t2)의 일반 조건
  ```sql
  MERGE
   INTO t1 t
  USING t2 s
     ON (t.empno = s.empno)
   WHEN NOT MATCHED THEN
        INSERT (t.empno, t.ename, t.job)
        VALUES (s.empno, s.ename, s.job)
        WHERE  s.job = 'CLERK';
  ```
  ```sql
  -- 동일 결과 인라인뷰 방식
  MERGE
   INTO t1 t
  USING (SELECT empno, ename, job FROM t2 WHERE job = 'CLERK') s
     ON (t.empno = s.empno)
   WHEN NOT MATCHED THEN
        INSERT (t.empno, t.ename, t.job)
        VALUES (s.empno, s.ename, s.job)
  ```
* DELETE절
  * DELETE절은 MERGE UPDATE 절로 갱신된 행을 대상으로 수행되며, 갱신된 값을 기준으로 행을 삭제한다
  ```sql
  -- 갱신된 sal가 300인 SMITH가 삭제된다
  MERGE
   INTO t1 t
  USING (SELECT * FROM t2 WHERE job = 'CLERK') s
     ON (t.empno = s.empno)
   WHEN MATCHED THEN
         UPDATE
            SET t.sal = s.sal - 500;
          WHERE t.job = 'CLERK'
         DELETE
           WHERE t.sal < 1000;
  ```
* MERGE UPDATE/DELETE/INSERT
  ```sql
  MERGE
   INTO t1 t
  USING (SELECT * FROM t2 WHERE job = 'CLERK') s
     ON (t.empno = s.empno)
   WHEN MATCHED THEN
         UPDATE
            SET t.sal = s.sal - 500;
          WHERE t.job = 'CLERK'
         DELETE
           WHERE t.sal < 1000;
   WHEN NOT MATCHED THEN
        INSERT (t.empno, t.ename, t.job)
        VALUES (s.empno, s.ename, s.job)
         WHERE s.job = 'CLERK';
  ```

<br>

### 고급 주제
* 조인 차수
  * MERGE 문도 UPDATE 문처럼 조인 치수에 따라 에러가 발생할 수 있다
    * t1(타겟 테이블):t4(소스 테이블)=1:M
      * t1 행이 t4 행들로 여러번 갱신될 수 있기 때문
  ```sql
  -- ORA-30926: 원본 테이블의 고정 행 집함을 가져올 수 없습니다
  -- t:s=차수 1:M
  MERGE
   INTO t1 t
  USING t4 s
     ON (t.empno = s.empno)
   WHEN MATCHED THEN
         UPDATE
            SET t.sal = s.sal - 500;
  ```
  ```sql
  -- 정상처리
  -- 차수 1:1을 맞춰줬기 때문
  MERGE
   INTO t1 t
  USING (SELECT * 
           FROM SELECT a.* 
                     , ROW_NUMBER() OVER (PARTITION BY a.empno
                                                ORDER BY a.yyyy DESC) AS rn
                   FROM t4) a
          WHERE rn = 1) s
     ON (t.empno = s.empno)
   WHEN MATCHED THEN
         UPDATE
            SET t.sal = s.sal - 500;
  ```
* 조인 조건
  * ON절에 기술된 열은 갱신할 수 없다 (무한 루프 발생 가능)
  ```sql
  -- ORA-38104: ON 절에서 참조되는 열은 업데이트할 수 없음: "T"."EMPNO"
  MERGE
   INTO t1 t
  USING (SELECT empno, empno + ROW_NUMBER() OVER (ORDER BY empno) AS empno_n
           FROM t1) s
     ON (t.empno = s.empno)
   WHEN MATCHED THEN
         UPDATE
            SET t.empno = s.empno_n;
  ```
  * 타겟 테이블과 소스 테이블이 동일하면 ROWID 슈도칼럼 사용 가능
  ```sql
  -- 정상처리
  MERGE
   INTO t1 t
  USING (SELECT empno, empno + ROW_NUMBER() OVER (ORDER BY empno) AS empno_n
           FROM t1) s
     ON (t.ROWID = s.ROWID)
   WHEN MATCHED THEN
         UPDATE
            SET t.empno = s.empno_n;
  ```
  * 다른 테이블을 기준으로 ON절에 기술된 열을 갱신하려면 USING절에서 갱신할 테이블을 조인해야 한다
  ```sql
  -- ORA-38104 가 발생하지 않도록 rowid를 ON절에 넣음으로써 우회하는 방법이다
  MERGE
   INTO t1 1
  USING (SELECT a.empno_n, b.ROWID AS rid
           FROM (SELECT empno, empno + ROW_NUMBER() OVER (ORDER BY empno) AS empno_n
                   FROM t3) a
               , t1 b
          WHERE b.empno = a.empno) s
     ON (t.ROWID = s.rid)
   WHEN MATCHED THEN
         UPDATE
            SET t.empno = s.empno_n;
  ```
  * UPDATE문은 분석 함수로 인해 에러 발생
  ```sql
  -- ORA-01779: 키-보존된것이 아닌 테이블로 대응한 열을 수정할 수 없습니다 
  UPDATE (SELECT a.empno, b.empno
            FROM t1 a
               , (SELECT empno, empno + ROW_NUMBER() OVER (ORDER BY empno) AS empno_n
                    FROM t3) b
           WHERE b.empno = a.empno)
     SET empno = empno_n;
  ```
* 일반 조건
  * WHEN MATCHED THEN) ON절에 일반조건을 넣기보다는 인라인뷰에 넣는 것이 가독성에 좋다
  ```sql
  -- 동일 결과
  MERGE
   INTO t1 t
  USING t2 s
     ON (t.job = 'CLERK' AND t.empno = s.empno)
  WHEN MATCHED THEN
        UPDATE
           SET t.sal = s.sal - 500;

  -- 동일 결과
  MERGE
   INTO (SELECT * FROM t1 WHERE job = 'CLERK') t
  USING t2 s
     ON (t.empno = s.empno)
  WHEN MATCHED THEN
        UPDATE
           SET t.sal = s.sal - 500;
  ```
  ```sql
  -- 동일 결과
  MERGE
   INTO t1 t
  USING t2 s
     ON (t.empno = s.empno AND s.job = 'CLERK')
  WHEN MATCHED THEN
        UPDATE
           SET t.sal = s.sal - 500;

  -- 동일 결과
  MERGE
   INTO t1 t
  USING (SELECT * FROM t2 WHERE job = 'CLERK') s
     ON (t.empno = s.empno)
  WHEN MATCHED THEN
        UPDATE
           SET t.sal = s.sal - 500;
  ```
  * WHEN NOT MATCHED THEN) ON절에 일반조건을 넣으면 의도하지 않은 ON절이 TRUE가 되면서 에러가 발생할 수 있다
    * ON절이 FALSE인 행이 삽입되므로, `t.job <> 'CLERK' || t.empno <> s.empno`인 조건이 True인 행들이 업데이트된다
  ```sql
  -- ORA-00001: 무결성 제약 조건 (SCOTT. T1 _PK)에 위배됩니다
  MERGE
   INTO t1 t
  USING t2 s
     ON (t.job = 'CLERK' AND t.empno = s.empno)
   WHEN NOT MATCHED THEN
        INSERT (t.empno, t.ename, t.sal)
        VALUES (s.empno, s.ename, s.sal);

  -- ORA-00001: 무결성 제약 조건 (SCOTT. T1 _PK)에 위배됩니다
  MERGE
   INTO t1 t
  USING t2 s
     ON (t.job = 'CLERK' AND t.empno = s.empno)
   WHEN NOT MATCHED THEN
        INSERT (t.empno, t.ename, t.sal)
        VALUES (s.empno, s.ename, s.sal);
  ```
* 아우터 조인
  * 타깃 테이블의 전체 행을 갱신할 때 사용 가능
  ```sql
  --GOOD: 성능 좋음
  MERGE
   INTO t1 t --기준 테이블
  USING t3 s --아우터 기준
     ON (t.empno = s.empno(+))
   WHEN MATCHED THEN
         UPDATE
            SET t.sal = NVL(s.sal - 500, 0);

  --BAD: 상관 서브쿼리를 사용하면서 쿼리 성능이 저하될 수 있다
  --스칼라 서브쿼리 (Scalar Subquery)처럼 값을 하나 조회해서 SET하는 방식
  UPDATE t1 a
     SET sal = NVL((SELECT x.sal FROM t3 X WHERE x.empno = a.empno) - 500 , 0);

  --GOOD: 인라인뷰를 사용하면 MERGE문과 동일한 성능 보장 가능
  UPDATE (SELECT a.sal, b.sal AS sal_n
            FROM t1 a, t2 b
           WHERE b.empno(+) = a.empno)
     SET sal =  NVL(sal_n - 500, 0);
  ```

<br>

### DML 에러 로깅
* DML문에서 한 건이라도 에러가 발생하면 모든 건이 롤백되기 때문에, 에러건에 대해서 에러를 발생시키자 않되, 에러 테이블에 에러 내역을 쌓고, 다른 건들은 정상 처리하도록 처리 가능
* 기본 문법
  * INTO: 에러 로깅 테이블을 지정
  * simple_expression: 에러 태그로 사용할 값을 지정
  * REJECT LIMIT: integer로 에러의 한계 값을 지정 (기본값은 0 또는 UNLIMITED)
  ```sql
  LOG ERRORS [INTO [schema.] table] [(simple_expression)]
  [REJECT LIMIT {integer | UNLIMITED}]
  ```
* 예시)
  ```sql
  -- ORA-01438: 이 열에 대해 지정된 전체 자릿수보다 큰 값이 허용됩니다
  -- 0 행이 생성되었습니다
  INSERT INTO t1 VALUES (7839, 'KING', 100000)
     LOG ERRORS INTO e1('1') REJECT LIMIT UNLIMITED;
  ```
  ```sql
  -- ORA-00001: 무결성 제약 조건 (SCOTT.T1_PK)에 위배됩니다
  -- 0 행이 생성되었습니다
  INSERT INTO t1 VALUES (7782, 'CLARK', 2450)
     LOG ERRORS INTO e1('2') REJECT LIMIT UNLIMITED;
  ```
  ```sql
  -- ORA-00001: 무결성 제약 조건 (SCOTT.T1_PK)에 위배됩니다
  -- PK위배되는 행들은 제외하고, 위배하지 않는 행들은 INSERT된다
  INSERT INTO t1 SELECT empno, ename, sal FROM emp WHERE deptno = 10
     LOG ERRORS INTO e1('3') REJECT LIMIT UNLIMITED;
  ```
* IGNORE_ROW_ON_DUPKEY_INDEX 힌트
  * 에러가 발생하는 건들은 무시되고, 정상건들은 정상 처리된다
  ```sql
  INSERT /*+ IGNORE_ROW_ON_DUPKEY_INDEX(T1 T1_U1) */
    INTO t1
  SELECT LEVEL FROM DUAL CONNECT BY LEVEL <= 2;
  ```
 
<br>
<hr>
<br>

## TCS 문 (Transaction Control Statement)
#### 트랜잭션, 데이터 동시성, 데이터 일관성

<br>

### 세팅
* ROWDEPENDENCIES
  * row-level dependency tracking 기능 활성화
    * SCN이 행수준으로 저장되며 행의 길이가 6바이트씩 증가한다
* ROWDEPENDENCIES
  * default 세팅으로, SCN이 블록 단위로 저장된다
```sql
CREATE TABLE t1(cd NUMBER, vl NUMBER) ROWDEPENDENCIES;
```

<br>

### 트랜잭션
* 정의
  * 함께 수행해야 하는 작업의 논리적인 단위
* 구조 
  * 트랜잭션 시작
    * DML문 혹은 SET TRANSACTION
    * UNDO Segment가 할당되고, 트랜잭션에 트랜잭션ID (XID)가 부여된다
      * 트랜잭션ID=UNDO Segment의 번호+슬롯+시퀀스
    * V$TRANSACTION 뷰를 통해 트랜잭션 정보 조회 가능
      ```sql
      SELECT xid, xidusn, xidslot, xidsqn, start_date, start_scn 
        FROM v$transaction;
      ```
  * 트랜잭션 종료
    * COMMIT 혹은 ROLLBACK
* SCN (System Change Number)
  * 오라클 데이터베이스의 논리적 TIMESTAMP로 데이터베이스 내부의 작업 순서를 식별하는 용도로 사용된다
  * ORA_ROWSCN
    * 행의 SCN
      * v$transaction 뷰 테이블의 `start_scn` 칼럼과 동일한 값
      * SCN_TO_TIMESTAMP 함수는 SYS.SMON_SCN_TIME 테이블을 참조하는데, 최대 120시간(5일) 동안의 SCN을 저장한다
        * 5일 이전의 SCN을 조회하면, "ORA-08181: 지정된 번호는 적합한 시스템 변경 번호가 아님" 에러 발생 가능
    ```sql
    SELECT cd, vl, ORA_ROWSCN, SCN_TO_TIMESTAMP (ORA_ROWSCN) AS c1 FROM t1;
    ```
    * 현재 SCN
    ```sql
    SELECT checkpoint_change# FROM v$database;
    ```
 * 기본 문법
   * COMMIT 문
     * 현재 트랜잭션의 변경 내용을 데이터베이스에 영구적으로 저장하고 트랜잭션을 종료한다
   ```sql
   COMMIT [WORK] [[COMMENT string] [WRITE [WAIT | NOWAIT] [IMMEDIATE | BATCH]] | FORCE string [, integer]];
   ```
   * ROLLBACK 문
     * 현재 트랜잭션의 변경 내용을 모두 취소하고 트랜잭션을 종료한다
     * 언두 세그먼트에 저장된 변경 이전 데이터를 통해 데이터를 복구한다
   ```sql
   ROLLBACK [WORK] [TO [SAVEPOINT] savepoint | FORCE string];
   ```
   * SAVEPOINT
     * 롤백할 수 있는 저장점을 생성한다
   ```sql
   SAVEPOINT savepoint;
   ```
   ```sql
   UPDATE t1 SET vl = vl - 10 WHERE cd = 2;
   SAVEPOINT s1;
   UPDATE t1 SET vl = vl + 10 WEHRE cd = 1;
   SAVEPOINT s2;

   DELETE FROM t1;
   SELECT * FROM t1;

   -- 정상처리  
   ROLLBACK TO SAVEPOINT s1;
   -- 에러발생 (ORA-01086: 'S2' 저장점이 이 세션에 설정되지 않았거나 부적합합니다)
   ROLLBACK TO SAVEPOINT s2; 
   ```
     * 오라클 데이터베이스는 DML 문이 수행될 때마다 내부적으로 저장점을 생성한다
       * 에러가 발생하면 직전의 저장점으로 문장 수준 롤백 (statement-level rollback)을 수행한다
   ```sql
   UPDATE t1 SET vl = vl + 18 WHERE cd = 1;
   -- 1행이 업데이트되었습니다
   UPDATE t1 SET vl = 'A' WHERE cd = 1;
   -- ORA-81722: 수치가 부적합합니다
   -- 전체 롤백이 아니라, UPDATE t1 SET vl = vl + 18 WHERE cd = 1;까지의 데이터 변경사항까지는 반영되어 있다
   ```
   * 암시적 커밋 (implicit commit)
     * DDL문은 수행 전에 트랜잭션을 커밋하고 종료 후 다시 트랜잭션을 커밋한다
   ```sql
   BEGIN
       COMMIT;
       DDL문;
       COMIIT;
   EXCEPTION
       WHEN OTHERS THEN ROLLBACK; RAISE;
   END;
   ```
   ```sql
   -- 초기 세팅
   DROP TABLE t2 PURGE;
   -- 정상처리
   CREATE TABLE t2 (c1 NUMBER);
   -- 정상처리

   INSERT INTO t2 VALUES(1);
   -- 정상처리
   CREATE TABLE t2 (c1 NUMBER);
   -- ORA-00955: 기존의 객체가 이름을 사용하고 있습니다
   ROLLBACK;
   -- 정상처리 및 트랜잭션 종료

   SELECT *
   FROM t2;
   -- INSERT INTO t2 VALUES(1) 정상처리된 값이 테이블에 적재되어 있다
   -- CREATE TABLE 문에서 선 COMMIT이 되기 때문에 INSERT INTO문은 COMMIT된다
   ```

<br>

### 데이터 동시성 (Data Concurrency)
* 정의
  * 다수의 시용자가 통일한 데이터에 동시에 접근할 수 있는 것을 말한다
* Locking 메커니즘
  * 오라클 데이터베이스는 데이터 동시성을 보장하기 위해 락(Lock)을 사용한다
    * 오라클 데이터베이스는 락 외에도 래치(Latch)와 뮤텍스(Mutex) 등을 사용하여 자원의 사용을 직렬화한다
  * 자동 락(Automatic Lock)
    * 오라클 락 종류
    ```sql
    SELECT type, name, description FROM v$lock_type ORDER BY type;
    ```
    * 락 유형
      * TM(Table Lock) 락: `테이블`에 설정되는 락
      * TX(Row Lock) 락: 로우 레벨 락(Low Level Lock)으로 `트랜잭션`에 설정되는 락
    * 락은 종류에 따라 설정될 수 있는 모드가 있다
      |                           | RS | RX | S | SRX | X |
      |---------------------------|----|----|---|-----|---|
      | RS (Row Share)            | Y  | Y  | Y | Y   |   |
      | RX (Row eXclusive)        | Y  | Y  |   |     |   |
      | S (Share)                 | Y  |    | Y |     |   |
      | SRX (Share Row eXclusive) | Y  |    |   |     |   |
      | X (eXclusive)             |    |    |   |     |   |
    * DML
      * TM 락: RX 모드
      * TX 락: X 모드
    * DDL
      * TM 락: X 모드
      * TX 락: X 모드
    * dba_lock
      * 락 현황 조회 가능
        * blocking_others: 다른 세션의 락을 블로킹하면 Blocking; 아니면, Not Blocking
    ```sql
    UPDATE...
    -- DML
    SELECT USERENV('SID') FROM dual;
    -- 어떤 Session에서 쿼리가 수행되었는지 조회
    -- session_id 값으로 사용

    SELECT lock_type       -- 락 유형
         , mode_held       -- 현재 잡고 있는 모드 
         , mode_requested  -- 현재 잡지 못하고 요청한 모드
         , blocking_others -- 다른 세션을 블로킹하고 있는지
    FROM   dba_lock
    WHERE  session id = 100
    AND    lock_type in ( 'DML' , 'Transaction' );
    ```
    * 블로킹 예시
      * 로우 레벨 락을 설정하기 위해 블록을 방문하며 로우 헤더(c1=1)를 확인
      * 로우 레벨 락이 설정되어 있는 것을 확인
      * 로우 레벨 락과 연결된 S1 세션의 TX 락이 X 모드인 것을 확인
      * 호환되지 않은 모드이므로 대기 목록에 트랜잭션을 등록하고 대기(블로킹)
    ```sql
    --S1(100)
    UPDATE t1 SET vl = vl + 10 WHERE cd = 1;
    --S1 락 획득
    --S2(200)
    UPDATE t1 SET vl = vl - 10 WHERE cd = 1;
    --S2 락 블로킹
    --S3(300)
    DROP TABLE t1;
    -- ORA-00054: 리소스가 사용 중이어서 NOWAIT가 지정되었거나 시간 초과가 만료된 상태로 획득합니다
    -- DDL문은 TM락을 X 모드로 설정한다
    ```
  * LOCK TABLE
    * 수동으로 테이블에 TM락 설정 가능
    ```sql
    LOCK TABLE [schema.] {table|view} [, [schema.] {table|view}]...
            IN lockmode MODE [NOWAIT|WAIT integer];
    ```
    ```sql
    --S1(100)
    LOCK TABLE t1 IN ROW EXCLUSIVE MODE;
    -- 테이블이 잠금되었습니다.

    --S2(100)
    LOCK TABLE t1 IN EXCLUSIVE MODE NOWAIT;
    -- ORA-00054: 리소스가 사용 중이어서 NOWAIT가 지정되었거나 시간 초과가 만료된 상태로 획득합니다.
    ```
* 동시성 제어
  * 개발 환경에 따라 자동 락(Automatic Lock)을 통한 동시성 보장이 불가능한 경우가 있다
  * Lost Update
  ```sql
  --S1(100)
  COLUMN vl NEW_VALUE v_vl
  --S1(100)
  SELECT vl FROM t1 WHERE cd = 1;
  --vl:40

  --S2(200)
  UPDATE t1 SET vl = vl + 10 WHERE cd = 1;
  --S2(200)
  COMMIT;
  --vl:50

  --S1(100)
  UPDATE t1
     SET vl = &v_vl + 10
   WHERE cd = 1;
  --S1(100)
  SELECT vl FROM t1 WHERE cd = 1;
  --vl:50
  ```
* 비관적 동시성 제어 (Pessimistic Concurrency control, Pessimistic Locking)
  * 다수의 사용자가 동일한 데이터를 동시에 갱신하는 일이 빈번하다고 가정하며, FOR UPDATE절을 사용한다
  * SELECT문에 FOR UPDATE절
    * 조회한 행에 로우 레벨 락이 설정된다
  ```sql
  FOR UPDATE [OF [{table|view}.]column [,[{table|view}.]column]...]
  [{NOWAIT|WAIT integer|SKIP LOCKED}]
  ```
  ```sql
  --S1(100)
  SELECT vl FROM t1 WHERE cd = 1 FOR UPDATE;
  --vl:40

  --S2(200)
  SELECT vl FROM t1 WHERE cd = 1 FOR UPDATE;
  --블로킹

  --S1(100)
  UPDATE t1 SET vl = vl + 10 WHERE cd = 1;
  --S1(100)
  COMMIT;
  --vl:50

  --S2(200)
  UPDATE t1 SET vl = vl + 10 WHERE cd = 1;
  --S2(200)
  COMMIT;
  --vl:60
  ```
  ```sql
  --S2(200)
  SELECT vl FROM t1 WHERE cd = 1 FOR UPDATE NOWAIT;
  --ORA-00054: 리소스가 사용 중이어서 NOWAIT가 지정되었거나 시간 초과가 만료된 상태로 획득합니다

  --S2(200)
  SELECT vl FROM t1 WHERE cd = 1 FOR UPDATE WAIT 10;
  --ORA-30006: 리소스 사용 중. WAIT 시간 초과로 획득이 만료됨

  --S2(200)
  SELECT vl FROM t1 FOR UPDATE SKIP LOCKED;
  --락이 잡히지 않은 행들만 조회된다
  ```
  * 조인이 사용된 FOR UPDATE
  ```sql
  --S1(100)
  SELECT *
    FROM emp a, dept b
   WHERE b.deptno = a.deptno
     FOR UPDATE OF a.deptno;
  -- FOR UPDATE절에 지정한 열의 테이블 행에만 락이 설정된다
  -- a.deptno > emp a

  --S2(200)
  SELECT * FROM dept FOR UPDATE NOWAIT;
  --정상조회
  --S2(200)
  SELECT * FROM emp  FOR UPDATE NOWAIT;
  --ORA-00054: 리소스가 사용 중이어서 NOWAIT가 지정되었거나 시간 초과가 만료된 상태로 획득합니다
  
  --S1(100)
  COMMIT;
  --S2(200)
  COMMIT;
  ```
* 낙관적 동시성 제어 (Optimistic Concurrency Control, Optimistic Locking)
  * 다수의 사용자가 동일한 데이터를 동시에 갱신하는 일이 드믈다고 가정한다
  * 칼럼 확인 방식
    * 변경할 값을 조회하여 저장하고, 값을 변경하기 전에 저장한 값의 변경 여부를 확인하는 방식이다
    * 변경할 값이 많은 경우, 모든 값을 비교해야 하기 때문에 쿼리가 길어질 수 있다
  ```sql
  --S1(100)
  COLUMN vl NEW_VALUE v_vl
  --S1(100)
  SELECT vl FROM t1 WHERE cd = 1;
  --vl:40

  --S2(200)
  UPDATE t1 SET vl = vl + 10 WHERE cd = 1;
  --S2(200)
  COMMIT;
  --vl:50

  --S1(100)
  UPDATE t1
     SET vl = vl + 10
   WHERE cd = 1
     AND vl = &v_vl;
  --0행이 업데이트되었습니다.
  ```
  * 버전 확인 방식
    * 버전 정보를 변수에 저장하고, 값을 변경하기 전에 저장한 버전 정보의 변경 여부를 확인하는 방식
      * 쿼리가 간결해지는 장점
      * 버전 속성값이 추가되어야 하는 단점
  ```sql
  --S1(100)
  COLUMN md NEW_VALUE md
  --S1(100)
  SELECT md FROM t1 WHERE cd = 1;
  --md: 특정 일시

  --S2(200)
  UPDATE t1 
     SET vl = vl + 10, md = SYSDATE
   WHERE cd = 1;
  --S2(200)
  COMMIT;
  --vl:50

  --S1(100)
  UPDATE t1
     SET vl = vl + 10
   WHERE cd = 1
     AND md = TO_CHAR(&md,
              , 'YYYY-MM-DD HH24:MI:SS');
  --0행이 업데이트되었습니다.
  ```
* 데이터 일관성 (Data Consistency)
  * 트랜잭션에 의한 변경을 일관된 상태로 볼 수 있음을 의미한다
  * Trade-off 관계
    * 데이터 동시성 vs 데이터 일관성
  * 다중 버전 읽기 일관성 (Multiversion Read Consistency, MVRC), Multiversion Concurrency Control (MVCC)
    * 쿼리가 시작된 시점의 데이터를 조회할 수 있는 기능
      * 쿼리가 시작된 SCN과 블록의 SCN을 비교하여 쿼리가 시작된 시점의 데이터를 반환한다
    * 언두 세그먼트 공간은 일정 시점이 지나면 재사용될 수 있다
      * 쿼리 시작 시점의 변경 이전의 데이터가 저장된 공간이 재사용되면 해당 시점의 데이터를 반환할 수 없게 된다
      * 이때, `ORA-01555: 너무 이전 스냅샷` 발생
      * 이를, 다중 버전 읽기 일관성의 부작용으로 보기도 한다
    ```sql
    --S2
    SELECT vl FROM t1 WHERE cd = 1; --40
    --S1
    UPDATE t1 SET vl = vl + 10 WHERE cd = 1;
    --S1
    SELECT vl FROM t1 WHERE cd = 1; --50
    --S2
    SELECT vl FROM t1 WHERE cd = 1; --40
    --S1
    COMMIT;
    --S2
    SELECT vl FROM t1 WHERE cd = 1; --50
    ```
  * 문장 수준 읽기 일관성 (Statement-level Read Consistency)
    * 오라클은 다중 버전 읽기 일관성을 지원하기 때문에 락을 사용하지 않고 문장 수준 읽기 일관성을 보장한다
  * 트랜잭션 수준 읽기 일관성 (Transaction-level Read Consistency)
    * 오라클은 기본적으로 트랜잭션 수준 읽기 일관성을 보장하지 않는다
    * 따라서, 고립화 수준을 변경해야 한다
  * ANSI/ISO SQL 표준 트랜잭션 고립화 수준 (Transaction Isolation Level)
    * read uncommitted: 커밋되지 않은 데이터를 읽는 것을 허용
      * dirty read, non-repeatable read, phantom read
    * read committed: 커밋된 데이터만 읽는 것을 허용
      * non-repeatable read, phantom read
    * repeatable reads: 트랜잭션 내에서 읽은 데이터는 갱신과 삭제를 금지
      * phantom read
    * serializable: 트랜잭션 내에서 읽은 테이블에 삽입을 금지
  * ANSI/ISO SQL 표준 읽기 이상현상 (read phenomena)
    * dirty read: 동일한 쿼리가 커밋되지 않은 데이터를 읽어 다른 결과를 반환
    * non-repeatable read: 동일한 쿼리가 갱신 또는 삭제에 의해 다른 결과를 반환
    * phantom read: 동일한 쿼리가 삽입에 의해 다른 결과를 반환
  * 오라클 세팅
    * 지원하는 트랜잭션 고립화 수준
      * read committed (default 세팅), serializable
    * repeatable reads 방지 가능
      * SELECT FOR UPDATE 사용
      ```sql
      --S1
      SELECT * FROM t1 FOR UPDATE;
      --S2
      UPDATE t1 SET vl = vl + 10 WHERE cd = 1;
      --블로킹

      --S1
      SELECT SUM(vl) AS vl FROM t1;
      --100
      --S1
      SELECT SUM(vl) AS vl FROM t1;
      --100 (반복 조회시 동일한 값 조회)
      --S1
      COMMIT;
      --S2
      ROLLBACK;
      ```
    * phantom read 방지 불가능
      ```sql
      --S1
      SELECT * FROM t1 FOR UPDATE;
      --S1
      SELECT SUM(vl) AS vl FROM t1;
      --100

      --S2
      INSERT INTO t1(cd, vl) VALUES(3, 50);
      --S2
      COMMIT;

      --S1
      SELECT SUM(vl) AS vl FROM t1;
      --150 (FOR UPDATE를 사용하더라도, phantom read 방지 불가능)
      --S1
      COMMIT;
      ```
* SET TRANSACTION 문
  * READ ONLY: 읽기 전용 트랜잭션으로 설정 (트랜잭션 수준 읽기 일관성 보장)
  * READ WRITE: (Default 세팅) 읽기 쓰기 전용 트랜잭션으로 설정 (문장 수준 읽기 일관성 보장)
  * SERIALIZABLE: 트랜잭션 고립화 수준을 SERIALIZABLE로 설정
  * READ COMMITTED: 트랜잭션 고립화 수준을 READ COMMITTED로 설정
  ```sql
  SET TRANSACTION { {READ {ONLY | WRITE }
                     | ISOLATION LEVEL {SERIALIZABLE | READ COMMITTED}
                     | USE ROLLBACK SEGMENT rollback_segment
                     } [NAME string] 
                   | NAME string};
  ```
  * INSERT 예시)
  ```sql
  --S1
  SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
  --S1
  SELECT SUM(vl) AS vl FROM t1;
  --150

  --S2
  INSERT INTO t1(cd, vl) VALUES(3, 50);
  --S2
  COMMIT;
  
  --S1
  SELECT SUM(vl) AS vl FROM t1;
  --150
  --S1
  COMMIT;
  --트랜잭션 종료되면, 트랜잭션 고립화가 초기화된다
  --즉, 이시점부터는 S1이라는 동일한 세션이 새로운 트랜잭션을 시작하면, 기본값인 READ WRITE로 트랜잭션이 생성된다
  
  --S1
  SELECT SUM(vl) AS vl FROM t1;
  --200
  ```
  * UPDATE 예시)
  ```sql
  --S1
  SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

  --S2
  UPDATE t1 SET vl = vl + 10 WHERE cd = 1;
  --S2
  COMMIT;
  
  --S1
  UPDATE t1 SET vl = vl - 10 WHERE cd = 1;
  --ORA-08177: 이 트랜잭션에 대한 직렬화 액세스를 할 수 없습니다
  --S1
  ROLLBACK;
  ```
  
<br>
<hr>
<br>

## DDL 문 (Data Definition Language)
#### 

<br>

### 테이블
* 기본 문법
  * CREATE TABLE 문
  ```sql
  CREATE TABLE [schema. ]table (
         column datatype [DEFAULT [ON NULL] expr]
      [, column datatype [DEFAULT [ON NULL] expr]]...) [TABLESPACE tablespace]; 
  ```
  ```sql
  CREATE TABLE t1 (
      c1 NUMBER
    , c2 NUMBER(2) DEFAULT 2
    , c3 NUMBER(3) DEFAULT 3 NOT NULL);

  -- 테이블 관련 데이터 딕셔너리 뷰
  -- users_table
  -- user_tab_columns
  ```
  ```sql
  -- 서브쿼리 방식 (CTAS, Create Table As Select)
  CREATE TABLE [schema. ]table [(
         column [DEFAULT [ON NULL] expr]
      [, column [DEFAULT [ON NULL] expr]]...)] [TABLESPACE tablespace]
  AS subquery;
  ```
  ```sql
  -- 타 테이블 칼럼 정보만 가져오기
  -- 데이터 INSERT X
  CREATE TABLE t2 
      AS SELECT * FROM t1 WHERE 0 = 1;
  -- 데이터 타입과 NOT NULL 제약 조건만 참조한다
  -- 기본값 (DEFAULT)값은 참조 X
  ```
  ```sql
  -- 특정 데이터 타입 지정을 위한 CAST 사용
  CREATE TABLE t2 
      AS SELECT 1234 AS c1 -- NUMBER
              , 'AB' AS c2 -- CHAR(2)
              , CAST(1234 AS NUMBER(10)) AS c3 -- NUMBER(10)
              , CAST('AB' AS VARCHAR2(10)) AS c4 -- VARCHAR2(10)
          FROM dual;
  ```
  ```sql
  -- NULL은 데이터 타입의 길이를 결정할 수 없어서 에러 발생
  -- ORA-01723: 길이가 0인 열은 지정할 수 없습니다
  CREATE TABLE t1 AS
  SELECT NULL FROM dual;
  
  -- 정상처리
  DROP TABLE t1 PURGE;
  
  CREATE TABLE t1 AS
  SELECT CAST(NULL AS NUMBER) AS c1
       , CAST(NULL AS VARCHAR2(1)) AS c2
    FROM dual;
  ```
  * 테이블스페이스와 익스텐트
    * 세그먼트 오브젝트
      * 테이블, 인덱스, 파티션
    * 포함 관계
      * 1개의 세그먼트는 1개의 테이블 스페이스에 저장
      * n개의 익스텐트가 1개의 세그먼트 구성
      * n개의 블록이 1개의 익스텐트 구성
    * 세그먼트의 테이블 스페이스 지정
    ```sql
    CREATE TABLE t1 TABLESPACE users AS
    SELECT ROWNUM AS c1 FROM XMLTABLE('1 to 10000');
    
    SELECT tablespace_name FROM user_tables WHERE table_name = 't1';
    -- USERS

    SELECT segment_type, tablespace_name, bytes, blocks
      FROM user_segments
     WHERE segment_name = 't1';
    -- TABLE USERS 196608 24

    SELECT extent_id, bytes, blocks 
      FROM user_extents
     WHERE segment_name = 't1';
    -- 0 extent_id 8 blocks
    -- 1 extent_id 8 blocks
    -- 2 extent_id 8 blocks

    SELECT default_tablespace FROM dba_users WHERE username = 'SCOTT';
    ```
    * SI 단위
      * 킬로(Kilo)
      * 메가(Mega)
      * 기가(Giga)
      * 테라(Tera)
      * 페타(Peta)
      * 엑사(Exa)
      * 제타(Zetta)
      * 요타(Yotta)
  * ALTER TABLE 문
    * RENAME절
    ```sql
    ALTER TABLE [schema.]table RENAME TO new_table_name; 
    ```
    * MOVE절
      * INCLUDING ROWS: 재배치한 데이터의 조건을 지정
      * ONLINE: DDL문이 수행되는 동안 DML문이 수행되도록 허용
      * TABLESPACE: 테이블스페이스를 지정
      * UPDATE INDEXES: 인덱스도 함께 재구성
    ```sql
    ALTER TABLE [schema.]table MOVE
          [INCLUDING ROWS where_clause]
          [ONLINE]
          [TABLESPACE tablespace]
          [UPDATE INDEXES] [(index [, index])];
    ```
    ```sql
    ALTER TABLE t1 MOVE INCLUDING ROWS WHERE c1 <= 5000 TABLESPACE users;
    -- 조건에 미포함되는 데이터는 재배치 되지 않고 제거된다
    ```
    * READ ONLY
      * READ ONLY: 테이블을 읽기 전용으로 변경
      * READ WRITE: 테이블을 읽기 쓰기로 변경 (기본값)
    ```sql
    ALTER TABLE [schema.]table {READ ONLY|READ WRITE};
    ```
    ```sql
    ALTER TABLE t1 READ ONLY;
    INSERT INTO t1(c1) VALUES(1);
    -- ORA-12081: 테이블에 작업을 업데이트하는 것이 허용되지 않습니다
    -- DW 시스템의 경우, 적재가 완료된 소스 테이블을 READ ONLY로 변경하여 소스 테이블을 사용하는 타깃 테이블의 데이터 일관성(Data Consistency)을 높일 수 있다
    SELECT table_name, read_only FROM user_tables WHERE table_name = 't1';
    -- READ ONLY 세팅 확인 가능
    ```
  * DROP TABLE 문
    * CASCADE CONSTRAINTS: 테이블을 참조하는 FK 제약 조건을 함께 삭제
    * PURGE: recycle bin을 사용하지 않고 테이블을 즉시 삭제
  ```sql
  DROP TABLE [schema.]table [CASCADE CONSTRAINTS] [PURGE];
  ```
  ```sql
  DROP TABLE t1 CASCADE CONSTRAINTS PURGE;
  ```
  * TRUNCATE TABLE 문
    * DROP STORAGE (Default): MINEXTENTS 파라미터에 의해 할당된 공간을 제외한 공간을 해제
    * DROP ALL STORAGE: MINEXTENTS 파라미터에 의해 할당된 공간을 포함한 모든 공간을 해제
    * REUSE STORAGE: 삭제된 행의 공간을 유지
    * RECYCLE: ON DELETE CASCADE FK 제약 조건으로 참조하는 테이블을 TRUNCATE
  ```sql
  TRUNCATE TABLE [schema.]table [{DROP[ALL] | REUSE} STORAGE] [CASCADE];
  ```
  ```sql
  TRUNCATE TABLE t1;
  -- DROP ALL STORAGE 사용시, 수행시간을 감소시킬 수 있다
  ```
* 테이블 유형
  * 유형
    * 구조: 힙 구조 테이블, 인덱스 구조 테이블, 익스터널 테이블
    * 분산: 클러스터 테이블, 파티션 테이블
    * 저장: 영구 테이블, 임시 테이블
  * 힙 구조 테이블 (Heap-organized Table)
    * 힙(Heap) 구조로 데이터 저장
      * 임의의 위치에 데이터가 저장된다
  ```sql
  CREATE TABLE [schema.]table (
         column datatype [DEFAULT [ON NULL] expr]
  [,     column datatype [DEFAULT [ON NULL] expr]]...)
  ORGANIZATION HEAP;
  ```
  * 인덱스 구조 테이블 (Index-organized Table, IOT)
    * b-tree 구조로 데이터 저장
      * PK 제약 조건의 열 순서에 따라 데이터가 정렬되어 저장된다
    * IOT는 열의 개수가 많지 않은 테이블에 사용해야 한다
      * 보통, 코드성 테이블 혹은 연관 테이블 (Association Table)에 사용한다
    * 인텍스 외부 영역인 오버플로우 영역에 저장될 수 있다
  ```sql
  CREATE TABLE [schema.]table (
         column datatype [DEFAULT [ON NULL] expr]
  [,     column datatype [DEFAULT [ON NULL] expr]]...
   ,     CONSTRAINT contraint_name PRIMARY KEY (column [, column]...))
  ORGANZATION INDEX;
  ```
  ```sql
  CREATE TABLE t1 (c1 NUMBER, c2 NUMBER, CONSTRAINT t1_pk PRIMARY KEY (c1))
  ORGANIZATION INDEX;
  ```
  ```sql
  SELECT object_name, data_object_id, object_type
  FROM   user_objects
  WHERE  object_name IN ('T1', 'T1_PK');
  -- T1, NULL, TABLE
  -- T1_PK, 109065, INDEX
  
  SELECT segment_name, segment_type
  FROM   user_segments
  WHERE  object_name IN ('T1', 'T1_PK');
  -- IOT는 논리적으로 존재하기 때문에, user_segment에서 조회 X
  -- T1_PK, INDEX
  
  SELECT table_name, iot_type FROM user_tables WHERE table_name = 'T1';
  -- T1, IOT
  ```
  * 익스터널 테이블 (External Table)
    * 외부 데이터를 조회하거나 외부에 데이터를 저장할 수 있는 테이블
      * 주로 DW 시스템의 ETL 작업에 사용된다
    * 액세스 드라이버
      * ORACLE_LOADER: SQL*Loader를 통해 외부 파일에 대한 읽기 전용 작업을 수행
      * ORACLE_DATAPUMP: Data Pump를 통해 데이터를 로드(Load) 또는 언로드(Unload)
  ```sql
  CREATE TABLE [schema.]table (
         column datatype [DEFAULT [ON NULL] expr]
  [,     column datatype [DEFAULT [ON NULL] expr]]...)
  ORGANIZATION EXTERNAL (
         [TYPE access_driver_type]
          DEFAULT DIRECTORY directory
         [ACCESS PARAMETERS (opaque_format_spec)]
          LOCATION ([directory:] 'location_specifier'
                 [, [directory:] 'location_specifier']...)
  ) [REJECT LIMIT {integer | UNLIMITED}];
  ```
  ```sql
  -- 디렉토리 생성
  CREATE OR REPLACE DIRECTORY dir_ext AS 'c:\app\ora12cr2\admin\ora12cr2\ext';
  GRANT ALL ON DIRECTORY dir_ext TO scott;
  ```
  ```sql
  -- _directories 뷰
  SELECT owner, directory_name, directory_path
    FROM all_directories
   WHERE directory_name = 'DIR_EXT';
  -- SYS, DIR_EXT, c:\app\ora12cr2\admin\ora12cr2\ext
  ```
  ```sql
  -- _tab_privs 뷰
  SELECT grantee, owner, table_name, grantor, privilege, type
    FROM user_tab_privs
   WHERE table_name = 'DIR_EXT';
  ```
    * ORACLE LOADER
  ```sql
  CREATE TABLE t1 (deptno NUMBER(2), dname VARCHAR2(14), loc VARCHAR2(13))
  ORGANIZATION EXTERNAL(
          TYPE    ORACLE LOADER
          DEFAULT DIRECTORY dir_ext
          ACCESS  PARAMETERS (
                  RECORDS DELIMITED BY NEWLINE
                  NOBADFILE NOLOGFILE NODISCARDFILE
                  FIELDS TERMINATED BY ',')
          LOCATION ('ext_dept.txt')
  ) REJECT LIMIT UNLIMITED;
  ```
  ```sql
  -- _external_tables 뷰
  SELECT type_name, default_dictionary_name, access_parameters
    FROM user_external_tables
   WHERE table_name = 'T1';
  ```
  ```sql
  -- _external_locations 뷰
  SELECT location, directory_name
    FROM user_external_locations
   WHERE table_name = 'T1';
  ```
    * preprocessor: 데이터베이스 서버의 OS 명령어를 수행하고 수행 결과를 테이블로 조회할 수 있다
  ```sql
  CREATE TABLE t1 (deptno NUMBER(2), dname VARCHAR2(14), loc VARCHAR2(13))
  ORGANIZATION EXTERNAL(
          TYPE    ORACLE LOADER
          DEFAULT DIRECTORY dir_ext
          ACCESS  PARAMETERS (
                  RECORDS DELIMITED BY NEWLINE
                  PREPROCESSOR dir_ext:'ext_unzip.cmd'
                  NOBADFILE NOLOGFILE NODISCARDFILE
                  FIELDS TERMINATED BY ',')
          LOCATION ('ext_dept.txt')
  ) REJECT LIMIT UNLIMITED;
  ```
<br>

### 클러스터 테이블 (Clustered Table)
* 클러스터 키가 동일하 데이터는 동일한 위치에 저장하는 세그먼트
  * INDEX: 인덱스 클러스터
  * HASHKEYS integer: 해시 클러스터
  * SINGLE TABLE: 단일 테이블 해시 클러스터
  * SORT: 정렬 해시 클러스터
```sql
CREATE CLUSTER [schema.]cluster (
       column datatype [SORT]
[,     column datatype [SORT]]...)
[{{INDEX | [SINGLE TABLE] HASHKEYS integer [HASH IS expr]}}...]
[TABLESPACE tablespace];
```
```sql
DROP CLUSTER [schema.]cluster [INCLUDING TABLES [CASCADE CONSTRAINTS]];
```
```sql
TRUNCATE CLUSTER [schema.]cluster [{DROP | REUSE} STORAGE];
```
```sql
CREATE TABLE [schema.]table (
       column datatype [DEFAULT [ON NULL] expr]
[,     column datatype [DEFAULT [ON NULL] expr]]...)
CLUSTER cluster (column [, column]...)
```
* 인덱스 클러스터 (Indexed Cluster)
  * 데이터 저장 및 조회에 인덱스 사용
```sql
-- 인덱스 클러스터 생성
DROP CLUSTER c1# INCLUDING TABLES;
CREATE CLUSTER c1# (c1 NUMBER) INDEX;

-- 클러스터 인덱스 생성
DROP INDEX c1#_x1;
CREATE INDEX c1#_x1 ON CLUSTER c1#;

-- 클러스터 테이블 생성
DROP TABLE t1 PURGE;
DROP TABLE t2 PURGE;

CREATE TABLE t1 (c1 NUMBER, c2 NUMBER) CLUSTER c1# (c1);
CREATE TABLE t2 (c1 NUMBER, c2 NUMBER) CLUSTER c1# (c1);
```
```sql
-- 클러스터 정보
SELECT cluster_name, cluster_type 
  FROM user_clusters 
 WHERE cluster_name = 'C1#';

-- 클러스터 테이블 + 클러스터 키
SELECT cluster_name, clu_column_name, table_name, tab_column_name 
  FROM user_clu_columns 
 WHERE cluster_name = 'C1#';

-- 테이블의 클러스터 정보
SELECT table_name, cluster_name 
  FROM user_tables
 WHERE table_name IN ('T1', 'T2');

-- 클러스터 인덱스 정보
SELECT index_type, table_owner, table_name, table_type
  FROM user_indexes
 WHERE index_name = 'C1#_X1';
```
```sql
-- 불가능) 클러스터 테이블은 동일한 클러스터에 속한 다른 테이블과 블록을 공유하기 때문에 개별 테이블 TRUNCATE 불가능
TRUNCATE TABLE t1;
-- ORA-03292: 잘릴 테이블이 클러스터의 일부입니다

-- 가능)
TRUNCATE CLUSTER c1#;
```
* 해시 클러스터 (Hash Cluster)
  * 데이터 저장 및 조회에 해시 알고리즘 사용
```sql
-- 인덱스 클러스터 생성
DROP CLUSTER c1# INCLUDING TABLES;
CREATE CLUSTER c1# (c1 NUMBER) HASHKEYS 100;

CREATE TABLE t1 (c1 NUMBER, c2 NUMBER) CLUSTER c1# (c1);
CREATE TABLE t2 (c1 NUMBER, c2 NUMBER) CLUSTER c1# (c1);
```
```sql
-- 클러스터 정보
SELECT cluster_name, cluster_type, function, hashkeys
  FROM user_clusters 
 WHERE cluster_name = 'C1#';
```
* 단일 테이블 해시 클러스터 (Single-table Hash Cluster)
  * 클러스터에 단일 테이블만 저장할 수 있는 해시 클러스터
```sql
-- 단일 테이블 해시 클러스터 생성
DROP CLUSTER c1# INCLUDING TABLES;
CREATE CLUSTER c1# (c1 NUMBER) SINGLE TABLE HASHKEYS 100;

DROP TABLE t1 PURGE;
CREATE TABLE t1 (c1 NUMBER, c2 NUMBER) CLUSTER c1# (c1);
```
```sql
-- 클러스터 정보
SELECT cluster_name, single_table
  FROM user_clusters 
 WHERE cluster_name = 'C1#';
```
* 정렬 해시 클러스터 (Sorted Hash Cluster)
  * SORT 키워드를 지정한 열로 데이터를 정렬하여 클러스터에 저장한다
```sql
-- 정렬 해시 클러스터 생성
DROP CLUSTER c1# INCLUDING TABLES;
CREATE CLUSTER c1# (c1 NUMBER, c2 NUMBER SORT) HASHKEYS 100 HASH IS c1;

DROP TABLE t1 PURGE;
CREATE TABLE t1 (c1 NUMBER, c2 NUMBER, c3 NUMBER) CLUSTER c1# (c1, c2);
```
```sql
-- 클러스터 정보
SELECT hash_expression
  FROM user_cluster_hash_expression
 WHERE cluster_name = 'C1#';
```

<br>

### 임시 테이블 (Temporary Table)
* 트랜잭션 혹은 세션 레벨로 관리되는 테이블
* OLAP 혹은 DW 시스템에서 중간 집계를 저장하는 용도의 테이블
  * ON COMMIT DELETE ROWS: 트랜잭션 레벨로 데이터를 저장
  * ON COMMIT PRESERVE ROWS: 세션 레벨로 데이터를 저장
```sql
CREATE GLOBAL TEMPORARY TABLE [schema.]table(
       column datatype [DEFAULT [ON NULL] expr]
[,     column datatype [DEFAULT [ON NULL] expr]]...)
[ON COMMIT [DELETE | PRESERVE] ROWS];
```
```sql
--트랜잭션 레벨 관리
DROP TABLE t1 PURGE;
CREATE GLOBAL TEMPORARY TABLE t1(c1 NUMBER) ON COMMIT DELETE ROWS;
INSERT INTO t1 VALUES(1);
SELECT * FROM t1;
--1
COMMIT;
SELECT * FROM t1;
--선택된 래코드가 없습니다
```
```sql
--세션 레벨 관리
DROP TABLE t1 PURGE;
CREATE GLOBAL TEMPORARY TABLE t1(c1 NUMBER) ON COMMIT PRESERVE ROWS;
INSERT INTO t1 VALUES(1);
COMMIT;
SELECT * FROM t1;
--1
--다시 접속
SELECT * FROM t1;
--선택된 래코드가 없습니다
```
* 트랜잭션 혹은 세션 레벨로 관리되기 때문에, 1개의 임시 테이블을 n개의 세션에서 동시에 사용할 수 있다
  * java의 threadlocal 같이 사용되는 듯
  * 각 세션은 자신이 넣은 데이터 1 or 2 중 1개만 조회됨
```sql
--S1
INSERT INTO t1 VALUES(1);
--S2
INSERT INTO t1 VALUES(2);
--S1
COMMIT;
--S2
COMMIT;
--S1
SELECT * FROM t1;
--1
--S2
SELECT * FROM t1;
--2
```

<br>
  
### 열
* 기본 문법
  * ADD절
  ```sql
  ALTER TABLE [schema.]table ADD (column datatype [DEFAULT [ON NULL] expr] 
                              [, column datatype [DEFAULT [ON NULL] expr]]...);
  ```
  ```sql
  DROP TABLE t1 PURGE;
  CREATE TABLE t1 (c1 NUMBER);
  ALTER TABLE t1 ADD (c2 NUMBER(2), c3 VARCHAR2(2));
  ```
  ```sql
  SELECT column_name, data_type, data_length, data_precision, data_scale
    FROM user_tab_columns
   WHERE table_name = 'T1';
  ```
  * MODIFY절
  ```sql
  ALTER TABLE [schema.]table MODIFY (column datatype [DEFAULT [ON NULL] expr] 
                              [, column datatype [DEFAULT [ON NULL] expr]]...);
  ```
  ```sql
  DROP TABLE t1 PURGE;
  CREATE TABLE t1 (c1 NUMBER(2), c2 NUMBER(2), c3 VARCHAR2(2), c4 DATE);
  INSERT INTO t1 VALUES (1, 1, 'A', DATE '2050-01-01');
  COMMIT;

  ALTER TABLE t1 MODIFY (c1 DEFAULT 1);
  -- 정상처리
  ALTER TABLE t1 MODIFY (c2 NUMBER(1));
  -- ORA-01440: 정도 또는 자리수를 축소할 열은 비어 있어야 합니다
  -- NUMBER 타입은 열에 값이 존재하는 경우, 데이터 타입의 길이를 축소할 수 없다
  ALTER TABLE t1 MODIFY (c3 VARCHAR2(1));
  -- 정상처리
  -- VARCHAR2 타입은 열에 값이 존재하는 하더라도 값의 실제크기까지 데이터 타입의 길이를 축소할 수 있다
  ALTER TABLE t1 MODIFY (c2 NUMBER(3), c3 VARCHAR2(3));
  -- 정상처리
  -- 데이터 타입의 길이 늘이는 것은 값의 유무 및 크기와 상관없이 가능
  ALTER TABLE t1 MODIFY (c4 TIMESTAMP);
  -- 정상처리
  -- DATE와 TIMESTAMP 간의 상호변경 가능
  -- 다만, TIMESTAMP -> DATE의 경우, 소수점 이하 초가 유실된다
  ```
  ```sql
  SELECT column_name, data_type, data_length, data_precision, data_scale
    FROM user_tab_columns
   WHERE table_name = 'T1';
  ```
  * RENAME절
  ```sql
  ALTER TABLE [schema.]table RENAME COLUMN old_name TO new_name;
  ```
  ```sql
  ALTER TABLE t1 RENAME COLUMN c4 TO c5;
  ```
  * DROP절
  ```sql
  ALTER TABLE [schema.]table DROP (column [, column]...) 
               [CASCADE CONSTRAINTS] [CHECKPOINT integer];
  ```
  ```sql
  ALTER TABLE t1 DROP (c3, c5);
  ```
  * SET UNUSED절
  ```sql
  ALTER TABLE [schema.]table SET UNUSED (column [, column]...) 
               [CASCADE CONSTRAINTS] [ONLINE];
  ```
  ```sql
  ALTER TABLE t1 SET UNUSED (c2);
  ```
  ```sql
  SELECT * FROM user_unused_col_tabs;

  SELECT column_name, hidden_column FROM user_tab_cols WHERE table_name = 'T1';
  ```
  * DROP절 (UNUSED COLUMNS)
    * UNUSED COLUMNS: 테이블의 미사용 열 모두 삭제
    * COLUMNS CONTINUE: 중단된 지점에서부터 미사용 열의 삭제 작업을 다시 진행
    * CHECKPOINT integer: 체크포인트를 수행할 행의 개수를 지정 (기본값 512)
  ```sql
  ALTER TABLE [schema.]table DROP {UNUSED COLUMNS | COLUMNS CONTINUE}
               [CHECKPOINT integer];
  ```
  ```sql
  ALTER TABLE t1 DROP UNUSED COLUMNS;
  ```
  * DDL 작업
    * TM락 X모드
    * 이슈) 일반 열 삭제
      * 장시간 소요되면 테이블 사용이 제한되면서 장애 발생 가능
    * 차선책) SET UNUSED 변경 후 운영 외 시간에 미사용 열 DROP 하기
    * 일정 규모 이상의 시스템은 정기 PM(Prevention Maintenance) 시점에 DDL 작업 수행
* 데이터 타입
  * 타입 목록
    * 문자: CHAR, VARCHAR2, CLOB, LONG, NCHR, NVARCHAR2, NCLOB
    * 숫자: NUMBER, BINARY_FLOAT, BINARY_DOUBLE
    * 날짜: DATE, TIMESTAMP, INTERVAL
    * 이진: BLOB, BFILE, LONG RAW, RAW
    * 기타: ROWID, UROWID
  * VARCHAR2
    * 가변 길이 문자 데이터 타입 (1 ~ 4000)
      * BYTE: 바이트 크기
      * CHAR: 문자의 길이
    ```sql
    VARCHAR2(size [BYTE|CHAR])
    ```
    ```sql
    SELECT parameter, value
    FROM   v$nls_parameters
    WHERE  parameter IN ('NLS_CHARACTERSET', 'NLS_LENGTH_SEMANTICS');
    ```
    ```sql
    DROP TABLE t1 PURGE;
    CREATE TABLE t1 (c1 VARCHAR2(1), c2 VARCHAR2(1 CHR), c3 VARCHAR2(1 BYTE);

    INSERT INTO t1(c1) VALUES('가');
    -- ORA-12899: ... "C1" 열에 대한 값이 너무 큼 (실제: 2, 최대값: 1)
    INSERT INTO t1(c2) VALUES('가');
    -- 정상처리
    ```
    ```sql
    SELECT column_name, data_type, data_length
      FROM user_tab_columns
      WHERE table_name = 'T1';
    -- c1 1
    -- c2 2
    -- c3 1
    ```
* NUMBER
  * 가변 길이 숫자 데이터 타입 (1 ~ 22 바이트)
    * p: 정밀도(precision) (범위: 1 ~ 38)
    * s: 스케일(scale) (범위: -84 ~ 127, 기본값: 0)
  ```sql
  NUMBER[(p[,s])];
  ```
    * NUMBER: 부동 소수점
    * NUMBER(2): 정수(-99 ~ 99)
      * 정수부: 2
      * 소수부: 0
    * NUMBER(2,1): 고정 소수점 수(-9.9 ~ 9.9)
      * 정수부: 1
      * 소수부: 1
    * NUMBER(2,2): 고정 소수점 수(-0.99 ~ 0.99)
      * 정수부: 0
      * 소수부: 2
    * NUMBER(1,1): 고정 소수점 수(-0.9 ~ 0.9)
      * 정수부: 0
      * 소수부: 1
    * NUMBER(1,2): 고정 소수점 수(-0.09 ~ 0.09)
      * 정수부: -1
      * 소수부: 2
    * NUMBER(2,-1): 정수(-90 ~ 90)
      * 정수부: 3
      * 소수부: -1
    * NUMBER(2,-2): 정수(-9900 ~ 9900)
      * 정수부: 4
      * 소수부: -2
    * NUMBER(1,-1): 정수(-90 ~ 90)
      * 정수부: 2
      * 소수부: -1
    * NUMBER(1,-2): 정수(-900 ~ 900)
      * 정수부: 3
      * 소수부: -2
  ```sql
  DROP TABLE t1 PURGE;
  CREATE TABLE t1 (c1 NUMBER, c2 NUMBER(3,2));

  SELECT column_name, data_type, data_precision, data_scale
    FROM user_tab_columns
   WHERE table_name = 'T1';
  ```
  ```sql
  INSERT INTO t1 (c2) VALUES(9.995);
  -- ORA-01438: 이 열에 대해 지정된 전체 자릿수보다 큰 값이 허용됩니다.
  ```
  ```sql
  INSERT INTO t1 VALUES(4/3, 4/3);
  COMMIT;

  SELECT * FROM t1;
  -- c1: 1.3333333333333333333
  -- c2: 1.33
  ```
  ```sql
  SELECT VSIZE(c1) AS c1, VSIZE(c2) AS c2 FROM t1;
  -- c1: 21 (바이트)
  -- c2: 3 (3)
  ```
* DATE 타입
  * 고정 길이 날짜 데이터 타입 (B.C 4712년 1월 1일 ~ A.D 9999년 12월 31일)
  * 저장 공간 7바이트 사용
```sql
  DROP TABLE t1 PURGE;
  CREATE TABLE t1 (c1 DATE);

  SELECT column_name, data_type, data_length
    FROM user_tab_columns
   WHERE table_name = 'T1';
  --- C1 DATE 7
```
* TIMESTAMP
  * 가변 길이 날짜 데이터 타입 (소수점 이하 초 단위의 날짜 값 저장 가능)
  * fractional_seconds_precision: 0~9, default(6)
  * 정밀도에 따라 7 ~ 11 바이트 저장 공간 사용
```sql
TIMESTAMP[(fractional_seconds_precision)]
```
```sql
DROP TABLE t1 PURGE;
CREATE TABLE t1 (c1 TIMESTAMP);

SELECT column_name, data_type, data_length, data_scale
  FROM user_tab_columns
 WHERE table_name = 'T1';
--- C1 TIMESTAMP(6) 11 6
```
* INTERVAL 타입
  * 날짜 값의 기간 저장
  * INTERVAL YEAR TO MONTH: 연, 월 단위의 기간 저장
    * year_precision: 0 ~ 9 default(2)
    * 저장 공간 5바이트 사용
  * INTERVAL DAY TO SECOND: 일, 시, 분, 초 단위의 기간 저장
    * day_precision: 0 ~ 9 default(2)
    * fractional_seconds_precision: 0 ~ 9 default(6)
    * 저장 공간 11바이트 사용
```sql
INTERVAL YEAR[(year_precision)] TO MONTH;

INTERVAL DAY[(day_precision)] TO SECOND[(fractional_seconds_precision)]
```
```sql
DROP TABLE t1 PURGE;
CREATE TABLE t1 (c1 INTERVAL YEAR TO MONTH, c2 INTERVAL DAY TO SECONDS);

INSERT INTO t1 VALUES (INTERVAL '1-11' YEAR TO MONTH
                      ,INTERVAL '1 12:34:56.789' DAY TO SECOND);
COMMIT;
```
```sql
SELECT column_name, data_type, data_length, data_precision, data_scale
  FROM user_tab_columns
 WHERE table_name = 'T1';
--- C1 INTERVAL YEAR(2) TO MONTH 5 2 0
--- C2 INTERVAL DAY(2) TO SECONDS(6) 11 2 6
```
```sql
-- 날짜 값 연산을 위한 기간 값을 저장하기 위해 사용된다
SELECT c1, c2
     , TIMESTAMP '2025-01-01 00:00:00' + c1 AS c3
     , TIMESTAMP '2025-01-01 00:00:00' + c2 AS c4
FROM t1;
-- c1: +01-11
-- c2: +01 12:34:56.789000 
-- c3: 2051-12-01 00:00:00.000000000
-- c4: 2050-01-02 12:34:56.789000000
```
* CLOB 타입 (Character Large OBject)
  * 가변 길이 문자 타입
  * 최대 (4GB - 1B) * block size 크기의 문자열 저장 가능
```sql
CLOB
```
```sql
DROP TABLE t1 PURGE;
CREATE TABLE t1 (c1 CLOB);

INSERT INTO t1 VALUES (TO_CLOB(LPAD('A', 4000, 'A')) || LPAD('B', 4000, 'B'));
COMMIT;
```
```sql
-- LOB 타입은 별도의 segment와 index가 생성된다
SELECT column_name, segment_name, index_name
  FROM user_lobs
 WHERE table_name = 'T1';

SELECT segment_name, segment_type
  FROM user_segments
 WHERE table_name = 'T1';
```

<br>
<hr>
<br>

## DCL 문
#### 

<br>

### 

<br>
<hr>
<br>

## SCS 문
#### 

<br>

### 

<br>
<hr>
<br>
