## 관리구문
> 
* 

<hr>
<br>

## DML 문 (Data Manipulation Language)
#### INSERT/UPDATE/DELETE/MERGE

<br>

### INSERT 문
* 단일 테이블 INSERT 문
  * VALUES 절: 단일 행 삽입
  ```sql
  INSERT INTO {table | view | subquery} [t_alias] [(column [, column]...)]
       VALUES ({expr | DEFAULT} [, {expr | DEFAULT}]...)
  ```
  ```sql
  CREATE TABLE t1 (empno NUMBER(4), ename VARCHAR2(10), deptno NUMBER(2) DEFAULT 20);
  
  -- INTO/VALUES절에 지정되지 않은 열: 기본값이 었으면 기본값; 없으면, NULL 삽입
  INSERT INTO t1 (empno, ename, deptno) VALUES (7369, 'SMITH' , 20);
  
  -- INTO절에 열을 지정하지 않으면, VALUES절에 전체 열의 값 기술 필요
  INSERT INTO t1 VALUES (7788, 'SCOTT' , 20);
  
  -- DEFAULT 값이 설정되어 있는 열에는 DEFAULT 키워드 사용 가능
  INSERT INTO t1 VALUES (7876, 'ADAMS' , DEFAULT);
  
  -- 열을 추가하면 상단에서 INTO절에 열을 지정하지 않아서 VALUES절에 전체 열을 기술해야 했던 모든 쿼리에서 에러가 발생한다
  -- 따라서, 하단의 쿼리처럼 INTO절에 열을 지정하는 방식이 쿼리의 안정성 측면에서 바람직하다
  ALTER TABLE t1 ADD job VARCHAR2(9);
  INSERT INTO t1 (empno, ename, deptno) VALUES (7902, 'FORD' , 20);
  ```
  * 서브 쿼리: 서브 쿼리의 결과 삽입
  ```sql
  INSERT INTO {table | view | subquery} [t_alias] [(column [, column]...)]
  subquery
  ```
  ```sql
  -- 서브쿼리 결과가 다중행이면 다중행이 INSERT된다
  INSERT INTO t1 (empno, ename)
  SELECT empno, ename FROM emp WHERE job = 'ANALYST';

  -- 서브쿼리에 UNION ALL 연산자를 사용하면 여러 태이블의 행 삽입 가능
  INSERT INTO t1 (empno, ename)
  SELECT empno, ename  FROM emp  WHERE job = 'PRESIDENT'
  UNION ALL
  SELECT deptno, dname FROM dept WHERE deptno = 10;
  ```
* 다중 테이블 INSERT 문
  * 무조건 INSERT 문: 모든 테이블에 서브 쿼리 결과 삽입
  ```sql
  INSERT ALL {INTO table [(column [, column]...] [VALUES ({expr | DEFAULT} [, {expr | DEFAULT}]...)]}...
  subquery
  ```
  ```sql
  CREATE TABLE t1 (empno NUMBER(4), job VARCHAR2(9));
  CREATE TABLE t2 (empno NUMBER(4), mgr NUMBER(4)  );

  -- t1, t2 테이블 각각에 행3개씩 INSERT
  INSERT ALL
         INTO   t1 (empno, job) VALUES (empno, job)
         INTO   t2 (empno, mgr) VALUES (empno, mgr)
  SELECT * FROM emp WHERE deptno = 10;

  -- PIVOT INSERT문: 서브 쿼리의 1행이 t1 테이블에 4번 삽입된다
  CREATE TABLE t1 (deptno NUMBER(2), tp VARCHAR2(3), sal NUMBER(7,2));
  
  INSERT ALL
         INTO t1 VALUES (deptno, 'MIN', sal_min)
         INTO t1 VALUES (deptno, 'MAX', sal_max)
         INTO t1 VALUES (deptno, 'SUM', sal_sum)
         INTO t1 VALUES (deptno, 'AVG', sal_avg)
  SELECT deptno
       , MIN (sal) AS sal_min
       , MAX (sal) AS sal_max
       , SUM (sal) AS sal_sum
       , AVG (sal) AS sal_avg
  FROM  emp
  GROUP BY deptno;
  ```
* 조건부 INSERT 문: 조건을 만족하는 테이블에 서브 쿼리 결과 삽입
  * ALL: 조건을 만족하는 모든 테이블에 행 삽입
  * FIRST: 조건을 만족하는 첫 번째 테이블에 행 삽입
  ```sql
  INSERT [ALL | FIRST]
    WHEN condition THEN
    INTO table [(column [, column]...)] [VALUES ({expr | DEFAULT} [, {expr | DEFAULT}]...)]
   [WHEN condition THEN
    INTO table [(column [, column]...)] [VALUES ({expr | DEFAULT} [, {expr | DEFAULT}]...)]
   [ELSE
    INTO table [(column [, column]...)] [VALUES ({expr | DEFAULT} [, {expr | DEFAULT}]...)]
  subquery
  ```
  ```sql
  CREATE TABLE t1 AS SELECT empno, ename, sal FROM emp WHERE 0 = 1;
  CREATE TABLE t2 AS SELECT * FROM t1;
  CREATE TABLE t3 AS SELECT * FROM t1;

  -- 조건을 만족하는 모든 테이블에 삽입
  INSERT ALL
        WHEN sal >= 2000 THEN INTO t1
        WHEN sal >= 3000 THEN INTO t2
        ELSE INTO t3
  SELECT empno, ename , sal FROM emp WHERE deptno = 10;

  -- 조건을 만족하는 첫번째 테이블에 삽입
  INSERT FIRST
          WHEN sal >= 2000 THEN INTO t1
          WHEN sal >= 3000 THEN INTO t2
          ELSE INTO t3
  SELECT empno, ename , sal FROM emp WHERE deptno = 10;
  ```

<br>

### UPDATE 문 
* 기본 문법
  * UPDATE > WHERE > SET (행별)
  ```sql
  UPDATE {table | view | subquery} [t_alias]
     SET {column = {expr | (subquery) | DEFAULT} | (column [, column]...) = (subquery)}
      [, {column = {expr | (subquery) | DEFAULT} | (column [, column]...) = (subquery)}]...
  WHERE condition;
  ```
* t1(dept, 갱신할 테이블):t2(emp, 나머지 테이블)=1:M 비식별 관계
  ```sql
  CREATE TABLE t1 AS SELECT deptno, dname, 0 AS sal, 0 AS comm FROM dept;
  CREATE TABLE t2 AS SELECT empno, ename, sal, comm, deptno    FROM emp;

  ALTER TABLE t1 ADD CONSTRAINT t1_pk PRIMARY KEY (deptno);
  ALTER TABLE t2 ADD CONSTRAINT t2_pk PRIMARY KEY (empno);
  ALTER TABLE t2 ADD CONSTRAINT t2_f1 FOREIGN KEY (deptno) REFERENCES t1 (deptno);
  
  UPDATE t1 SET sal = 10000, comm = 1000 WHERE deptno = 40;
  ```
* 다중 열 서브 쿼리: 서브 쿼리의 결과로 갱신
  * UPDATE 기준은 t1의 행 별로 t2와 조인을 해서 얻은 값으로 갱신한다
  * 만약 조인의 결과가 없다면, SUM 집계함수 결과가 NULL이 되기 때문에, (a.sal, a.comm) = (NULL, NULL)로 갱신된다
  ```sql
  UPDATE t1 a
     SET (a.sal, a.comm) =
         (SELECT SUM (x.sal), SUM (x.comm) FROM t2 x WHERE x.deptno = a.deptno);
  ```
  * 조인의 결과가 없어서 NULL값 갱신을 피하기 위해서 EXISTS절을 추가한다
  ```sql
  UPDATE t1 a
  SET    (a.sal, a.comm) =
         (SELECT SUM (x.sal), SUM (x.comm) FROM t2 X WHERE x.deptno = a.deptno)
  WHERE  EXISTS (SELECT 1 FROM t2 X WHERE x.deptno = a.deptno);
  ```
* 인라인뷰 사용 가능
  * GOOD! 갱신할 테이블:나머지 테이블=1:1(차수) - 단일 행이 단일 값으로 갱신되는 것이 보장되어야 한다
    * GROUP BY deptno를 통해서 차수를 1:1로 맞춰줌
  ```sql
  -- 인라인 뷰를 통해 t2 테이블은 1번만 읽게 설계 가능
  UPDATE( SELECT a.sal, a.comm, b.sal AS sal_n, b.comm AS comm_n
            FROM t1 a
               , (SELECT deptno, SUM(sal) AS sal, SUM(comm) AS comm
                    FROM t2
                   GROUP BY deptno) b
            WHERE b.deptno = a.deptno )
  SET sal = sal_n, comm = comm_n;
  ```
    * MERGE문으로 대체 가능
  ```sql
  MERGE
   INTO t1 t
  USING (SELECT deptno, SUM(sal) AS sal, SUM(comm) AS comm
           FROM t2
       GROUP BY deptno) s
     ON (t.deptno = s.deptno)
  WHEN MATCHED THEN
        UPDATE SET t.sal = s.sal, t.comm = s.comm;
  ```
  * BAD! 갱신할 테이블:나머지 테이블=1:M(차수) - ORA-01779(키-보존된 것이 아닌 테이블로 대응한 열을 수정할 수 없습니다) 발생
    * 1쪽 테이블(t1)의 값이 M쪽 테이블(t2)의 값으로 여러 번 갱신될 수 있기 때문
    ```sql
    UPDATE (SELECT a.sal, a.comm, b.sal AS sal_n, b.comm AS comm_n
              FROM t1 a, t2 b
             WHERE b.deptno = a.deptno)
       SET sal = sal_n, c. mm = comm_n;
    ```
  * GOOD! 갱신할 테이블:나머지 테이블=M:1(차수) - 단일 행이 단일 값으로 갱신되는 것이 보장되어야 한다
    * M쪽 테이블(t2)의 값이 1쪽 테이블(t1)의 값으로 1번만 갱신되는 것이 보장된다
    ```sql
    UPDATE (SELECT a.sal, a.comm, b.sal AS sal_n, b.comm AS comm_n
              FROM t2 a, t1 b
             WHERE b.deptno = a.deptno)
       SET sal = sal_n, c. mm = comm_n;
    ```

<br>

### DELETE 문
* 기본 문법
  * FROM > WHERE > DELETE
  ```sql
  DELETE
    FROM { table | view | subquery} [t_alias]
   WHERE condition;
  ```
* 예시
  ```sql
  DELETE FROM t1 WHERE deptno = 10;
  ```
  ```sql
  DELETE
    FROM t1 a
   WHERE NOT EXISTS (SELECT 1 FROM emp x WHERE x.deptno = a.deptno);
  ```
  ```sql
  DELETE FROM t1;
  ```
* 실수 방지
  * 먼저 SELECT문을 작성하고, SELECT문을 UPDATE문이나 DELETE문으로 변경하는 방식을 사용해야 실수 방지 가능
  * UPDATE
  ```sql
  SELECT a.*
       , (SELECT SUM( x.comm )
            FROM emp x
           WHERE x.deptno = a.deptno
    FROM t1 a
   WHERE EXISTS
         (SELECT 1
            FROM emp x
           WHERE x.deptno = a.deptno);
  ```
  ```sql
  UPDATE t1 a
     SET a.sal = (SELECT SUM( x.comm )
                    FROM emp x
                   WHERE x.deptno = a.deptno)
   WHERE EXISTS
         (SELECT 1
            FROM emp x
           WHERE x.deptno = a.deptno);
  ```
  * DELETE
  ```sql
  SELECT a.*
    FROM t1 a
   WHERE NOT EXISTS (SELECT 1
                       FROM emp x
                      WHERE x.deptno = a.deptno);
  ```
  ```sql
  DELETE
    FROM t1 a
   WHERE NOT EXISTS (SELECT 1
                       FROM emp x
                      WHERE x.deptno = a.deptno);
  ```

<br>

### MERGE 문
* 기본 문법
  * INTO절: 갱신 또는 삽입할 타켓 테이블
  * USING절: 갱신 또는 상비에 사용할 소스 테이블
  * ON절: 갱신 또는 삽입을 결정하는 조건
  * MERGE UPDATE절: ON 절의 조건이 만족하는 경우 수행될 구문
  * MERGE INSERT절: ON 절의 조건이 만족하지 않는 경우 수행될 구문
  ```sql
  MERGE 
   INTO { table | view | (subquery) } [t_alias]
  USING { table | view | (subquery) } [t_alias]
     ON ( condition )
   WHEN MATCHED THEN
         UPDATE 
            SET column = { expr | DEFAULT } [, column = { expr | DEFAULT }
         [WHERE condition{
        [DELETE 
          WHERE condition]
   WHEN NOT MATCHED THEN 
         INSERT [(column [, column]...)]
          VALUES ({ expr | DEFAULT } [, { expr | DEFAULT }]...)
          [WHERE condition];
  ```
* 예시
  ```sql
  MERGE
   INTO t1 t
  USING t2 s
     ON (t.empno = s.empno)
   WHEN MATCHED THEN
        UPDATE
           SET t.sal = s.sal - 500
   WHEN NOT MATCHED THEN
        INSERT (t.empno, t.ename, t.job)
        VALUES (s.empno, s.ename, s.job);
  ```
* 선택 작업
  * MERGE UPDATE절
  ```sql
  MERGE
   INTO t1 t
  USING t2 s
     ON (t.empno = s.empno)
   WHEN MATCHED THEN
        UPDATE
           SET t.sal = s.sal - 500;
  ```
  ```sql
  -- 동일 결과 UPDATE문
  UPDATE (SELECT a.sal , b.sal AS sal_n FROM t1 a, t2 b WHERE b.empno = a.empno)
  SET sal = sal n - 500;
  ```
  * MERGE INSERT절
  ```sql
  MERGE
   INTO t1 t
  USING t2 s
     ON (t.empno = s.empno)
   WHEN NOT MATCHED THEN
        INSERT (t.empno, t.ename, t.job)
        VALUES (s.empno, s.ename, s.job);
  ```
  ```sql
  -- 동일 결과 INSERT문
  INSERT INTO t1(empno, ename, job, sal)
      AS SELECT empno, ename, job
           FROM t2 s
          WHERE NOT EXISTS (SELECT 1
                              FROM t1 t
                             WHERE t.empno = s.empno;
  ```
* WHERE 절
  * MERGE UPDATE: 타깃 테이블(t1)의 일반 조건
  ```sql
  MERGE
   INTO t1 t
  USING t2 s
     ON (t.empno = s.empno)
   WHEN MATCHED THEN
         UPDATE
            SET t.sal = s.sal - 500
          WHERE t.job = 'CLERK';
  ```
  ```sql
  -- 동일 결과 인라인뷰 방식
  MERGE
   INTO (SELECT * FROM t1 WHERE job = 'CLERK') t
  USING t2 s
     ON (t.empno = s.empno)
   WHEN MATCHED THEN
         UPDATE
            SET t.sal = s.sal - 500;
  ```
  * MERGE UPDATE: 소스 테이블(t2)의 일반 조건
  ```sql
  MERGE
   INTO t1 t
  USING t2 s
     ON (t.empno = s.empno)
   WHEN MATCHED THEN
         UPDATE
            SET t.sal = s.sal - 500
          WHERE s.job = 'CLERK';
  ```
  ```sql
  -- 동일 결과 인라인뷰 방식
  MERGE
   INTO t1 t
  USING (SELECT * FROM t2 WHERE job = 'CLERK') s
     ON (t.empno = s.empno)
   WHEN MATCHED THEN
         UPDATE
            SET t.sal = s.sal - 500;
  ```
  * MERGE UPDATE: 타깃 테이블(t1)의 일반 조건 && 소스 테이블(t2)의 일반 조건
  ```sql
  MERGE
   INTO t1 t
  USING t2 s
     ON (t.empno = s.empno)
   WHEN MATCHED THEN
         UPDATE
            SET t.sal = s.sal - 500
          WHERE (   ( t.job = 'CLERK' AND s.sal >= 1000 )
                  OR( t.job <> 'CLERK') );
  ```
  * MERGE INSERT: 타겟 테이블(t1)의 일반 조건 `불가능!`
  ```sql
  -- ORA-38102: INSERT WHERE 절에 부적합한 열이 있음 "T"."JOB"
  MERGE
   INTO t1 t
  USING t2 s
     ON (t.empno = s.empno)
   WHEN NOT MATCHED THEN
        INSERT (t.empno, t.ename, t.job)
        VALUES (s.empno, s.ename, s.job)
        WHERE  t.job = 'CLERK';
  ```
  ```sql
  -- ORA-00001: 무결성 제약 조건 (SCOTT.T1_PK)에 위배됩니다
  -- INSERT 대상은 인라인뷰가 아닌 테이블이기 때문에 이미 JONES가 있는데 JONES가 INSERT되서 PK Violation이 발생했다
  MERGE
   INTO (SELECT * FROM t1 WHERE job = 'CLERK') t
  USING t2 s
     ON (t.empno = s.empno)
   WHEN NOT MATCHED THEN
        INSERT (t.empno, t.ename, t.job)
        VALUES (s.empno, s.ename, s.job)
  ```
  * MERGE INSERT: 소스 테이블(t2)의 일반 조건
  ```sql
  MERGE
   INTO t1 t
  USING t2 s
     ON (t.empno = s.empno)
   WHEN NOT MATCHED THEN
        INSERT (t.empno, t.ename, t.job)
        VALUES (s.empno, s.ename, s.job)
        WHERE  s.job = 'CLERK';
  ```
  ```sql
  -- 동일 결과 인라인뷰 방식
  MERGE
   INTO t1 t
  USING (SELECT empno, ename, job FROM t2 WHERE job = 'CLERK') s
     ON (t.empno = s.empno)
   WHEN NOT MATCHED THEN
        INSERT (t.empno, t.ename, t.job)
        VALUES (s.empno, s.ename, s.job)
  ```
* DELETE절
  * DELETE절은 MERGE UPDATE 절로 갱신된 행을 대상으로 수행되며, 갱신된 값을 기준으로 행을 삭제한다
  ```sql
  -- 갱신된 sal가 300인 SMITH가 삭제된다
  MERGE
   INTO t1 t
  USING (SELECT * FROM t2 WHERE job = 'CLERK') s
     ON (t.empno = s.empno)
   WHEN MATCHED THEN
         UPDATE
            SET t.sal = s.sal - 500;
          WHERE t.job = 'CLERK'
         DELETE
           WHERE t.sal < 1000;
  ```
* MERGE UPDATE/DELETE/INSERT
  ```sql
  MERGE
   INTO t1 t
  USING (SELECT * FROM t2 WHERE job = 'CLERK') s
     ON (t.empno = s.empno)
   WHEN MATCHED THEN
         UPDATE
            SET t.sal = s.sal - 500;
          WHERE t.job = 'CLERK'
         DELETE
           WHERE t.sal < 1000;
   WHEN NOT MATCHED THEN
        INSERT (t.empno, t.ename, t.job)
        VALUES (s.empno, s.ename, s.job)
         WHERE s.job = 'CLERK';
  ```

<br>

### 고급 주제
* 조인 차수
  * MERGE 문도 UPDATE 문처럼 조인 치수에 따라 에러가 발생할 수 있다
    * t1(타겟 테이블):t4(소스 테이블)=1:M
      * t1 행이 t4 행들로 여러번 갱신될 수 있기 때문
  ```sql
  -- ORA-30926: 원본 테이블의 고정 행 집함을 가져올 수 없습니다
  -- t:s=차수 1:M
  MERGE
   INTO t1 t
  USING t4 s
     ON (t.empno = s.empno)
   WHEN MATCHED THEN
         UPDATE
            SET t.sal = s.sal - 500;
  ```
  ```sql
  -- 정상처리
  -- 차수 1:1을 맞춰줬기 때문
  MERGE
   INTO t1 t
  USING (SELECT * 
           FROM SELECT a.* 
                     , ROW_NUMBER() OVER (PARTITION BY a.empno
                                                ORDER BY a.yyyy DESC) AS rn
                   FROM t4) a
          WHERE rn = 1) s
     ON (t.empno = s.empno)
   WHEN MATCHED THEN
         UPDATE
            SET t.sal = s.sal - 500;
  ```
* 조인 조건
  * ON절에 기술된 열은 갱신할 수 없다 (무한 루프 발생 가능)
  ```sql
  --ORA-38104: ON 절에서 참조되는 열은 업데이트할 수 없음: "T"."EMPNO"
  MERGE
   INTO t1 t
  USING (SELECT empno, empno + ROW_NUMBER() OVER (PARTITION BY empno) AS empno_n
           FROM t1) s
     ON (t.empno = s.empno)
   WHEN MATCHED THEN
         UPDATE
            SET t.empno = s.empno_n;
  ```
* 일반 조건
* 아우터 조인

<br>

### DML 에러 로깅
 
<br>
<hr>
<br>

## TCS 문
#### 

<br>

### 

<br>
<hr>
<br>

## DDL 문
#### 

<br>

### 

<br>
<hr>
<br>

## DML문
#### 

<br>

### 

<br>
<hr>
<br>

## DCL 문
#### 

<br>

### 

<br>
<hr>
<br>

## SCS 문
#### 

<br>

### 

<br>
<hr>
<br>
