## 관리구문
> 
* 

<hr>
<br>

## DML 문 (Data Manipulation Language)
#### INSERT/UPDATE/DELETE/MERGE

<br>

### INSERT 문
* 단일 테이블 INSERT 문
  * VALUES 절: 단일 행 삽입
  ```sql
  INSERT INTO {table | view | subquery} [t_alias] [(column [, column]...)]
       VALUES ({expr | DEFAULT} [, {expr | DEFAULT}]...)
  ```
  ```sql
  CREATE TABLE t1 (empno NUMBER(4), ename VARCHAR2(10), deptno NUMBER(2) DEFAULT 20);
  
  -- INTO/VALUES절에 지정되지 않은 열: 기본값이 었으면 기본값; 없으면, NULL 삽입
  INSERT INTO t1 (empno, ename, deptno) VALUES (7369, 'SMITH' , 20);
  
  -- INTO절에 열을 지정하지 않으면, VALUES절에 전체 열의 값 기술 필요
  INSERT INTO t1 VALUES (7788, 'SCOTT' , 20);
  
  -- DEFAULT 값이 설정되어 있는 열에는 DEFAULT 키워드 사용 가능
  INSERT INTO t1 VALUES (7876, 'ADAMS' , DEFAULT);
  
  -- 열을 추가하면 상단에서 INTO절에 열을 지정하지 않아서 VALUES절에 전체 열을 기술해야 했던 모든 쿼리에서 에러가 발생한다
  -- 따라서, 하단의 쿼리처럼 INTO절에 열을 지정하는 방식이 쿼리의 안정성 측면에서 바람직하다
  ALTER TABLE t1 ADD job VARCHAR2(9);
  INSERT INTO t1 (empno, ename, deptno) VALUES (7902, 'FORD' , 20);
  ```
  * 서브 쿼리: 서브 쿼리의 결과 삽입
  ```sql
  INSERT INTO {table | view | subquery} [t_alias] [(column [, column]...)]
  subquery
  ```
  ```sql
  -- 서브쿼리 결과가 다중행이면 다중행이 INSERT된다
  INSERT INTO t1 (empno, ename)
  SELECT empno, ename FROM emp WHERE job = 'ANALYST';

  -- 서브쿼리에 UNION ALL 연산자를 사용하면 여러 태이블의 행 삽입 가능
  INSERT INTO t1 (empno, ename)
  SELECT empno, ename  FROM emp  WHERE job = 'PRESIDENT'
  UNION ALL
  SELECT deptno, dname FROM dept WHERE deptno = 10;
  ```
* 다중 테이블 INSERT 문
  * 무조건 INSERT 문: 모든 테이블에 서브 쿼리 결과 삽입
  ```sql
  INSERT ALL {INTO table [(column [, column]...] [VALUES ({expr | DEFAULT} [, {expr | DEFAULT}]...)]}...
  subquery
  ```
  ```sql
  CREATE TABLE t1 (empno NUMBER(4), job VARCHAR2(9));
  CREATE TABLE t2 (empno NUMBER(4), mgr NUMBER(4)  );

  -- t1, t2 테이블 각각에 행3개씩 INSERT
  INSERT ALL
         INTO   t1 (empno, job) VALUES (empno, job)
         INTO   t2 (empno, mgr) VALUES (empno, mgr)
  SELECT * FROM emp WHERE deptno = 10;

  -- PIVOT INSERT문: 서브 쿼리의 1행이 t1 테이블에 4번 삽입된다
  CREATE TABLE t1 (deptno NUMBER(2), tp VARCHAR2(3), sal NUMBER(7,2));
  
  INSERT ALL
         INTO t1 VALUES (deptno, 'MIN', sal_min)
         INTO t1 VALUES (deptno, 'MAX', sal_max)
         INTO t1 VALUES (deptno, 'SUM', sal_sum)
         INTO t1 VALUES (deptno, 'AVG', sal_avg)
  SELECT deptno
       , MIN (sal) AS sal_min
       , MAX (sal) AS sal_max
       , SUM (sal) AS sal_sum
       , AVG (sal) AS sal_avg
  FROM  emp
  GROUP BY deptno;
  ```
* 조건부 INSERT 문: 조건을 만족하는 테이블에 서브 쿼리 결과 삽입
  * ALL: 조건을 만족하는 모든 테이블에 행 삽입
  * FIRST: 조건을 만족하는 첫 번째 테이블에 행 삽입
  ```sql
  INSERT [ALL | FIRST]
    WHEN condition THEN
    INTO table [(column [, column]...)] [VALUES ({expr | DEFAULT} [, {expr | DEFAULT}]...)]
   [WHEN condition THEN
    INTO table [(column [, column]...)] [VALUES ({expr | DEFAULT} [, {expr | DEFAULT}]...)]
   [ELSE
    INTO table [(column [, column]...)] [VALUES ({expr | DEFAULT} [, {expr | DEFAULT}]...)]
  subquery
  ```
  ```sql
  CREATE TABLE t1 AS SELECT empno, ename, sal FROM emp WHERE 0 = 1;
  CREATE TABLE t2 AS SELECT * FROM t1;
  CREATE TABLE t3 AS SELECT * FROM t1;

  -- 조건을 만족하는 모든 테이블에 삽입
  INSERT ALL
        WHEN sal >= 2000 THEN INTO t1
        WHEN sal >= 3000 THEN INTO t2
        ELSE INTO t3
  SELECT empno, ename , sal FROM emp WHERE deptno = 10;

  -- 조건을 만족하는 첫번째 테이블에 삽입
  INSERT FIRST
          WHEN sal >= 2000 THEN INTO t1
          WHEN sal >= 3000 THEN INTO t2
          ELSE INTO t3
  SELECT empno, ename , sal FROM emp WHERE deptno = 10;
  ```

<br>

### UPDATE 문 
* 기본 문법
  * UPDATE > WHERE > SET (행별)
  ```sql
  UPDATE {table | view | subquery} [t_alias]
     SET {column = {expr | (subquery) | DEFAULT} | (column [, column]...) = (subquery)}
      [, {column = {expr | (subquery) | DEFAULT} | (column [, column]...) = (subquery)}]...
  WHERE condition;
  ```
* t1(dept, 갱신할 테이블):t2(emp, 나머지 테이블)=1:M 비식별 관계
  ```sql
  CREATE TABLE t1 AS SELECT deptno, dname, 0 AS sal, 0 AS comm FROM dept;
  CREATE TABLE t2 AS SELECT empno, ename, sal, comm, deptno    FROM emp;

  ALTER TABLE t1 ADD CONSTRAINT t1_pk PRIMARY KEY (deptno);
  ALTER TABLE t2 ADD CONSTRAINT t2_pk PRIMARY KEY (empno);
  ALTER TABLE t2 ADD CONSTRAINT t2_f1 FOREIGN KEY (deptno) REFERENCES t1 (deptno);
  
  UPDATE t1 SET sal = 10000, comm = 1000 WHERE deptno = 40;
  ```
* 다중 열 서브 쿼리: 서브 쿼리의 결과로 갱신
  * UPDATE 기준은 t1의 행 별로 t2와 조인을 해서 얻은 값으로 갱신한다
  * 만약 조인의 결과가 없다면, SUM 집계함수 결과가 NULL이 되기 때문에, (a.sal, a.comm) = (NULL, NULL)로 갱신된다
  ```sql
  UPDATE t1 a
     SET (a.sal, a.comm) =
         (SELECT SUM (x.sal), SUM (x.comm) FROM t2 x WHERE x.deptno = a.deptno);
  ```
  * 조인의 결과가 없어서 NULL값 갱신을 피하기 위해서 EXISTS절을 추가한다
  ```sql
  UPDATE t1 a
  SET    (a.sal, a.comm) =
         (SELECT SUM (x.sal), SUM (x.comm) FROM t2 X WHERE x.deptno = a.deptno)
  WHERE  EXISTS (SELECT 1 FROM t2 X WHERE x.deptno = a.deptno);
  ```
* 인라인뷰 사용 가능
  * GOOD! 갱신할 테이블:나머지 테이블=1:1(차수) - 단일 행이 단일 값으로 갱신되는 것이 보장되어야 한다
    * GROUP BY deptno를 통해서 차수를 1:1로 맞춰줌
  ```sql
  -- 인라인 뷰를 통해 t2 테이블은 1번만 읽게 설계 가능
  UPDATE( SELECT a.sal, a.comm, b.sal AS sal_n, b.comm AS comm_n
            FROM t1 a
               , (SELECT deptno, SUM(sal) AS sal, SUM(comm) AS comm
                    FROM t2
                   GROUP BY deptno) b
            WHERE b.deptno = a.deptno )
  SET sal = sal_n, comm = comm_n;
  ```
    * MERGE문으로 대체 가능
  ```sql
  MERGE
   INTO t1 t
  USING (SELECT deptno, SUM(sal) AS sal, SUM(comm) AS comm
           FROM t2
       GROUP BY deptno) s
     ON (t.deptno = s.deptno)
  WHEN MATCHED THEN
        UPDATE SET t.sal = s.sal, t.comm = s.comm;
  ```
  * BAD! 갱신할 테이블:나머지 테이블=1:M(차수) - ORA-01779(키-보존된 것이 아닌 테이블로 대응한 열을 수정할 수 없습니다) 발생
    * 1쪽 테이블(t1)의 값이 M쪽 테이블(t2)의 값으로 여러 번 갱신될 수 있기 때문
    ```sql
    UPDATE (SELECT a.sal, a.comm, b.sal AS sal_n, b.comm AS comm_n
              FROM t1 a, t2 b
             WHERE b.deptno = a.deptno)
       SET sal = sal_n, c. mm = comm_n;
    ```
  * GOOD! 갱신할 테이블:나머지 테이블=M:1(차수) - 단일 행이 단일 값으로 갱신되는 것이 보장되어야 한다
    * M쪽 테이블(t2)의 값이 1쪽 테이블(t1)의 값으로 1번만 갱신되는 것이 보장된다
    ```sql
    UPDATE (SELECT a.sal, a.comm, b.sal AS sal_n, b.comm AS comm_n
              FROM t2 a, t1 b
             WHERE b.deptno = a.deptno)
       SET sal = sal_n, c. mm = comm_n;
    ```

<br>

### DELETE 문
* 기본 문법
  * FROM > WHERE > DELETE
  ```sql
  DELETE
    FROM { table | view | subquery} [t_alias]
   WHERE condition;
  ```
* 예시
  ```sql
  DELETE FROM t1 WHERE deptno = 10;
  ```
  ```sql
  DELETE
    FROM t1 a
   WHERE NOT EXISTS (SELECT 1 FROM emp x WHERE x.deptno = a.deptno);
  ```
  ```sql
  DELETE FROM t1;
  ```
* 실수 방지
  * 먼저 SELECT문을 작성하고, SELECT문을 UPDATE문이나 DELETE문으로 변경하는 방식을 사용해야 실수 방지 가능
  * UPDATE
  ```sql
  SELECT a.*
       , (SELECT SUM( x.comm )
            FROM emp x
           WHERE x.deptno = a.deptno
    FROM t1 a
   WHERE EXISTS
         (SELECT 1
            FROM emp x
           WHERE x.deptno = a.deptno);
  ```
  ```sql
  UPDATE t1 a
     SET a.sal = (SELECT SUM( x.comm )
                    FROM emp x
                   WHERE x.deptno = a.deptno)
   WHERE EXISTS
         (SELECT 1
            FROM emp x
           WHERE x.deptno = a.deptno);
  ```
  * DELETE
  ```sql
  SELECT a.*
    FROM t1 a
   WHERE NOT EXISTS (SELECT 1
                       FROM emp x
                      WHERE x.deptno = a.deptno);
  ```
  ```sql
  DELETE
    FROM t1 a
   WHERE NOT EXISTS (SELECT 1
                       FROM emp x
                      WHERE x.deptno = a.deptno);
  ```

<br>

### MERGE 문
* 기본 문법
  ```sql
  MERGE 
   INTO { table | view | (subquery) } [t_alias]
  USING { table | view | (subquery) } [t_alias]
     ON ( condition )
   WHEN MATCHED THEN
   
  ```

<br>
<hr>
<br>

## TCS 문
#### 

<br>

### 

<br>
<hr>
<br>

## DDL 문
#### 

<br>

### 

<br>
<hr>
<br>

## DML문
#### 

<br>

### 

<br>
<hr>
<br>

## DCL 문
#### 

<br>

### 

<br>
<hr>
<br>

## SCS 문
#### 

<br>

### 

<br>
<hr>
<br>
