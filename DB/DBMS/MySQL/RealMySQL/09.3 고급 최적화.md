# 옵티마이저와 힌트
> 쿼리를 최적으로 실행하기 위해 각 테이블의 데이터가 어떤 분포로 저장돼 있는지 통계 정보를 참조하여, 그러한 기본 데이터를 비교해 최적의 실행 계획을 수립하는 작업 필요
* `Explain` 명령어로 쿼리의 실행 계획 확인 가능

<hr>
<br>

## 고급 최적화
#### MySQL 서버의 옵티마이저가 실행 계획을 수립할 때 `통계 정보`와 `옵티마이저 옵션`을 결합해서 최적의 실행 계획 수립
#### 옵티마이저 옵션 = {옵티마이저 옵션, 옵티마이저 스위치}

<br>

### 옵티마이저 스위치 옵션 (ON, OFF, DEFAULT 중 택 1)
> Driven Table 중에 하나를 `조인 버퍼`에 저장한다는 것이 주요 포인트

```mysql
SET GLOBAL optimizer_switch='';
SET SESSION optimizer_switch='';
SELECT /*+ SET_VAR(optimizer_switch='') */
```
* MRR 배치 키 액세스(mrr & batched_key_access) 
  * Driven Table에 엑세스할 때, 인덱스를 타지 못하면, 매번 테이블 풀 스캔을 할텐데, 그것은 너무나 큰 PayLoad이기 때문에, 메모리 속 `조인버퍼`에 넣어서 조인을 걸어준다 
* 블록 네스티드 루프 조인(block_nested_loop) 
  * 조건에 매칭되는 Driving Table 레코드를 `조인 버퍼`에 넣어서 조인을 걸어준다
* 인덱스 컨디션 푸시다운(index_condition_pushdown)
* 인덱스 확장(use_index_extensions)
* 인덱스 머지(index_merge)
  * 테이블당 꼭 1개의 인덱스를 타지 않아도 된다; n개도 가능
* 인덱스 머지 - 교집합(index_merge_intersection)
* 인덱스 머지 - 합집합(index_merge_union)
* 인덱스 머지 - 정렬 후 합집합(index_merge_sort_union)
* 세미 조인(semijoin)
  * subquery
* 테이블 풀-아웃(table pull-out)
* 퍼스트 매치(firstmatch)
* 루스 스캔(loosescan)
* 구체화(materialization)
* 중복 제거(duplicated weed-out)
* 컨디션 팬아웃(condition_fanout_filter)
* 파생 테이블 머지(derived_merge)
* 인비저블 인덱스(use_invisible_indexes)
* 스킵 스캔(skip_scan)
* 해시 조인(hash_join)
  * Nested Loop Join의 차선책 (Fallback Strategy)으로 사용
    * 조인 조건의 칼럼이 인덱스가 없는 경우
    * 조인 대상 테이블 중 일부 레코드 건수가 매우 적은 경우
  * Extra
    * `Using join buffer (hash join)`
* 인덱스 정렬 선호(prefer_ordering_index)

<br>

### Nested Loop Join vs Hash Join
* Nested Loop Join
  * 최고 응답 속도(Best Response-time) > OLTP에 적합
* Hash Join
  * 최고 스루풋(Best Throughput)전략 > OLAP에 적합

<div align="center">
  <img width="80%" src="https://user-images.githubusercontent.com/37537227/220366154-bcf3a30f-416a-406d-b277-2ebed03c5f35.png">
</div>

<br>

### 조인 최적화 알고리즘
* Exhaustive 검색 알고리즘
  * FROM절에 명시된 모든 테이블의 조합에 대해 실행 계획의 비용을 계산해서 최적의 조합 1개를 찾는 방법
  * n!개를 모두 확인해야 하기 때문에 시간 복잡도가 매우 오래 소요
* Greedy 검색 알고리즘
  * Depth를 하나씩 늘려가면서, 그때 그때의 부분 실행 계획을 채워나가다가 전체 실행 계획을 찾는 방법

<br>

### 쿼리 힌트
* 인덱스 힌트 (ANSI-SQL 표준 문법 준수 X, 가급적이면 옵티마이저 힌트 사용 권장)
  * STRAIGHT_JOIN 
    ```mysql
    EXPLAIN
        SELECT /*! STRAIGHT_JOIN */
               e.first_name, e.last_name, d.dept_name
        FROM   employees e, dept_emp de, departments d
        WHERE  e.emp_no = de.emp_no AND d.dept_no = de.deptn_no;
    ```
    * FROM 절에 명시된 테이블의 순서대로 (employees --> dept_emp --> departments)
    * 사용 유형 (`건수가 적은`이라는 표현은 WHERE 조건까지 포함한 건수를 의미, 전체 레코드 테이블이 아니다)
      * 임시 테이블 (인라인 뷰 or 파생된 테이블) --> 인라인 뷰
      * 임시 테이블끼리 --> 크기가 작은 테이블
      * 일반 테이블끼리 조인 --> 양쪽 다 인덱스있거나 없으면, 레코드 건수가 적은 테이블; 그 외에는, 조인 칼럼에 인덱스가 없는 테이블
    * 동일 기능을 탑재한 옵티마이저 힌트
      * `JOIN_FIXED_ORDER` : WHERE 조건 테이블 순서 그대로 (STRAIGHT_JOIN 인덱스 힌트와 동일한 기능)
      * `JOIN_ORDER`, `JOIN_PREFIX`, `JOIN_SUFFIX` : 일부 테이블의 조인 순서
  * USE INDEX / FORCE INDEX / IGNORE INDEX
  * SQL_CALC_FOUND_ROWS
* 옵티마이저 힌트
  * 옵티마이저 힌트 종류
  * MAX_EXECUTION_TIME
  * SET_VAR
  * SEMIJOIN & NO_SEMIJOIN
  * SUBQUERY
  * BNL & NO_BNL & HASHJOIN & NO_HASHJOIN
  * JOIN_FIXED_ORDER & JOIN_ORDER & JOIN_PREFIX & JOIN_SUFFIX
  * MERGE & NO_MERGE
  * INDEX_MERGE & NO_INDEX_MERGE
  * NO_ICP
  * SKIP_SCAN & NO_SKIP_SCAN
  * INDEX & NO_INDEX

<br>
<hr>
<br>
