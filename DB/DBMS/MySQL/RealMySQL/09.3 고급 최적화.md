# 옵티마이저와 힌트
> 쿼리를 최적으로 실행하기 위해 각 테이블의 데이터가 어떤 분포로 저장돼 있는지 통계 정보를 참조하여, 그러한 기본 데이터를 비교해 최적의 실행 계획을 수립하는 작업 필요
* `Explain` 명령어로 쿼리의 실행 계획 확인 가능

<hr>
<br>

## 고급 최적화
#### MySQL 서버의 옵티마이저가 실행 계획을 수립할 때 `통계 정보`와 `옵티마이저 옵션`을 결합해서 최적의 실행 계획 수립
#### 옵티마이저 옵션 = {옵티마이저 옵션, 옵티마이저 스위치}

<br>

### 옵티마이저 스위치 옵션 (ON, OFF, DEFAULT 중 택 1)
> Driven Table 중에 하나를 `조인 버퍼`에 저장한다는 것이 주요 포인트

```mysql
SET GLOBAL optimizer_switch='';
SET SESSION optimizer_switch='';
SELECT /*+ SET_VAR(optimizer_switch='') */
```
* MRR 배치 키 액세스(mrr & batched_key_access) 
  * Driven Table에 엑세스할 때, 인덱스를 타지 못하면, 매번 테이블 풀 스캔을 할텐데, 그것은 너무나 큰 PayLoad이기 때문에, 메모리 속 `조인버퍼`에 넣어서 조인을 걸어준다 
* 블록 네스티드 루프 조인(block_nested_loop) 
  * 조건에 매칭되는 Driving Table 레코드를 `조인 버퍼`에 넣어서 조인을 걸어준다
* 인덱스 컨디션 푸시다운(index_condition_pushdown)
* 인덱스 확장(use_index_extensions)
* 인덱스 머지(index_merge)
  * 테이블당 꼭 1개의 인덱스를 타지 않아도 된다; n개도 가능
* 인덱스 머지 - 교집합(index_merge_intersection)
* 인덱스 머지 - 합집합(index_merge_union)
* 인덱스 머지 - 정렬 후 합집합(index_merge_sort_union)
* 세미 조인(semijoin)
  * subquery
* 테이블 풀-아웃(table pull-out)
* 퍼스트 매치(firstmatch)
* 루스 스캔(loosescan)
* 구체화(materialization)
* 중복 제거(duplicated weed-out)
* 컨디션 팬아웃(condition_fanout_filter)
* 파생 테이블 머지(derived_merge)
* 인비저블 인덱스(use_invisible_indexes)
* 스킵 스캔(skip_scan)
* 해시 조인(hash_join)
  * Nested Loop Join의 차선책 (Fallback Strategy)으로 사용
    * 조인 조건의 칼럼이 인덱스가 없는 경우
    * 조인 대상 테이블 중 일부 레코드 건수가 매우 적은 경우
  * Extra
    * `Using join buffer (hash join)`
* 인덱스 정렬 선호(prefer_ordering_index)

<br>

### Nested Loop Join vs Hash Join
* Nested Loop Join
  * 최고 응답 속도(Best Response-time) > OLTP에 적합
* Hash Join
  * 최고 스루풋(Best Throughput)전략 > OLAP에 적합

<div align="center">
  <img width="80%" src="https://user-images.githubusercontent.com/37537227/220366154-bcf3a30f-416a-406d-b277-2ebed03c5f35.png">
</div>

<br>

### 조인 최적화 알고리즘
* Exhaustive 검색 알고리즘
  * FROM절에 명시된 모든 테이블의 조합에 대해 실행 계획의 비용을 계산해서 최적의 조합 1개를 찾는 방법
  * n!개를 모두 확인해야 하기 때문에 시간 복잡도가 매우 오래 소요
* Greedy 검색 알고리즘
  * Depth를 하나씩 늘려가면서, 그때 그때의 부분 실행 계획을 채워나가다가 전체 실행 계획을 찾는 방법

<br>

### 쿼리 힌트
* 인덱스 힌트 (ANSI-SQL 표준 문법 준수 X, 가급적이면 옵티마이저 힌트 사용 권장)
  * STRAIGHT_JOIN (JOIN의 순서)
    * SELECT 문 옆에 위치
    ```mysql
    EXPLAIN
        SELECT /*! STRAIGHT_JOIN */
               e.first_name, e.last_name, d.dept_name
        FROM   employees e, dept_emp de, departments d
        WHERE  e.emp_no = de.emp_no AND d.dept_no = de.deptn_no;
    ```
    * FROM 절에 명시된 테이블의 순서대로 (employees --> dept_emp --> departments)
    * 사용 유형 (`건수가 적은`이라는 표현은 WHERE 조건까지 포함한 건수를 의미, 전체 레코드 테이블이 아니다)
      * 임시 테이블 (인라인 뷰 or 파생된 테이블) --> 인라인 뷰
      * 임시 테이블끼리 --> 크기가 작은 테이블
      * 일반 테이블끼리 조인 --> 양쪽 다 인덱스있거나 없으면, 레코드 건수가 적은 테이블; 그 외에는, 조인 칼럼에 인덱스가 없는 테이블
    * 동일 기능을 탑재한 옵티마이저 힌트
      * `JOIN_FIXED_ORDER` : WHERE 조건 테이블 순서 그대로 (STRAIGHT_JOIN 인덱스 힌트와 동일한 기능)
      * `JOIN_ORDER`, `JOIN_PREFIX`, `JOIN_SUFFIX` : 일부 테이블의 조인 순서
  * USE INDEX / FORCE INDEX / IGNORE INDEX (인덱스)
    * 인덱스를 가지는 테이블 뒤에 위치
    * 설명
      * USE INDEX : MySQL 옵티마이저에게 특정 테이블의 인덱스를 사용하도록 권장하는 힌트 정도
      * FORCE INDEX : USE INDEX보다 옵티마이저에게 미치는 영향이 더 강한 힌트 정도
      * IGNORE INDEX : 특정 인덱스를 무시하도록 하는 힌트 정도
        * 보통, 풀 테이블 스캔을 유도하기 위해 사용
  * USE INDEX FOR JOIN / USE INDEX FOR ORDER BY / USE INDEX FOR GROUP BY
    * FOR JOIN : 테이블 간의 JOIN + 레코드 검색
    * 예시) 
    ```mysql
    SELECT * 
    FROM   employees 
    WHERE  emp_no=10001;
    
    SELECT *
    FROM   employees FORCE INDEX(primary)
    WHERE  emp_no=10001;
    
    SELECT *
    FROM   employees USE INDEX(primary)
    WHERE  emp_no=10001;
    ```
      * PRIMARY KEY를 이용한 동일한 실행계획
    ```mysql
    SELECT *
    FROM   employees IGNORE INDEX(primary)
    WHERE  emp_no=10001;
    ```
      * INDEX를 못타게 한 실행계획
    ```mysql
    SELECT *
    FROM   employees FORCE INDEX(ix_firstname)
    WHERE  emp_no=10001;
    ```
      * 전혀 관계없는 인덱스를 선택했을 때 테이블 풀스캔을 이용하게 만드는 실행계획
  * SQL_CALC_FOUND_ROWS
    * LIMIT으로 만족한 수만큼의 레코드를 찾았다고 하더라도, 끝까지 검색 수행
    * 다만, 책에서는 사용을 권장하지 않는다
    * 예시) 
    ```mysql
    SELECT SQL_CALC_FOUND_ROWS *
    FROM   employees
    WHERE  first_name='Georgi'
    LIMIT  0, 20
    ;
    
    SELECT FOUND_ROWS() AS total_record_count;
    ```
    ```mysql
    SELECT COUNT(*)
    FROM   employees 
    WHERE  first_name='Georgi'
    ;
    ```
* 옵티마이저 힌트
  * 옵티마이저 힌트 종류
    * 인덱스 : 특정 인덱스의 이름 사용 (테이블명, 인덱스 순으로 명시 필요)
    * 테이블 : 특정 테이블의 이름 사용
    * 쿼리 블록 : 특정 쿼리 블록 사용 (QB_NAME으로 네이밍 필요)
    ```mysql
    EXPLAIN
    SELECT   /*+ JOIN_ORDER(e, s@subq1) */
             COUNT(*)
    FROM     employees e
    WHERE    e.first_name='Matt'
    AND      e.emp_no IN (SELECT /*+ QB_NAME(subq1) */ s.emp_no
                          FROM   salaries s
                         WHERE   s.salaries WHERE 50000 AND 50500)
    ;
    ```
    * 글로벌(쿼리 전체) : 전체 쿼리에 대해서 영향을 미치는 힌트
  * MAX_EXECUTION_TIME (ms 단위로 쿼리의 실행 시간 제한)
  * SET_VAR (해당 쿼리에 한해서 시스템 변수 세팅)
    ```mysql
    EXPLAIN
        SELECT /*+ SET_VAR(optimizer_switch='index_merge_intersection=off') */ *
        FROM   employees
        WHERE  first_name='Georgi' AND emp_no BETWEEN 10000 AND 20000;
    ```
  * SEMIJOIN & NO_SEMIJOIN
    * 최적화 전략
      * Duplication Weed-out : SEMIJOIN(DUPSWEEDOUT)
      * First Match : SEMIJOIN(FIRSTMATCH)
      * Loose Scan  : SEMIJOIN(LOOSESCAN)
      * Materialization : SEMIJOIN(MATERIALIZATION)
      * Table Pull-out : 없음
    ```mysql
    EXPLAIN
        SELECT *
        FROM   departments d
        WHERE  d.dept_no IN
               (
                SELECT /*+ SEMIJOIN(MATERIALIZATION) */ de.dept_no
                FROM   dept_emp de
               );
    ```
    ```mysql
    EXPLAIN
        SELECT /*+ SEMIJOIN(MATERIALIZATION) */ *
        FROM   departments d
        WHERE  d.dept_no IN
               (
                SELECT  /*+ QB_NAME(subq1) */ de.dept_no
                FROM    dept_emp de
               );
    ```
  * SUBQUERY (보통 SEMIJOIN 최적화가 사용되지 못할 때 사용)
    * 전략
      * IN-to-EXISTS : SUBQUERY(INTOEXISTS)
      * Materialization : SUBQUERY(MATERIALIZATION)
  * BNL & NO_BNL & HASHJOIN & NO_HASHJOIN
    ```mysql
    EXPLAIN
        SELECT /*+ BNL(e, de) */ *
        FROM   employees e
        INNER JOIN dept_emp de ON de.emp_no=e.emp_no
        ;
    ```
  * JOIN_FIXED_ORDER & JOIN_ORDER & JOIN_PREFIX & JOIN_SUFFIX
    * JOIN_FIXED_ORDER : STRAIGHT_JOIN 힌트와 동일하게 FROM 절의 테이블 순서대로 조인
    * JOIN_ORDER : 힌트에 명시된 테이블 순서대로 조인 
    * JOIN_PREFIX : 조인에서 드라이빙 테이블만 강제하는 힌트
    * JOIN_SUFFIX : 조인에서 드리븐 테이블(가장 마지막에 조인돼야 할 테이블들)만 강제하는 힌트
    ```mysql
    -- FROM절 순서대로
    SELECT /*+ JOIN_FIXED_ORDER() */ *
    FROM   employees e
           INNER JOIN dept_emp    de ON de.emp_no=e.emp_no
           INNER JOIN departments d  ON d.dept_no=de.dept_no
    ;
    ```
    ```mysql
    -- 힌트 순서대로
    SELECT /*+ JOIN_ORDER(d, de) */ *
    FROM   employees e
           INNER JOIN dept_emp   de ON de.emp_no=e.emp_no
           INNER JOIN departments d ON d.dept_no=de.dept_no
    ;
    ```
    ```mysql
    -- Driving Table 순서
    SELECT /*+ JOIN_PREFIX(e, de) */ *
    FROM   employees e
           INNER JOIN dept_emp de ON de.emp_no=e.emp_no
           INNER JOIN departments d ON d.dept_no=de.dept_no
    ;
    ```
    ```mysql
    -- Driven Table 순서
    SELECT /*+ JOIN_SUFFIX(de, e) */ *
    FROM   employees e
           INNER JOIN dept_emp de ON de.emp_no=e.emp_no
           INNER JOIN departments d ON d.dept_no=de.dept_no
    ;
    ```
  * MERGE & NO_MERGE
    * FROM 절에 사용된 서브쿼리가 내부테이블 (Derived Table)로 생성될 수 있는데, 이는 불필요한 자원 소모를 유발할 수 있기에, 병합 최적화도 필요
    ```mysql
    EXPLAIN
        SELECT /*+ MERGE(sub) */ *
        FROM   (SELECT *
                FROM   employees
                WHERE  first_name='Matt'
               ) sub LIMIT 10 
    ;
    ```
  * INDEX_MERGE & NO_INDEX_MERGE
    * 하나의 테이블에 대해 여러 개의 인덱스를 동시에 사용하는 것을 인덱스 머지 (Index Merge)
    ```mysql
    EXPLAIN
        SELECT /*+ INDEX_MERGE(employees ix_firstname, PRIMARY) */ *
        FROM  employees
        WHERE first_name='Georgi' AND emp_no BETWEEN 10000 AND 20000
    ;
    ```
  * NO_ICP (Index Condition Pushdown)
    * NO 설정만 제공     
  * SKIP_SCAN & NO_SKIP_SCAN
    * 인덱스의 선행 칼럼에 대한 조건이 없어도 옵티마이저가 해당 인덱스를 사용할 수 있게 해줌
    * 다만, 조건이 누락된 선행 칼럼이 가지는 유니크한 값의 개수가 많아진다면, 인덱스 스킵 스캔의 성능은 오히려 더 떨어진다
    ```mysql
    ALTER TABLE employees
        ADD INDEX ix_gender_birthdate (gender, birth_date);
    
    EXPLAIN
        SELECT gender, birth_date
        FROM   employees
        WHERE  birth_date >= '1965-02-01'
    ;
    ```
  * INDEX & NO_INDEX
    * INDEX 및 NO_INDEX 옵티마이저 힌트는 예전 MySQL의 인덱스 힌트를 대체하는 용도
    
    |인덱스 힌트|옵티마이저 힌트|
    |--------|-----------|
    |USE INDEX|INDEX   |
    |USE INDEX FOR GROUP BY|GROUP INDEX|
    |USE INDEX FOR ORDER BY|ORDER_INDEX|
    |IGNORE INDEX|NO_INDEX|
    |IGNORE INDEX FOR GROUP BY|NO_GROUP_INDEX|
    |IGNORE INDEX FOR ORDER BY|NO_ORDER_INDEX|
    
    ```mysql
    -- 인덱스 힌트 사용 
    EXPLAIN
        SELECT *
        FROM   employees USE INDEX(ix_firstname)
        WHERE  first_name='Matt'
    ;
    
    -- 옵티마이저 힌트 사용
    EXPLAIN
        SELECT * /*+ INDEX(employees ix_firstname) */ *
        FROM   employees 
        WHERE  first_name='Matt'
    ;
    ```
    
<br>
<hr>
<br>
