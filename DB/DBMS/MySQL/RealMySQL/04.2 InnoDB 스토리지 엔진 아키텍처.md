# InnoDB 스토리지 엔진 아키텍처
> MySQL에서 사용할 수 있는 스토리지 엔진 중 거의 유일하게 레코드 기반의 잠금 기능을 제공
* 이에 따라, 높은 동시성으로 처리 가능 

<div align="center">
  <img width="50%" src="https://user-images.githubusercontent.com/37537227/212529377-98ca923a-d334-415f-962e-3587a8dcb9ef.png" >
</div>

<hr>
<br>

## 프라이머리 키에 의한 클러스터링
#### 프라이머리 키를 이용한 레인지 스캔은 빨리 처리됨

<br>

### InnoDB의 모든 테이블은 기본적으로 프라이머리 키를 기준으로 클러스터링되어 저장
* 프라이머리 키 값의 순서대로 디스크에 저장
* 모든 세컨더리 인덱스는 레코드의 주소 대신 프라이머리 키의 값을 논리적인 주소로 사용
  * 즉, 쿼리 실행 계획에서 다른 보조 인덱스보다 프라이머리 키가 선택될 확률이 높다
* Oracle의 IOT (Index Organized Table)와 동일한 구조의 테이블이 InnoDB에서 일반적인 테이블 구조

<br>
<hr>
<br>

## 외래 키 지원
#### 서버 운영의 불편함 때문에 서비스용 데이터베이스에서는 생성하지 않는 것이 요즘의 추세이긴 함

<br>

### 서버 운영의 불편함이 발생하는 이유
* 외래 키는 부모 테이블과 자식 테이블 모두 해당 칼럼에 인덱스 생성이 필요하고, 변경 시에는 반드시 부모 테이블이나 자식 테이블에 데이터가 있는지 체크하는 작업이 필요하므로, 잠금이 여러 테이블로 전파되고, 그로 인해 데드락이 발생할 때가 많으므로 개발할 때도 외래 키의 존재에 주의하는 것이 좋다
* 수동 데이터 적재 및 스키마 변경 등의 관리 작업이 어려워질 수 있다
* 시스템 변수 OFF 설정 후 빠르게 작업 처리 가능
  * 부모 테이블에 대한 `ON DELETE CASECADE`와 `ON UPDATE CASCADE` 옵션도 무시
  * `Global`, `Session`
```mysql
SET foreign_key_checks=OFF;
SET SESSION foreign_key_checks=OFF;
```

<br>
<hr>
<br>

## MVCC (Multi Version Concurrency Control, 다중 버전 동시성 제어)
#### 하나의 레코드에 대해 여러 개의 버전이 동시에 관리된다는 의미

<br>

### MVCC의 가장 큰 목적은 잠금을 사용하지 않는 일관된 읽기를 제공
* InnoDB는 언두 로그(Undo Log)를 이용해 기능 구현

<br>

### DBMS의 MVCC 메커니즘 예시) 간단 UPDATE

<div align="center">
  <img width="50%" src="https://user-images.githubusercontent.com/37537227/212531247-871ba5a2-c7c1-4cd3-8fa7-7f2c8fc19b2c.png" >
</div>

```mysql
CREATE TABLE member (
  m_id INT NOT NULL,
  m_name VARCHAR(20) NOT NULL,
  m_area VARCHAR(100) NOT NULL,
  PRIMARY KEY(m_id),
  INDEX ix_area (m_area)
);

INSERT INTO member (m_id, m_name, m_area) VALUES (12, '홍길동', '서울');

COMMIT;
```

<div align="center">
  <img width="50%" src="https://user-images.githubusercontent.com/37537227/212531463-50536bc7-066a-4829-92e0-2cf256306131.png" >
</div>

```mysql
UPDATE member SET m_area = '경기' WHERE m_id = 12;
```
* 커밋 혹은 롤백 여부와 상관없이 InnoDB 버퍼 풀의 값은 새로운 값으로 업데이트
* InnoDB는 ACID를 보장하기 때문에 백그라운드 쓰레드가 버퍼 풀의 값과 데이터 파일의 값은 동일
* 다만, 기존 값을 언두 로그에 복사해놓음

```mysql
SELECT * FROM member WHERE m_id = 12;
```
* 아직 커밋 혹은 롤백이 되지 않은 상태에서 `SELECT`하면 작업 중인 레코드를 조회하면, 새로운 값 혹은 기존 값 중 어느 값이 READ될까?
  * 정답은 시스템 변수(transaction_isolation)에 설정된 격리 수준(Isolation Level)에 달려있다
* 격리 수준 (Isolation Level)
  * `READ_UNCOMMITTED` : InnoDB 버퍼 풀이 현재 가지고 있는 변경된 새로운 값을 읽어서 반환
  * `READ_COMMITTED`, `REPEATABLE_READ`, `SERIALIZABLE` : InnoDB 버퍼 풀 혹은 데이터 파일 속 데이터를 읽지 않고, 언두 영역의 데이터를 반환한다
* `MySQL`은 `Isolation Level`이 `READ_COMMITTED`이기 때문에, 언두 영역의 데이터를 반환
* MVCC 메커니즘
  * 즉, 하나의 레코드 (회원 번호가 12인 레코드)에 대해 2개의 버전이 유지되고, 필요에 따라 어느 데이터가 보여지는지 여러 가지 상황에 따라 달라지는 구조
  * 트렌젝션이 길어지면, 당연히 언두에서 관리하는 예전 데이터가 삭제되지 못하고, 오랫동안 많은 값들을 보관하게 되면서 언두 영역이 저장되는 시스템 테이블스페이스의 공간이 많이 늘어나는 상황 발생 가능
* 상황별 언두 영역의 값 삭제 시점
  * 롤백 이후 
    * 언두 영역의 기존 값이 버퍼 풀로로 다시 복구하고, 언두 영역의 데이터 삭제
  * 커밋 이후
    * 언두 영역을 필요로 하는 트랜젝션이 더는 없을 때 삭제

<br>
<hr>
<br>

## 잠금 없는 일관된 읽기 (Non-Locking Consistent Read)
#### InnoDB 스토리지 엔진은 MVCC 기술을 이용해 잠금을 걸지 않고 읽기 작업을 수행

<br>

### InnoDB에서 읽기 작업은 다른 트랜잭션이 가지고 있는 잠금을 기다리지 않고, 읽기 작업이 가능
* 격리수준이 `serializable`이 아닌, `read_uncommitted`나 `read_committed`, `repeatable_read` 수준인 경우
  * INSERT와 연결되지 않은 순수한 읽기(SELECT) 작업은 다른 트랜잭션의 변경 작업과 관계없이 항상 잠금을 대기하지 않고 바로 실행된다

<div align="center">
  <img width="50%" src="https://user-images.githubusercontent.com/37537227/212544944-b89fda97-1361-4270-b9f6-0d43090265d3.png" >
</div>

* Update하는 유저가 아직 Commit을 하지 않았더라도, 해당 변경 트렌잭션으로 인해 해당 row에 잠금이 걸리지 않는다는 것을 알 수 있다
  * `read_uncommited` 격리 수준의 유저는 버퍼 풀에서 변경된 새로운 값 (`경기`)을 READ
  * `read_committed`와 `repeatable_read` 격리 수준의 유저는 언두 영역의 변경되지 않은 기존의 값 (`서울`)을 READ


<br>
<hr>
<br>
