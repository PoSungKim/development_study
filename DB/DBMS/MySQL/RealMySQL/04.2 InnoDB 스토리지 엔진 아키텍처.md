# InnoDB 스토리지 엔진 아키텍처
> MySQL에서 사용할 수 있는 스토리지 엔진 중 거의 유일하게 레코드 기반의 잠금 기능을 제공
* 이에 따라, 높은 동시성으로 처리 가능 

<div align="center">
  <img width="50%" src="https://user-images.githubusercontent.com/37537227/212529377-98ca923a-d334-415f-962e-3587a8dcb9ef.png" >
</div>

<hr>
<br>

## 프라이머리 키에 의한 클러스터링
#### 프라이머리 키를 이용한 레인지 스캔은 빨리 처리됨

<br>

### InnoDB의 모든 테이블은 기본적으로 프라이머리 키를 기준으로 클러스터링되어 저장
* 프라이머리 키 값의 순서대로 디스크에 저장
* 모든 세컨더리 인덱스는 레코드의 주소 대신 프라이머리 키의 값을 논리적인 주소로 사용
  * 즉, 쿼리 실행 계획에서 다른 보조 인덱스보다 프라이머리 키가 선택될 확률이 높다
* Oracle의 IOT (Index Organized Table)와 동일한 구조의 테이블이 InnoDB에서 일반적인 테이블 구조

<br>
<hr>
<br>

## 외래 키 지원
#### 서버 운영의 불편함 때문에 서비스용 데이터베이스에서는 생성하지 않는 것이 요즘의 추세이긴 함

<br>

### 서버 운영의 불편함이 발생하는 이유
* 외래 키는 부모 테이블과 자식 테이블 모두 해당 칼럼에 인덱스 생성이 필요하고, 변경 시에는 반드시 부모 테이블이나 자식 테이블에 데이터가 있는지 체크하는 작업이 필요하므로, 잠금이 여러 테이블로 전파되고, 그로 인해 데드락이 발생할 때가 많으므로 개발할 때도 외래 키의 존재에 주의하는 것이 좋다
* 수동 데이터 적재 및 스키마 변경 등의 관리 작업이 어려워질 수 있다
* 시스템 변수 OFF 설정 후 빠르게 작업 처리 가능
  * 부모 테이블에 대한 `ON DELETE CASECADE`와 `ON UPDATE CASCADE` 옵션도 무시
  * `Global`, `Session`
```mysql
SET foreign_key_checks=OFF;
SET SESSION foreign_key_checks=OFF;
```

<br>
<hr>
<br>

## MVCC (Multi Version Concurrency Control, 다중 버전 동시성 제어)
#### 하나의 레코드에 대해 여러 개의 버전이 동시에 관리된다는 의미

<br>

### MVCC의 가장 큰 목적은 잠금을 사용하지 않는 일관된 읽기를 제공
* InnoDB는 언두 로그(Undo Log)를 이용해 기능 구현

<br>

### DBMS의 MVCC 메커니즘 예시) 간단 UPDATE

<div align="center">
  <img width="50%" src="https://user-images.githubusercontent.com/37537227/212531247-871ba5a2-c7c1-4cd3-8fa7-7f2c8fc19b2c.png" >
</div>

```mysql
CREATE TABLE member (
  m_id INT NOT NULL,
  m_name VARCHAR(20) NOT NULL,
  m_area VARCHAR(100) NOT NULL,
  PRIMARY KEY(m_id),
  INDEX ix_area (m_area)
);

INSERT INTO member (m_id, m_name, m_area) VALUES (12, '홍길동', '서울');

COMMIT;
```

<div align="center">
  <img width="50%" src="https://user-images.githubusercontent.com/37537227/212531463-50536bc7-066a-4829-92e0-2cf256306131.png" >
</div>

```mysql
UPDATE member SET m_area = '경기' WHERE m_id = 12;
```
* 커밋 혹은 롤백 여부와 상관없이 InnoDB 버퍼 풀의 값은 새로운 값으로 업데이트
* InnoDB는 ACID를 보장하기 때문에 백그라운드 쓰레드가 버퍼 풀의 값과 데이터 파일의 값은 동일
* 다만, 기존 값을 언두 로그에 복사해놓음

```mysql
SELECT * FROM member WHERE m_id = 12;
```
* 아직 커밋 혹은 롤백이 되지 않은 상태에서 `SELECT`하면 작업 중인 레코드를 조회하면, 새로운 값 혹은 기존 값 중 어느 값이 READ될까?
  * 정답은 시스템 변수(transaction_isolation)에 설정된 격리 수준(Isolation Level)에 달려있다
* 격리 수준 (Isolation Level)
  * `READ_UNCOMMITTED` : InnoDB 버퍼 풀이 현재 가지고 있는 변경된 새로운 값을 읽어서 반환
  * `READ_COMMITTED`, `REPEATABLE_READ`, `SERIALIZABLE` : InnoDB 버퍼 풀 혹은 데이터 파일 속 데이터를 읽지 않고, 언두 영역의 데이터를 반환한다
* `MySQL`은 `Isolation Level`이 `READ_COMMITTED`이기 때문에, 언두 영역의 데이터를 반환
* MVCC 메커니즘
  * 즉, 하나의 레코드 (회원 번호가 12인 레코드)에 대해 2개의 버전이 유지되고, 필요에 따라 어느 데이터가 보여지는지 여러 가지 상황에 따라 달라지는 구조
  * 트렌젝션이 길어지면, 당연히 언두에서 관리하는 예전 데이터가 삭제되지 못하고, 오랫동안 많은 값들을 보관하게 되면서 언두 영역이 저장되는 시스템 테이블스페이스의 공간이 많이 늘어나는 상황 발생 가능
* 상황별 언두 영역의 값 삭제 시점
  * 롤백 이후 
    * 언두 영역의 기존 값이 버퍼 풀로로 다시 복구하고, 언두 영역의 데이터 삭제
  * 커밋 이후
    * 언두 영역을 필요로 하는 트랜젝션이 더는 없을 때 삭제

<br>
<hr>
<br>

## 잠금 없는 일관된 읽기 (Non-Locking Consistent Read)
#### InnoDB 스토리지 엔진은 MVCC 기술을 이용해 잠금을 걸지 않고 읽기 작업을 수행

<br>

### InnoDB에서 읽기 작업은 다른 트랜잭션이 가지고 있는 잠금을 기다리지 않고, 읽기 작업이 가능
* 격리수준이 `serializable`이 아닌, `read_uncommitted`나 `read_committed`, `repeatable_read` 수준인 경우
  * INSERT와 연결되지 않은 순수한 읽기(SELECT) 작업은 다른 트랜잭션의 변경 작업과 관계없이 항상 잠금을 대기하지 않고 바로 실행된다

<div align="center">
  <img width="50%" src="https://user-images.githubusercontent.com/37537227/212544944-b89fda97-1361-4270-b9f6-0d43090265d3.png" >
</div>

* Update하는 유저가 아직 Commit을 하지 않았더라도, 해당 변경 트렌잭션으로 인해 해당 row에 잠금이 걸리지 않는다는 것을 알 수 있다
  * `read_uncommited` 격리 수준의 유저는 버퍼 풀에서 변경된 새로운 값 (`경기`)을 READ
  * `read_committed`와 `repeatable_read` 격리 수준의 유저는 언두 영역의 변경되지 않은 기존의 값 (`서울`)을 READ
* 이를 통해, 너무 오랜 기간동안 Active인 트랜잭션이 너무 많으면, 언두 영역의 값들이 삭제되지 못하고 유지됨에 따라, 서버가 느려지거나 문제가 발생할 수 있음

<br>
<hr>
<br>

## 자동 데드락 감지
#### 내부적으로 잠금이 교착 생태에 빠지지 않았는지 체크하기 위해 잠금 대기 목록을 그래프(Wait-for List) 형태로 관리

<br>

### 데드락 감지 쓰레드가 주기적으로 서로 교착 상태에 빠진 트랜젝션들 중 하나를 강제 종료한다
* 강제 종료 대상 : 언두 로그가 더 많은 거래
* 롤백 대상 : 언두 로그가 더 적은 거래
* 시스템 변수 
  * `innodb_table_locks`: (ON) 레코드 잠금뿐만 아니라, 테이블 레벨의 잠금까지 감지 가능
  * `innodb_deadlock_detect` : (OFF) 데드락 감지 쓰레드 미 사용
  * `innodb_lock_wait_timeout` : (ON) 데드락 상황에서 일정 시간이 지나면 자동으로 요청이 실패하고 에러 메세지를 반환

<br>
<hr>
<br>

## 자동화된 장애 복구
#### 완료되지 못한 트랜잭션, 디스크에 일부만 기록된 (Partial Write) 데이터 페이즈 등에 대한 일련의 복구 작업이 자동으로 진행

<br>

### 장애 복구 과정
* MySQL 서버가 가동되면 자동 복구 기능이 실행되지만, 자동 복구가 불가능한 상황이면 실행되지 못하고 종료된다
* 시스템 변수
  * `innodb_force_recovery` : 자동 복구 및 실행이 불가능할 때 사용하는 MySQL 복구 모드
    * 1 (SRV_FROCE_IGNORE_CORRUPT)
    * 2 (SRV_FORCE_NO_BACKGROUDN)
    * 3 (SRV_FORCE_NO_TRX_UNDO)
    * 4 (SRC_FORCE_NO_IBUF_MERGE)
    * 5 (SRV_FORCE_NO_UNDO_LOG_SCAN)
    * 6 (SRV_FORCE_NO_LOG_REDO)
* 기동된 이후에는 ```mysql mysqldump``` 명령어로 데이터를 최대한 백업하고 다시 DB와 테이블을 생성 필요
* 마지막 풀 백업 시점부터 장애 시점까지의 바이너리 로그가 있다면 사용하여 복구하는게 현명

<br>
<hr>
<br>

## InnoDB 버퍼 풀
#### InnoDB 스토리지 엔진에서 가장 핵심적으로 부분으로, 디스크의 데이터 파일이나 인덱스 정보를 메로리에 캐시해 두는 공간
#### 일반적인 CUD 연산은 랜덤한 디스크 작업을 발생시키는데, 버퍼 풀이 변경된 데이터를 모아서 처리하면 랜덤한 디스크 작업의 횟수를 줄일 수 있다

<br>

### 버퍼 풀의 크기 설정
* 128MB 크키의 청크 단위로 쪼개어 관리된다
* 고려사항 (메모리 혼자 사용하는게 아니기에...)
  * 운영체제
  * 각 클라이언트 쓰레드
  * 레코드 쓰레드
  * 기타 다른 프로그램들...
* 시스템 변수
  * `inno_buffer_pool_size` : 늘리는건 시스템 부하가 적지만 내리는건 매우 크다
  * `innodb_buffer_pool_instances` : 버퍼 풀 전체를 몇 개의 인스턴스로 나눌지 결정

<br>

### 버퍼 풀의 구조
* InnoDB 스토리지 엔진은 버퍼 풀이라는 거대한 메모리 공간을 페이지 크기(innodb_page_size 시스템 변수에 설정된)의 조각으로 쪼개어 InnoDB 스토리지 엔진이 데이터를 필요로 할 때 해당 데이터 페이지를 읽어서 각 조각에 저장
* 버퍼 풀의 페이지 크기 조각 관리를 위한 자료구조
  * LRU (Least Recently Used) 리스트 - 
  * Flush 리스트 - 
  * Free 리스트 - 비어있는 페이지들의 목록

<div align="center">
  <img width="50%" src="https://user-images.githubusercontent.com/37537227/212549168-94ccd3ce-3240-44fb-a830-e65f39e51074.png" >
</div>

<br>

### 버퍼 풀과 리두 로그

<br>
<hr>
<br>
