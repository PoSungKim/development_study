# 옵티마이저와 힌트
> 쿼리를 최적으로 실행하기 위해 각 테이블의 데이터가 어떤 분포로 저장돼 있는지 통계 정보를 참조하여, 그러한 기본 데이터를 비교해 최적의 실행 계획을 수립하는 작업 필요
* `Explain` 명령어로 쿼리의 실행 계획 확인 가능

<hr>
<br>

## 개요
#### 실행 계획을 수립하는 옵티마이저를 이해하는 것이 중요하며, 실행 계획을 이해해야지 더 최적화된 방법으로 실행 계획을 수립하도록 유도 가능

<br>

### 쿼리 실행 절차
* SQL Parsing --> SQL Parse Tree (MySQL 엔진)
* Optimizer --> Execution Plan (MySQL 엔진)
* Record Extract (MySQL 엔진 + 스토리지 엔진)

<br>

### 옵티마이저 종류
* CBO (Cost-based Optimizer)
* RBO (Rule-based Optimizer)

<br>
<hr>
<br>

## 기본 데이터 처리
#### 

<br>

### 풀 테이블 스캔과 풀 인덱스 스캔
* 풀 테이블 스캔 사용하는 경우
  * 레코드 건수가 너무 작을 때
  * WHERE 절이나 ON 절에 인덱스를 이용이 적절하지 않을 경우
  * 인덱스 레인지 스캔 사용 가능 쿼리라도, 레코드 건수가 너무 많은 경우
* 풀 인덱스 스캔 사용하는 경우
  ```mysql
  SELECT COUNT(*) FROM employees;
  ```
  
<br>

### 병렬 처리
```mysql
SET SESSION innodb_parallel_read_threads=8;
SELECT COUNT(*) FROM salaries;
```
* MySQL 8.0에서 병렬 처리를 사용하기 위해서는 WHERE 절에 아무것도 없어야 함
* CPU의 코어 개수를 넘는 설정 X

<br>

### Order By 처리 (Using filesort)
* 인덱스 이용 vs FileSort 이용 (정렬할때 인덱스를 못사용하면, FileSort를 사용한다)
  * 인덱스를 사용하지 못하는 경우
    * 정렬 기준이 너무 많아서 요건별로 모두 인덱스 생성하는 것이 불가능할 경우
    * Group by 혹은 Distinct 결과를 정렬해야 하는 경우
    * Union의 결과 같이 임시 테이블의 결과를 다시 정렬해야 하는 경우
    * 랜던하게 결과 레코드를 가져와야 하는 경우
* 소트 버퍼
  * MySQL은 정렬을 수행하기 위해 별도의 메모리 공간을 할당받아서 사용하는데, 이 메모리 공간이 소트 버퍼(Sort Buffer)
  * Sort해야 하는 레코드의 개수가 너무 많아서 할당된 메모리 공간으로 충분하지 않을 때, 디스크 공간을 임시 저장공간으로 사용
    * 각 버퍼 크키만큼 정렬된 레코드를 다시 병합하면서 정렬을 수행해야 한다
    * 즉, Multi-merge 과정을 거친다
  * 시스템 변수
    * `sort_buffer_size` : 최대 사용 가능한 소트 버퍼 공간
    * `Sort_merge_passes` : 수행된 멀티 머지 횟수 (`SHOW STATUS VARIABLES`)
  * 예시)
    ```mysql
    SELECT * FROM salaries
    ORDER BY to_date
    LIMIT 999999999, 1;
    ```
    * to_date에 인덱스 처리가 되어 있지 않아서, 쿼리 처리 시에 정렬 작업이 필요한 쿼리
  * MySQL 메모리 영역 ({글로벌 메모리 영역,  세션 (로컬) 메모리 영역}) 중 Sort Buffer는 `세션 (로컬) 메모리 영역`
    * 즉, 여러 클라이언트가 공유해서 사용할 수 있는 영역이 아니다
      * 커넥션이 많으면 많을수록, 정렬 작업이 많을 수록, 소트 버퍼로 소비되는 메모리 공간이 커짐을 의미
    * 운영체제의 입장에서 메모리 부족 현상이 발생하면, OOM-Killer가 여유 메모리를 확보하기 위해 프로세스를 강제로 종료
      * 메모리를 가장 많이 사용하는 프로세스를 강제 종료하기 때문에 일반적으로 메모리를 가장 많이 사용하는 MySQL 서버가 강제 종료 1순위가 된다
* 정렬 알고리즘
  ```mysql
  -- 옵티마이저 트레이스 활성화
  SET OPTIMIZER_TRACE = "enabled=on", END_MARKERS_IN_JSON=on;
  SET OPTIMIZER_TRACE_MAX_MEM_SIZE=1000000;

  -- 쿼리 실행
  SELECT * FROM employees ORDER BY last_name LIMIT 100000, 1;
  
  -- 트레이스 내용 확인
  SELECT * FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE \G
  ```
  * filesort_summary
    * sort_algorithm
      * std::stable_sort : C++의 stable_sort 함수로
    * sort_mode (MySQL 서버의 정렬 방식 3가지)
      * <sort_key, rowid> : (투 패스 정렬) 정렬 키와 레코드의 로우 아이디(Row ID)만 가져와서 정렬하는 방식
      * <sort_key, additional_fields> : (싱글 패스 정렬) 정렬 키와 레코드 전체를 가져와서 정렬하는 방식, 레코드 칼럼들은 고정 사이즈로 메모리 저장
      * <sort_key, packed_additional_fields> : (싱글 패스 정렬) 정렬 키와 레코드 전체를 가져와서 정렬하는 방식, 레코드 칼럼들은 가변 사이즈로 메모리 저장
* `싱글 패스 정렬` vs `투 패스 정렬`
  ```mysql
  SELECT   emp_no, first_name, last_name
  FROM     employees
  ORDER BY first_name;
  ```
  * `싱글 패스 정렬` (Single Pass) 방식 - 소트 버퍼에 정렬 기준 칼럼을 포함해 SELECT 대상이 되는 칼럼 전부를 담아서 정렬 수행
  
  <div align="center">
    <img width="70%" src="https://user-images.githubusercontent.com/37537227/219857776-46ac90fc-0867-4951-8d08-97364f5381c0.png">
  </div>
  
    * sort에 필요하지 않는 `emp_no`, `last_name`까지 DB에서 읽어서 메모리에 올린 후 정렬하여 클라이언트에 넘겨준다
  * `투 패스 정렬` (Two Pass) 방식 - 정렬 대상 칼럼과 프라이머리 키 값만 소트 버퍼에 담아서 정렬을 수행하고, 정렬된 순서대로 다시 프라이머리 키로 테이블을 읽어서 SELECT할 칼럼을 가져오는 정렬 방식

  <div align="center">
    <img width="70%" src="https://user-images.githubusercontent.com/37537227/219857920-6f5dffe1-5db5-46c0-abc1-38f8ebcc1d06.png">
  </div>
  
    * 정렬 결과를 토대로 한 번 더 DB에서 읽어서 마지막 결과물인 `쿼리 결과`를 반환한다
    * 최신버전에서는 일반적으로 Single Pass 정렬 방식을 사용
      * 다만, Single Pass는 1번의 DB 읽기로 모든 결과를 가져와서 정렬을 하기 때문에, 설정한 버퍼 소트 공간으로는 더 적은 개수의 레코드를 정렬할 수 있다 (더 많은 칼럼을 가져오니까)
      * 물론, Two Pass는 동일한 크기의 버퍼 소트 공간으로 더 많은 Record를 정렬할 수 있지만, 2번의 DB 읽기를 해야 한다
    * 그럼에도 특정 상황에서는 Two Pass 정렬 방식이 채택된다
      * 레코드의 크키가 max_length_for_sort_data 시스템 변수에 설정된 값보다 클 때
      * BLOB이나 TEXT 타입의 칼럼이 SELECT 대상에 포함할 때
    * 정렬해야 하는 데이터의 총 크기에 따라서 Single Pass과 Two Pass 중 하나가 더 높은 효율성을 나타낸다
      * 정렬해야 하는 데이터의 크기가 크면, Two Pass
      * 정렬해야 하는 데이터의 크기가 작으면, Single Pass
      * 개인의견) 즉, 정말 필요한 칼럼만 SELECT하면 Single Pass를 타게될 것임
  * 정렬 처리 방법 (실행 계획의 Extra 칼럼 내용)
    * 인덱스를 이용한 정렬 (별도 표기 X) - 1번째로 빠름
      ```mysql
      SELECT *
      FROM   employees e, salaries s
      WHERE  s.emp_no = e.emp_no
        AND  e.emp_no BETWEEN 100002 AND 100020
      ORDER BY e.emp_no;
      
      -- emp_no 칼럼으로 정렬이 필요한데, 인덱스를 사용하면서 자동으로 정렬이 되지만, 굳이 ORDER BY에서 e.emp_no를 빼지는 않아야 한다
      -- 그 이유는 MySQL 서버는 인덱스로 처리할 수 있는 경우, 별도로 Order By가 존재하더라도, 2번 정렬을 하지 않는다. 즉, 인덱스만 1번 타기 때문에, 성능이슈는 없다
      ```
      ```mysql
      SELECT *
      FROM   employees e, salaries s
      WHERE  s.emp_no = e.emp_no
        AND  e.emp_no BETWEEN 100002 AND 100020
      ```
      
      <div align="center">
        <img width="80%" src="https://user-images.githubusercontent.com/37537227/219926977-82063d2b-8162-4f04-ab81-9907ff43df38.png">
      </div>

    * 조인의 드라이빙 테이블만 정렬 ("Using filesort" 표기) - 2번째로 빠름
    * 임시 테이블을 이용한 정렬 ("Using filesort; Using filesort" 표기) - 3번째로 빠름
    * 정렬 처리 방법의 성능 비교
      * 스트리밍 방식
      * 버퍼링 방식

<br>
<hr>
<br>

## 
#### 

<br>

### 

<br>
<hr>
<br>
