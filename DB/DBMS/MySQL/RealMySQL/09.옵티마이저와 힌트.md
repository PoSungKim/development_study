# 옵티마이저와 힌트
> 쿼리를 최적으로 실행하기 위해 각 테이블의 데이터가 어떤 분포로 저장돼 있는지 통계 정보를 참조하여, 그러한 기본 데이터를 비교해 최적의 실행 계획을 수립하는 작업 필요
* `Explain` 명령어로 쿼리의 실행 계획 확인 가능

<hr>
<br>

## 개요
#### 실행 계획을 수립하는 옵티마이저를 이해하는 것이 중요하며, 실행 계획을 이해해야지 더 최적화된 방법으로 실행 계획을 수립하도록 유도 가능

<br>

### 쿼리 실행 절차
* SQL Parsing --> SQL Parse Tree (MySQL 엔진)
* Optimizer --> Execution Plan (MySQL 엔진)
* Record Extract (MySQL 엔진 + 스토리지 엔진)

<br>

### 옵티마이저 종류
* CBO (Cost-based Optimizer)
* RBO (Rule-based Optimizer)

<br>
<hr>
<br>

## 기본 데이터 처리
#### 

<br>

### 풀 테이블 스캔과 풀 인덱스 스캔
* 풀 테이블 스캔 사용하는 경우
  * 레코드 건수가 너무 작을 때
  * WHERE 절이나 ON 절에 인덱스를 이용이 적절하지 않을 경우
  * 인덱스 레인지 스캔 사용 가능 쿼리라도, 레코드 건수가 너무 많은 경우
* 풀 인덱스 스캔 사용하는 경우
  ```mysql
  SELECT COUNT(*) FROM employees;
  ```
  
<br>

### 병렬 처리
```mysql
SET SESSION innodb_parallel_read_threads=8;
SELECT COUNT(*) FROM salaries;
```
* MySQL 8.0에서 병렬 처리를 사용하기 위해서는 WHERE 절에 아무것도 없어야 함
* CPU의 코어 개수를 넘는 설정 X

<br>

### Order By 처리 (Using filesort)
* 인덱스 이용 vs FileSort 이용 (정렬할때 인덱스를 못사용하면, FileSort를 사용한다)
  * 인덱스를 사용하지 못하는 경우
    * 정렬 기준이 너무 많아서 요건별로 모두 인덱스 생성하는 것이 불가능할 경우
    * Group by 혹은 Distinct 결과를 정렬해야 하는 경우
    * Union의 결과 같이 임시 테이블의 결과를 다시 정렬해야 하는 경우
    * 랜던하게 결과 레코드를 가져와야 하는 경우
* 소트 버퍼
  * MySQL은 정렬을 수행하기 위해 별도의 메모리 공간을 할당받아서 사용하는데, 이 메모리 공간이 소트 버퍼(Sort Buffer)
  * Sort해야 하는 레코드의 개수가 너무 많아서 할당된 메모리 공간으로 충분하지 않을 때, 디스크 공간을 임시 저장공간으로 사용
    * 각 버퍼 크키만큼 정렬된 레코드를 다시 병합하면서 정렬을 수행해야 한다
    * 즉, Multi-merge 과정을 거친다
  * 시스템 변수
    * `sort_buffer_size` : 최대 사용 가능한 소트 버퍼 공간
    * `Sort_merge_passes` : 수행된 멀티 머지 횟수 (`SHOW STATUS VARIABLES`)
  * 예시)
    ```mysql
    SELECT * FROM salaries
    ORDER BY to_date
    LIMIT 999999999, 1;
    ```
    * to_date에 인덱스 처리가 되어 있지 않아서, 쿼리 처리 시에 정렬 작업이 필요한 쿼리
  * MySQL 메모리 영역 ({글로벌 메모리 영역,  세션 (로컬) 메모리 영역}) 중 Sort Buffer는 `세션 (로컬) 메모리 영역`
    * 즉, 여러 클라이언트가 공유해서 사용할 수 있는 영역이 아니다
      * 커넥션이 많으면 많을수록, 정렬 작업이 많을 수록, 소트 버퍼로 소비되는 메모리 공간이 커짐을 의미
    * 운영체제의 입장에서 메모리 부족 현상이 발생하면, OOM-Killer가 여유 메모리를 확보하기 위해 프로세스를 강제로 종료
      * 메모리를 가장 많이 사용하는 프로세스를 강제 종료하기 때문에 일반적으로 메모리를 가장 많이 사용하는 MySQL 서버가 강제 종료 1순위가 된다
* 정렬 알고리즘
  ```mysql
  -- 옵티마이저 트레이스 활성화
  SET OPTIMIZER_TRACE = "enabled=on", END_MARKERS_IN_JSON=on;
  SET OPTIMIZER_TRACE_MAX_MEM_SIZE=1000000;

  -- 쿼리 실행
  SELECT * FROM employees ORDER BY last_name LIMIT 100000, 1;
  
  -- 트레이스 내용 확인
  SELECT * FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE \G
  ```
  * filesort_summary
    * sort_algorithm
      * std::stable_sort : C++의 stable_sort 함수로
    * sort_mode (MySQL 서버의 정렬 방식 3가지)
      * <sort_key, rowid> : (투 패스 정렬) 정렬 키와 레코드의 로우 아이디(Row ID)만 가져와서 정렬하는 방식
      * <sort_key, additional_fields> : (싱글 패스 정렬) 정렬 키와 레코드 전체를 가져와서 정렬하는 방식, 레코드 칼럼들은 고정 사이즈로 메모리 저장
      * <sort_key, packed_additional_fields> : (싱글 패스 정렬) 정렬 키와 레코드 전체를 가져와서 정렬하는 방식, 레코드 칼럼들은 가변 사이즈로 메모리 저장
* `싱글 패스 정렬` vs `투 패스 정렬`
  ```mysql
  SELECT   emp_no, first_name, last_name
  FROM     employees
  ORDER BY first_name;
  ```
  * `싱글 패스 정렬` (Single Pass) 방식 - 소트 버퍼에 정렬 기준 칼럼을 포함해 SELECT 대상이 되는 칼럼 전부를 담아서 정렬 수행
  
  <div align="center">
    <img width="70%" src="https://user-images.githubusercontent.com/37537227/219857776-46ac90fc-0867-4951-8d08-97364f5381c0.png">
  </div>
  
    * sort에 필요하지 않는 `emp_no`, `last_name`까지 DB에서 읽어서 메모리에 올린 후 정렬하여 클라이언트에 넘겨준다
  * `투 패스 정렬` (Two Pass) 방식 - 정렬 대상 칼럼과 프라이머리 키 값만 소트 버퍼에 담아서 정렬을 수행하고, 정렬된 순서대로 다시 프라이머리 키로 테이블을 읽어서 SELECT할 칼럼을 가져오는 정렬 방식

  <div align="center">
    <img width="70%" src="https://user-images.githubusercontent.com/37537227/219857920-6f5dffe1-5db5-46c0-abc1-38f8ebcc1d06.png">
  </div>
  
    * 정렬 결과를 토대로 한 번 더 DB에서 읽어서 마지막 결과물인 `쿼리 결과`를 반환한다
    * 최신버전에서는 일반적으로 Single Pass 정렬 방식을 사용
      * 다만, Single Pass는 1번의 DB 읽기로 모든 결과를 가져와서 정렬을 하기 때문에, 설정한 버퍼 소트 공간으로는 더 적은 개수의 레코드를 정렬할 수 있다 (더 많은 칼럼을 가져오니까)
      * 물론, Two Pass는 동일한 크기의 버퍼 소트 공간으로 더 많은 Record를 정렬할 수 있지만, 2번의 DB 읽기를 해야 한다
    * 그럼에도 특정 상황에서는 Two Pass 정렬 방식이 채택된다
      * 레코드의 크키가 max_length_for_sort_data 시스템 변수에 설정된 값보다 클 때
      * BLOB이나 TEXT 타입의 칼럼이 SELECT 대상에 포함할 때
    * 정렬해야 하는 데이터의 총 크기에 따라서 Single Pass과 Two Pass 중 하나가 더 높은 효율성을 나타낸다
      * 정렬해야 하는 데이터의 크기가 크면, Two Pass
      * 정렬해야 하는 데이터의 크기가 작으면, Single Pass
      * 개인의견) 즉, 정말 필요한 칼럼만 SELECT하면 Single Pass를 타게될 것임
  * 정렬 처리 방법 (실행 계획의 Extra 칼럼 내용)
    * 인덱스를 이용한 정렬 (별도 표기 X) - 1번째로 빠름
      ```mysql
      SELECT *
      FROM   employees e, salaries s
      WHERE  s.emp_no = e.emp_no
        AND  e.emp_no BETWEEN 100002 AND 100020
      ORDER BY e.emp_no;
      
      -- emp_no 칼럼으로 정렬이 필요한데, 인덱스를 사용하면서 자동으로 정렬이 되지만, 굳이 ORDER BY에서 e.emp_no를 빼지는 않아야 한다
      -- 그 이유는 MySQL 서버는 인덱스로 처리할 수 있는 경우, 별도로 Order By가 존재하더라도, 2번 정렬을 하지 않는다. 즉, 인덱스만 1번 타기 때문에, 성능이슈는 없다
      ```
      ```mysql
      SELECT *
      FROM   employees e, salaries s
      WHERE  s.emp_no = e.emp_no
        AND  e.emp_no BETWEEN 100002 AND 100020
      ```
      
      <div align="center">
        <img width="80%" src="https://user-images.githubusercontent.com/37537227/219926977-82063d2b-8162-4f04-ab81-9907ff43df38.png">
      </div>
      
      * Driving Table로 인덱스를 엑세스하기 때문에 정렬이 이미 되어 있다는 것이 주요 포인트
        * 단, 실행계획으로 `Join Buffer`가 사용되면 순서가 흐트러질 수 있음
    * 조인의 드라이빙 테이블만 정렬 ("Using filesort" 표기) - 2번째로 빠름
      ```mysql
      SELECT *
      FROM   employees e, salaries s
      WEHRE  s.emp_no = e.emp_no
      AND    e.emp_no BETWEEN 100002 AND 100010
      ORDER BY e.last_name
      ```
      * `employees` 테이블이 Driving Table으로 선정되는 이유
        1) `WHERE절의 e.emp_no BETWEEN` 연산에 사용되는 칼럼 `emp_no`는 `employees` 테이블의 PK이다
        2) Driven Table `salaries` 테이블의 조인 칼럼인 `emp_no` 칼럼에 인덱스가 존재

      <div align="center">
        <img width="80%" src="https://user-images.githubusercontent.com/37537227/219934170-69870fa3-96d0-44a5-806a-1ecd57142918.png">
      </div>

      * 그림 설명 
        * `BETWEEN`절에 매칭되는 `employees` 테이블 레코드들만 추출
        * 추출된 레코드들을 `last_name` 순으로 `Sort Buffer`에서 정렬 
        * 정렬된 Driving Table 레코드들을 기준으로 `salaries` 테이블과 조인
        * 출력값 리턴
    * 임시 테이블을 이용한 정렬 ("Using filesort; Using filesort" 표기) - 3번째로 빠름
      ```mysql
      SELECT   * 
      FROM     employees e, salaries s
      WHERE    s.emp_no = e.emp_no
      AND      e.emp_no BETWEEN 100002 AND 100010
      ORDER BY s.salary;
      ```
      
      <div align="center">
        <img width="80%" src="https://user-images.githubusercontent.com/37537227/219934653-e1811c3d-de05-44b3-a529-a5258c344d7f.png">
      </div>
      
      * `ORDER BY` 절의 기준 칼럼이 Driving Table이 아닌, Driven Table의 칼럼인 케이스
        1) Driving Table과 Driven Table을 조인한 결과를 임시 테이블에 저장 
        2) 임시 테이블을 정렬
        3) 결과 리턴
    * 정렬 처리 방법의 성능 비교 (쿼리에서 인덱스를 사용하지 못하는 정렬이나 그루핑 작업이 왜 느리게 작동할 수밖에 없는 이유)
      * 스트리밍 방식
        * 서버 쪽에서 처리할 데이터가 얼마인지에 관계없이 조건에 일치하는 레코드가 검색될 때마다 바로 클라이언트로 전송해주는 방식
        * 서버의 응답시간이 짧아지기 때문에 OLTP성 거래에 적합
        * Limit을 사용하면 마지막 레코드를 가져오기까지의 응답 시간이 줄일 수 있다
      * 버퍼링 방식
        * `ORDER BY`, `GROUP BY` 절을 사용하면, 그때 그때 바로 바로 클라이언트로 전달 불가능
        *  조건에 매칭되는 레코드를 모두 받은 이후에 정렬을 해야 하기 때문에 limit 절의 이점도 살릴 수 없음 
      * 클라이언트 도구 및 API 별로 {스트리밍, 버퍼링} 작동 방식이 다름
        * JDBC API는 버퍼링 (불필요한 네트워크 I/O를 줄여서 전체 Throughput 시간을 줄이기 위해서)
        * MySQL은 스트리밍 (응답시간을 줄이기 위해서)
        * (형태) JDBC API (버퍼링) <-- MySQL 서버 (스트리밍)
        * 즉, MySQL 서버는 그때 그때 가능하면 충족한 레코드 값들을 바로 바로 전달하지만, 그 값들을 받은 JDBC는 모두 다 저장 및 전달 받은 이후에 리턴한다
      * `인덱스를 이용한 정렬`만 스트리밍 방식으로 처리되며, 해당 케이스에서 사용된 `LIMIT`만이 스트리밍 처리 방식의 이점을 활용할 수 있다
      ```mysql
      SELECT   *  
      FROM     tb_test1 t1, tb_test2 t2
      WHERE    t1.col1 = t2.col1
      ORDER BY t1.col2
      LIMIT    10;
      ```
      
      <div align="center">
        <img width="40%" src="https://user-images.githubusercontent.com/37537227/219936113-816a7044-9724-4a88-b191-b61f009ffb99.png">
        <img width="42.6%" src="https://user-images.githubusercontent.com/37537227/219936121-682f633f-1924-4850-8f92-b1aef79deedc.png">
      </div>
* 정렬 관련 상태 변수
  * `FLUSH STATUS;`
  * `SHOW STATUS LIKE 'Sort%'`

<br>

### GROUP BY 처리
* GROUP BY 절에서 사용된 조건은 Index를 탈 수 없으니 HAVING 절 튜닝을 위해서 인덱스를 생성할 필요 X
* 인덱스 스캔을 이용하는 GROUP BY (타이트 인덱스 스캔)
* 루스 인덱스 스캔을 이용하는 GROUP BY
* 임시 테이블을 사용하는 GROUP BY

<br>

### DISTINCT 처리
* SELECT DISTINCT ...

<br>
<hr>
<br>

## 
#### 

<br>

### 

<br>
<hr>
<br>
