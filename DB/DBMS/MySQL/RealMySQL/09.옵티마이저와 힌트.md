# 옵티마이저와 힌트
> 쿼리를 최적으로 실행하기 위해 각 테이블의 데이터가 어떤 분포로 저장돼 있는지 통계 정보를 참조하여, 그러한 기본 데이터를 비교해 최적의 실행 계획을 수립하는 작업 필요
* `Explain` 명령어로 쿼리의 실행 계획 확인 가능

<hr>
<br>

## 개요
#### 실행 계획을 수립하는 옵티마이저를 이해하는 것이 중요하며, 실행 계획을 이해해야지 더 최적화된 방법으로 실행 계획을 수립하도록 유도 가능

<br>

### 쿼리 실행 절차
* SQL Parsing --> SQL Parse Tree (MySQL 엔진)
* Optimizer --> Execution Plan (MySQL 엔진)
* Record Extract (MySQL 엔진 + 스토리지 엔진)

<br>

### 옵티마이저 종류
* CBO (Cost-based Optimizer)
* RBO (Rule-based Optimizer)

<br>
<hr>
<br>

## 기본 데이터 처리
#### 

<br>

### 풀 테이블 스캔과 풀 인덱스 스캔
* 풀 테이블 스캔 사용하는 경우
  * 레코드 건수가 너무 작을 때
  * WHERE 절이나 ON 절에 인덱스를 이용이 적절하지 않을 경우
  * 인덱스 레인지 스캔 사용 가능 쿼리라도, 레코드 건수가 너무 많은 경우
* 풀 인덱스 스캔 사용하는 경우
  ```mysql
  SELECT COUNT(*) FROM employees;
  ```
<br>

### 병렬 처리
```mysql
SET SESSION innodb_parallel_read_threads=8;
SELECT COUNT(*) FROM salaries;
```
* MySQL 8.0에서 병렬 처리를 사용하기 위해서는 WHERE 절에 아무것도 없어야 함
* CPU의 코어 개수를 넘는 설정 X

<br>

### Order By 처리 (Using filesort)
* 인덱스 이용 vs FileSort 이용
  * 인덱스를 사용하지 못하는 경우
    * 정렬 기준이 너무 많아서 요건별로 모두 인덱스 생성하는 것이 불가능할 경우
    * Group by 혹은 Distinct 결과를 정렬해야 하는 경우
    * Union의 결과 같이 임시 테이블의 결과를 다시 정렬해야 하는 경우
    * 랜던하게 결과 레코드를 가져와야 하는 경우
* 소트 버퍼
  * MySQL은 정렬을 수행하기 위해 별도의 메모리 공간을 할당받아서 사용하는데, 이 메모리 공간이 소트 버퍼(Sort Buffer)
  * Sort해야 하는 레코드의 개수가 너무 많아서 할당된 메모리 공간으로 충분하지 않을 때, 디스크 공간을 임시 저장공간으로 사용
    * 각 버퍼 크키만큼 정렬된 레코드를 다시 병합하면서 정렬을 수행해야 한다
    * 즉, Multi-merge 과정을 거친다
  * 시스템 변수
    * `sort_buffer_size` : 최대 사용 가능한 소트 버퍼 공간
    * `Sort_merge_passes` : 수행된 멀티 머지 횟수 (`SHOW STATUS VARIABLES`)
  * 예시)
    ```mysql
    SELECT * FROM salaries
    ORDER BY to_date
    LIMIT 999999999, 1;
    ```
    * to_date에 인덱스 처리가 되어 있지 않아서, 쿼리 처리 시에 정렬 작업이 필요한 쿼리
  * MySQL 메모리 영역 ({글로벌 메모리 영역,  세션 (로컬) 메모리 영역}) 중 Sort Buffer는 `세션 (로컬) 메모리 영역`
    * 즉, 여러 클라이언트가 공유해서 사용할 수 있는 영역이 아니다
      * 커넥션이 많으면 많을수록, 정렬 작업이 많을 수록, 소트 버퍼로 소비되는 메모리 공간이 커짐을 의미
    * 운영체제의 입장에서 메모리 부족 현상이 발생하면, OOM-Killer가 여유 메모리를 확보하기 위해 프로세스를 강제로 종료
      * 메모리를 가장 많이 사용하는 프로세스를 강제 종료하기 때문에 일반적으로 메모리를 가장 많이 사용하는 MySQL 서버가 강제 종료 1순위가 된다
* 정렬 알고리즘
  ```mysql
  -- 옵티마이저 트레이스 활성화
  SET OPTIMIZER_TRACE = "enabled=on", END_MARKERS_IN_JSON=on;
  SET OPTIMIZER_TRACE_MAX_MEM_SIZE=1000000;

  -- 쿼리 실행
  SELECT * FROM employees ORDER BY last_name LIMIT 100000, 1;
  
  -- 트레이스 내용 확인
  SELECT * FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE \G
  ```
  * filesort_summary
    * sort_algorithm
      * std::stable_sort
    * sort_mode (MySQL 서버의 정렬 방식 3가지)
      * <sort_key, rowid> : (투 패스 정렬) 정렬 키와 레코드의 로우 아이디(Row ID)만 가져와서 정렬하는 방식
      * <sort_key, additional_fields> : (싱글 패스 정렬) 정렬 키와 레코드 전체를 가져와서 정렬하는 방식, 레코드 칼럼들은 고정 사이즈로 메모리 저장
      * <sort_key, packed_additional_fields> : (싱글 패스 정렬) 정렬 키와 레코드 전체를 가져와서 정렬하는 방식, 레코드 칼럼들은 가변 사이즈로 메모리 저장
  * `싱글 패스 정렬` 방식 - 소트 버퍼에 정렬 기준 칼럼을 포함해 SELECT 대상이 되는 칼럼 전부를 담아서 정렬 수행

  <div align="center">
    <img width="70%" src="https://user-images.githubusercontent.com/37537227/219857776-46ac90fc-0867-4951-8d08-97364f5381c0.png">
  </div>

  * `투 패스 정렬` 방식 - 소트 버퍼에 정렬 기준 칼럼을 포함해 SELECT 대상이 되는 칼럼 전부를 담아서 정렬 수행

  <div align="center">
    <img width="70%" src="https://user-images.githubusercontent.com/37537227/219857920-6f5dffe1-5db5-46c0-abc1-38f8ebcc1d06.png">
  </div>

  * 정렬 처리 방법
    * 인덱스를 이용한 정렬
    * 조인의 드라이빙 테이블만 정렬
    * 임시 테이블을 이용한 정렬
    * 정렬 처리 방법의 성능 비교
      * 스트리밍 방식
      * 버퍼링 방식


<br>
<hr>
<br>

