# 인덱스
> 
* 

<hr>
<br>

## 디스크 읽기 방식
#### 

<br>

### 하드 디스크 드라이브(HDD), 솔리드 스테이트 드라이브(SSD)
* raid controller
* index range scan > Random I/O
* full table scan > sequential I/O
* sortedlist (DBMS Index) vs arraylist (DBMS)

<br>
<hr>
<br>

## 인덱스란?
#### 

<br>

### 인덱스
* 데이터를 관리하는 방식 (알고리즘)
  * B-Tree Index (B+, B*)
  * Hash Index
* 중복 값 허용 여부
  * 프라이머리 키
  * 세컨더리 키

<br>
<hr>
<br>

## B-Tree 인덱스
####

<br>

### 구조 및 특성 
* InnoDB에서는 클러스터링 테이블을 제공 
  * 프라이머리 키 순서대로 정렬되어 데이터 파일이 저장된다
  * 프라이머리 키를 주소처럼 사용하기 때문에 논리적인 주소를 가진다고 볼 수 있다
  * 모든 세컨더리 인덱스 검색에서 데이터 레코드를 읽기 위해서는 반드시 프라이머리 키를 저장하고 있는 B-Tree를 다시 한 번 검색해야 한다
  * Oracle IOT (Index Organized Table)

<br>

### B-Tree 인덱스 키 추가 및 삭제
* 지연 추가 (체인지 버퍼)
* 바로 추가 (프라이머리 키 or 유니크 인덱스 키)
* 레코드 잠금이나 넥스트 키락(갭락)이 검색을 수행한 인덱스를 잠근 후 테이블의 레코드를 잠그는 방식으로 구현돼 있다 
* 페이지 개수 == 디스크 읽기 횟수

<br>

### B-Tree 인덱스 사용에 영향을 미치는 요소 
* 인덱스 키 값의 크기
* B-Tree 깊이
* 선택도 : Selectivity (기수성 : Cardinality)
  * 모든 인덱스 키 값 가운데 유니크한 값의 수를 의미
  * 전체 레코드 개수 및 기수성은 통계값으로 가지고 있다
  * 인덱스는 기수성이 높은 칼럼 값을 선택해야 함
* 읽어야 하는 레코드의 건수
  * 20~25%를 넘어서면 인덱스를 이용하지 않는 것이 좋겠다고 옵티마이저는 판단

<br>
<hr>
<br>


<br>

### B-Tree 인덱스를 통한 데이터 읽기
* 인덱스 레인지 스캔
  * SHOW STATUS LIKE 'Handler_%'
  * Index Seek --> Index Scan --> 레코드가 저장된 페이지 조회
  * 커버링 인덱스
* 인덱스 풀 스캔 (보통, 인덱스를 사용하지 않는다로 표현)
  * 인덱스 칼럼 (A, B, C) 중 WHERE 조건에 (B, C)만 있고, 인덱스만 읽어서 처리할 수 있는 쿼리면 사용 가능
* 루스 인덱스 스캔
  * 듬성 듬성 읽기
  * group by 작업에만 사용 가능
* 인덱스 스킵 스캔
  * 듬성 듬성 읽기
  * 커버링 인덱스 조건 충족 필요

<br>

### 다중 칼럼(Multi-column) 인덱스

<br>

### B-Tree 인덱스의 정렬 및 스캔 방향
- 인덱스의 정렬
  - 인덱스 스캔 방향
    - `Order By && Limit` : 옵티마이저가 스캔 방향을 결정하여 비용 없이 특정 개수의 레코드만 가져오면 된다
  - 내림차순 인덱스
    - 오른차순/내림차순 인덱스
    - 인덱스 정순/역순 스캔
      - 페이지 잠금이 인덱스 정순 스캔에 적합한 구조

<br>

### B-Tree 인덱스의 가용성과 효율성 (Where, group by, order by)
* 비교 조건의 종류와 효율성
* 인덱스의 가용성
  * `LIKE '%mer';` --> Left-most 정렬 기반의 B-Tree에 맞지 않음
* 가용성과 효율성 판단
  * 사용 못하는 경우 
    * Not Equal
    * Like '%??'
    * 스토어드 함수나 다른 연산자로 인덱스 칼럼이 변형된 후 비교된 경우
    * Not-deterministic 속성의 스토어드 함수
    * 데이터 타입이 서로 다른 비교
    * 문자열 데이터 타입의 콜레이션이 다른 경우
  * 사용 가능한 경우
    * 동등 비교 (=, IN)
    * 크다 작다 형태 (>, <)
    * Like 좌측 일치 패턴

<br>
<hr>
<br>
