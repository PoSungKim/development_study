# 인덱스
> 
* 

<hr>
<br>

## 디스크 읽기 방식
#### 

<br>

### 하드 디스크 드라이브(HDD), 솔리드 스테이트 드라이브(SSD)
* raid controller
* index range scan > Random I/O
* full table scan > sequential I/O
* sortedlist (DBMS Index) vs arraylist (DBMS)

<br>
<hr>
<br>

## 인덱스란?
#### 

<br>

### 인덱스
* 데이터를 관리하는 방식 (알고리즘)
  * B-Tree Index (B+, B*)
  * Hash Index
* 중복 값 허용 여부
  * 프라이머리 키
  * 세컨더리 키

<br>
<hr>
<br>

## B-Tree 인덱스
####

<br>

### 구조 및 특성 
* InnoDB에서는 클러스터링 테이블을 제공 
  * 프라이머리 키 순서대로 정렬되어 데이터 파일이 저장된다
  * 프라이머리 키를 주소처럼 사용하기 때문에 논리적인 주소를 가진다고 볼 수 있다
  * 모든 세컨더리 인덱스 검색에서 데이터 레코드를 읽기 위해서는 반드시 프라이머리 키를 저장하고 있는 B-Tree를 다시 한 번 검색해야 한다
  * Oracle IOT (Index Organized Table)

<br>

### B-Tree 인덱스 키 추가 및 삭제
* 지연 추가 (체인지 버퍼)
* 바로 추가 (프라이머리 키 or 유니크 인덱스 키)
* 레코드 잠금이나 넥스트 키락(갭락)이 검색을 수행한 인덱스를 잠근 후 테이블의 레코드를 잠그는 방식으로 구현돼 있다 
* 페이지 개수 == 디스크 읽기 횟수

<br>

### B-Tree 인덱스 사용에 영향을 미치는 요소 
* 인덱스 키 값의 크기
* B-Tree 깊이
* 선택도 : Selectivity (기수성 : Cardinality)
  * 모든 인덱스 키 값 가운데 유니크한 값의 수를 의미
  * 전체 레코드 개수 및 기수성은 통계값으로 가지고 있다
  * 인덱스는 기수성이 높은 칼럼 값을 선택해야 함
* 읽어야 하는 레코드의 건수
  * 20~25%를 넘어서면 인덱스를 이용하지 않는 것이 좋겠다고 옵티마이저는 판단

<br>
<hr>
<br>


<br>

### B-Tree 인덱스를 통한 데이터 읽기
* 인덱스 레인지 스캔
  * SHOW STATUS LIKE 'Handler_%'
  * Index Seek --> Index Scan --> 레코드가 저장된 페이지 조회
  * 커버링 인덱스
* 인덱스 풀 스캔 (보통, 인덱스를 사용하지 않는다로 표현)
  * 인덱스 칼럼 (A, B, C) 중 WHERE 조건에 (B, C)만 있고, 인덱스만 읽어서 처리할 수 있는 쿼리면 사용 가능
* 루스 인덱스 스캔
  * 듬성 듬성 읽기
  * group by 작업에만 사용 가능
* 인덱스 스킵 스캔
  * 듬성 듬성 읽기
  * 커버링 인덱스 조건 충족 필요

<br>

### 다중 칼럼(Multi-column) 인덱스

<br>

### B-Tree 인덱스의 정렬 및 스캔 방향
- 인덱스의 정렬
  - 인덱스 스캔 방향
    - `Order By && Limit` : 옵티마이저가 스캔 방향을 결정하여 비용 없이 특정 개수의 레코드만 가져오면 된다
  - 내림차순 인덱스
    - 오른차순/내림차순 인덱스
    - 인덱스 정순/역순 스캔
      - 페이지 잠금이 인덱스 정순 스캔에 적합한 구조

<br>

### B-Tree 인덱스의 가용성과 효율성 (Where, group by, order by)
* 비교 조건의 종류와 효율성
* 인덱스의 가용성
  * `LIKE '%mer';` --> Left-most 정렬 기반의 B-Tree에 맞지 않음
* 가용성과 효율성 판단
  * 사용 못하는 경우 
    * Not Equal
    * Like '%??'
    * 스토어드 함수나 다른 연산자로 인덱스 칼럼이 변형된 후 비교된 경우
    * Not-deterministic 속성의 스토어드 함수
    * 데이터 타입이 서로 다른 비교
    * 문자열 데이터 타입의 콜레이션이 다른 경우
  * 사용 가능한 경우
    * 동등 비교 (=, IN)
    * 크다 작다 형태 (>, <)
    * Like 좌측 일치 패턴


<br>
<hr>
<br>

## R-Tree 인덱스
#### 

<br>

### 구조 및 특성
* 공간 데이터를 저장할 수 있는 데이터 타입
* 공간 데이터의 검색을 위한 공간 인덱스(R-Tree 알고리즘)
* 공간 데이터의 연산 함수(거리 또는 포함 관계의 처리
* Minimum Bounding Rectangle (MBR)

<br>
<hr>
<br>

## 전문 검색 인덱스
#### 전문 검색 (Full Text Search) 인덱스

<br>

### 인덱스 알고리즘
* 어근 분석 알고리즘 (전문적)
  * 불용어 (Stop Word) 처리
  * 어근 분석 (Stemming)
* n-gram 알고리즘 (범용적)
  * 단순히 키워드를 검색해내기 위한 인덱싱 
* 가용성
  * FULLTEXT KEY WITH PARSER ngram

<br>
<hr>
<br>

## 함수 기반 인덱스
#### 

<br>

### 함수 기반 인덱스
* 가상 칼럼을 이용한 인덱스 (VIRTUAL/STORED)
* 함수를 이용한 인덱스 
* 두 방법의 성능 차이는 없다 (내부 구현이 동일하기에)

<br>
<hr>
<br>

## 멀티 밸류 인덱스
#### 

<br>

### 멀티 밸류 인덱스
* JSON 타입
* MEMBER_OF(), JSON_CONTAINS(), JSON_OVERLAPS()

<br>
<hr>
<br>

## 클러스터링 인덱스
#### 

<br>

### 클러스터링 인덱스
* 프라이머리 키 값에 의해 레코드의 저장 위치가 결정되므로 테이블 레코드의 저장 방식이라고 볼 수 있다
* 리프노드에 레코드의 모든 칼럼이 같이 저장
* PK 값이 변경되면, 위치하던 페이지가 달라진다
* 테이블당 하나의 클러스터링 인덱스 사용 가능 
* 세턴더리 인덱스 > 프라이머리 인덱스 > 최종 레코드 조회
* 변경 : 삭제 > 추가

<br>
<hr>
<br>

## 유니크 인덱스
#### 

<br>

### 유니크 인덱스
* Unique Index && Index (세컨더리) > 중복
* Unique Index && Index (PK) > 중복

<br>
<hr>
<br>

## 외래키
#### 

<br>

### 외래키
* 외래키와 연관있는 칼럼 > 잠금 경합 (잠금 대기) O
* 외래키와 연관없는 칼럼 > 잠금 경합 (잠금 대기) X
* 자식 테이블의 변경 작업이 대기하는 경우
* 부모 테이블의 변경 작업이 대기하는 경우
* 경합 상황으로 인해, 전체적인 쿼리 동시 처리 성능에 영향을 줄 수 있다

<br>
<hr>
<br>
