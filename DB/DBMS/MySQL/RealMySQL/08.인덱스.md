# 인덱스
> 
* 

<hr>
<br>

## 디스크 읽기 방식
#### 

<br>

### 하드 디스크 드라이브(HDD), 솔리드 스테이트 드라이브(SSD)
* raid controller
* index range scan > Random I/O
* full table scan > sequential I/O
* sortedlist (DBMS Index) vs arraylist (DBMS)

<br>
<hr>
<br>

## 인덱스란?
#### 

<br>

### 인덱스
* 데이터를 관리하는 방식 (알고리즘)
  * B-Tree Index (B+, B*)
  * Hash Index
* 중복 값 허용 여부
  * 프라이머리 키
  * 세컨더리 키

<br>
<hr>
<br>

## B-Tree 인덱스
####

<br>

### 구조 및 특성 
* InnoDB에서는 클러스터링 테이블을 제공 
  * 프라이머리 키 순서대로 정렬되어 데이터 파일이 저장된다
  * 프라이머리 키를 주소처럼 사용하기 때문에 논리적인 주소를 가진다고 볼 수 있다
  * 모든 세컨더리 인덱스 검색에서 데이터 레코드를 읽기 위해서는 반드시 프라이머리 키를 저장하고 있는 B-Tree를 다시 한 번 검색해야 한다
  * Oracle IOT (Index Organized Table)

<br>

### B-Tree 인덱스 키 추가 및 삭제
* 지연 추가 (체인지 버퍼)
* 바로 추가 (프라이머리 키 or 유니크 인덱스 키)
* 레코드 잠금이나 넥스트 키락(갭락)이 검색을 수행한 인덱스를 잠근 후 테이블의 레코드를 잠그는 방식으로 구현돼 있다 
* 페이지 개수 == 디스크 읽기 횟수

<br>

### B-Tree 인덱스 사용에 영향을 미치는 요소 
* 인덱스 키 값의 크기
* B-Tree 깊이
* 선택도 : Selectivity (기수성 : Cardinality)
  * 모든 인덱스 키 값 가운데 유니크한 값의 수를 의미
  * 전체 레코드 개수 및 기수성은 통계값으로 가지고 있다
  * 인덱스는 기수성이 높은 칼럼 값을 선택해야 함
* 읽어야 하는 레코드의 건수
  * 20~25%를 넘어서면 인덱스를 이용하지 않는 것이 좋겠다고 옵티마이저는 판단

<br>
<hr>
<br>

ㅁ
