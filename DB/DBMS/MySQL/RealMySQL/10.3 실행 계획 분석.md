# 통계 정보
> MySQL 5.7 버전까지 테이블과 인덱스에 대한 개괄적인 정보를 가지고 실행 계획 수립
* MySQL 8.0 버전부터는 인덱스되지 않은 칼럼들에 대해서도 데이터 분포도를 수집해서 저항하는 히스토그램(Histogram) 정보 도입

<hr>
<br>

## 실행 계획 분석
#### (테이블 출력 기준) id가 낮으면 바깥 (Outer) 부분이거나 먼저 접근한 테이블
#### (테이블 출력 기준) id가 높으면 안쪽 (Inner) 부분이거나 나중에 접근한 테이블
#### id, select_type, table 칼럼은 실행 계획의 각 라인에 명시된 테이블이 어떤 순서로 실행되는지를 판단
#### type 이후의 칼럼은 MySQL 서버가 각 테이블의 레코드를 어떤 방식으로 읽었는지를 의미

<br>

### id 칼럼
* 단위 SELECT 쿼리별로 부여되는 식별자 값

<br>

### select_type 칼럼 
* SIMPLE
  * Union, Subquery X
* PRIMARY
  * Union, Subquery O
* UNION
* DEPENDENT UNION
  * union, union all 단위 쿼리가 외부 쿼리에 의해 영향을 받는 것을 의미
* UNION RESULT
  * MySQL 8.0은 아직 Union All일 때는 임시 테이블을 안 만들지만, Union (Union Distinct)일 때는 임시 테이블 생성 후 버퍼링 진행
* SUBQUERY
  * FROM 절 이외에서 사용되는 서브쿼리만을 의미
* DEPENDENT SUBQUERY
  * 안쪽(Inner) 서브쿼리가 바깥쪽(Outer) SELECT 쿼리에서 정의한 칼럼을 사용하는 경우 
* DERIVED
  * FROM 절에 사용되는 서브쿼리
  * 메모리나 디스크에 임시 테이블이 파생되는 케이스
  * 다만, 최근 옵티마이저는 임시 테이블을 만드는 것이 아니라, 조인 형태로 실행계획을 변경하여 최적화를 알아서 수행해줄 수도 있다
    * 개발자는 select_type을 보고 derived가 있다면, 조인을 사용할 것으로 적극 권장
* DEPENDENT DERIVED
  * LATERAL JOIN, FROM 절의 서브쿼리에서도 외부 칼럼 참조 가능
* UNCACHEABLE SUBQUERY
  * 보통, 서브쿼리는 한 번 실행 후 실행 결과를 캐시하여 재활용한다
    * Subquery : 모든 결과를 캐시에 저장
    * Dependent Subquery : 바깥쪽 (Outer) 쿼리의 칼럼의 값 단위로 캐시하여 재활용한다
  * 서브쿼리 캐시는 쿼리 캐시와 파생 테이블과는 무관한 기능, 혼동 X
  * 다만, 모든 서브쿼리가 Cacheable한 것은 아니다
    * 사용자 변수가 서브쿼리에 사용된 경우
    * NOT-DETERMINISTIC 속성의 스토어드 루틴이 서브쿼리에 사용된 경우
    * UUID(), RAND()와 같이 결과값이 호출할 때마다 달라지는 함수가 서브쿼리에 사용된 경우
  * 예시) `@status`
* UNCACHEABLE UNION
  * 캐시가 되지 않는 UNION
  * 캐시하고 싶을 때, 괄호로 감싸주지 말라는 지침도 있다는 점 참고 필요
* MATERIALIZED
  * FROM 절이나 IN(subquery) 형태의 쿼리에 사용된 서브쿼리의 최적화
  * 서브쿼리 결과물을 임시 테이블로 생성한 이후에 조인을 하는 형태로 진행

<br>

### table 칼럼
* `NULL`
  * dual
* `<derived N>`, `<union M, N>`, `<subquery N>`
  * 임시 테이블

<br>

### partitions 칼럼
* 파티션 프루닝 (Partition Pruning)
  * 파티션이 여러 개인 테이블에서 불필요한 파티션을 빼고 쿼리를 수행하기 위해 접근해야 할 것으로 판단되는 테이블만 골라내는 과정
* 파티션 키로 사용되는 칼럼은 프라이머리 키를 포함한 모든 유니크 인덱스의 일부여야함

<br>

### type 칼럼
* 각 테이블의 레코드가 어떤 방식으로 읽었는지 나타냄
  * 쿼리 튜닝할 때 type 칼럼을 받드시 체크해야할 정도의 중요한 정보
* 칼럼 값 목록
  * system
    * 레코드가 1 or 0건만 존재하는 테이블
  * const (unique index scan)
    * 테이블 레코드 건수와 상관없이 프라이머리 키나 유니크 키 칼럼, 유니크 인덱스의 모든 칼럼을 이용하는 WHERE 조건절을 통해 1건의 레코드만 반환하는 처리 방식
    * 상수화
    ```mysql
    SELECT COUNT(*)
    FROM   employees e1
    WHERE  first_name = (SELECT first_name FROM employees e2 WHERE emp_no=100001);
    ```
    ```mysql
    SELECT COUNT(*)
    FROM   employees e1
    WHERE  first_name = 'Jasminko';
    ```
  * eq_ref
    * 조인에서 첫 번째 읽은 테입르의 칼럼값을 이용해 두 번째 테이블ㅇ르 프라이머리 키나 유니크 키로 동등 (Equal) 조건 검색 (두 번째 테이블은 반드시 1건의 레코드만 반환)
      * 여러 테이블이 조인되는 쿼리의 실행 계획에서만 표시
      * 조인에서 처음 읽은 테이블의 칼럼값을, 그다음 읽어야 할 테이블의 프라이머리 키나 유니트 키 칼럼의 검색 조건에 사용할 때
      * 유니크 인덱슨느 Not Null이어야 하며, 모든 칼럼이 비교 조건에 사용되어야만 함
    ```mysql
    EXPLAIN
        SELECT *
        FROM   dept_emp de, employees e
        WHERE  e.emp_no=de.emp_no AND de.dept_no='d005'
    ;
    ``` 
  * ref
    * 조인의 순서와 인덱스의 종류에 관계없이 동등(Equal) 조건으로 검색 (1건의 레코드만 반환된다는 보장이 없어도 됨)
      * 조인의 순서와 관계없이 사용되며, 프라이머리 키나 유니크 키 등의 제약 조건도 없다
      * 인덱스의 종류와 관계없이 동등(Equal) 조건으로 검색할 때는 ref 접근 방법이 사용됨
    ```mysql
    EXPLAIN
        SELECT *
        FROM   dept_emp
        WHERE  dept_no = 'd005'
    ;
    ```
  * fulltext
    * MySQL 서버의 전문 검색(Full-text Search) 인덱스를 사용해 레코드를 읽는 접근 방법을 의미
      * 전문 검색 인덱스는 통계 정보가 관리되지 않으며, 전문 검색 인덱스를 사용하려면 전혀 다른 SQL문법 사용 필요
    * `MATCH(...) AGAINST (...)`
  * ref_or_null
    * ref 접근 방법 + NULL 비교 추가
    ```mysql
    EXPLAIN
        SELECT *
        FROM   titles
        WHERE  to_date='1985-03-01' OR to_date IS NULL
    ;
    ```
  * unique_subquery
    * IN(subquery) 형태의 조건에서 subquery의 반환 값에는 중복이 없으므로 별도의 중복 제거 작업이 필요하지 않음
      * 서브쿼리에서 중복되지 않는 유니크한 값만 반환
    ```mysql
    EXPLAIN
        SELECT *
        FROM   departments
        WHERE  deptno IN (SELECT dept_no FROM dept_emp WHERE emp_no = 10001)
    ;
    ```
    * MySQL 8.0에서는 SEMIJOIN 최적화가 진행되어서 unique_subquery, index_subquery이 실행되지 않을 수 있다
      * `SET optimizer_switch='semijoin=off';`
  * index_subquery
    * IN(subquery) 형태의 조건에서 subquery의 반환 값에는 중복된 값이 있을 수 있지만 인덱스를 이용해 중복된 값을 제거할 수 있음
  * range
    * 인덱스 레인지 스캔 형태의 접근 방법
      * `<`, `>`, `IS NULL`, `BETWEEN`, `IN`, `LIKE`
    ```mysql
    EXPLAIN
        SELECT *
        FROM   employees
        WHERE  emp_no BETWEEN 10002 AND 10004
    ;
    ```
  * index_merge 
    * 2개 이상의 인덱스를 이용해 각각의 검색 결과를 만들어낸 후, 그 결과를 병합해서 처리하는 방식
    * 생각보다 효율적이지 않다
      * 여러 인덱스를 읽어야 하므로 일반적으로 range 접근 방법보다 효율성이 떨어진다
      * 전문 검색 인덱스를 사용하는 쿼리에서는 index_merge가 적용되지 않는다
      * Index_merge 접근 방법으로 처리된 결과는 항상 2개 이상의 집합이 되기 때문에 그 두 집합의 교집합이나 합집합, 또는 중복 제거와 같은 부가적인 작업이 필요
  * index
  * ALL


<br>
<hr>
<br>

