# 쿼리 작성 및 최적화
> SQL은 어떠한 (What) 데이터를 요청하기 위한 언어이지, 어떻게 (How) 데이터를 읽을 지를 표현하는 언어는 아니다
* 그럼에도, 내부적으로 어떻게 동작하는지를 이해한다면, 몇 십 배에서 몇 백 배까지의 성능 향상이 가능하다

<hr>
<br>

## 쿼리 작성과 연관된 시스템 변수
#### SQL 작성 규칙은 MySQL 서버의 시스템 설정에 따라 달라진다

<br>

### SQL 모드
* sql_mode
  * STRICT_ALL_TABLES, STRICT_TRANS_TABLES
    * MySQL 서버에서 INSERT나 UPDATE 문장으로 데이터를 변경하는 경우 칼럼의 타입과 저장되는 값의 타입이 다를 때 자동으로 타입 변경을 수행
    * STRICT_ALL_TABLES
      * 모든 스토리지 엔진에 대해 엄격한 모드(Strict Mode) 적용
    * STRICT_TRANS_TABLES
      * InnoDB 같은 트랜잭션을 지원하는 스토리지 엔진에만 엄격한 모드(Strict Mode) 적용
  * ANSI_QUOTES
    * '' 홀따옴표는 문자열 값 표기
    * "" 쌍따옴표는 칼러명이나 테이블과 같은 식별자(Identifier)를 구분하는 용도로 사용
  * ONLY_FULL_GROUP_BY
    * GROUP BY 절이 사용된 문장의 SELECT 절에는 GROUP BY 절에 명시된 칼럼과 집계 함수(COUNT 또는 SUM과 같은 그룹 함수)만 사용할 수 있다
  * PIPE_AS_CONCAT
    * || (문자열 연결 연산자 CONCAT)로 사용
  * PAD_CHAR_TO_FULL_LENGTH
    * 뒤쪽의 공백이 제거되지 않고 반환되어야 할 때 사용
  * NO_BACKSLASH_ESCAPE
    * \ 역슬래시 문자도 다른 문자와 동일하게 취급할 때 사용
  * IGNORE_SPACE
    * 프로시저나 함수명과 괄호 사이의 공백은 무시
  * REAL_AS_FLAT
    * REAL타입이 DOUBLE이 아닌, FLOAT 타입의 동의어로 변경
  * NO_ZERO_IN_DATE, NO_ZERO_DATE
    * 2020-00-00 같은 실제 존재하지 않는 날짜를 저장하지 않도록 할 때 사용
  * ANSI
    * 최대한 SQL 표준에 맞게 동작하게 만들어준다
    * REAL_AS_FLAT, PIPE_AS_CONCAT, ANSI_QUOTES, IGNORE_SPACE, ONLY_FULL_GROUP_BY
  * TRADITIONAL
    * STRICT_ALL_TABLES, STRICT_TRANS_TABLES, NO_ZERO_IN_DATE, NO_ZERO_DATE, ERROR_FOR_DIVISION_BY_ZERO, NO_ENGINE_SUBSTITUTION 

<br>

### 영문 대소문자 구분
* MySQL 서버는 설치된 운영체제에 따라 테이블명의 대소문자를 구분한다
  * DB나 테이블이 디스크의 디렉토리나 파일로 매핑되기 때문
  * 윈도우 MySQL 대소문자 구분 X
  * 유닉스 계열 MySQL 대소문자 구분 O
* lower_case_table_names 시스템 설정
  * 0 : DB, 테이블에 대해서 대소문자 구분 O
  * 1 : 소문자로만 저장되어 대소문자 구분 X
  * 2 : 윈도우와 macOS에서 저장은 대소문자 구분하는데, 쿼리에서는 대소문자 구분 X (굳이...?)

<br>

### MySQL 예약어
* 생성하는 데이터베이스나 테이블, 칼럼의 이름을 예약어와 같은 키워드로 생성하면 해당 칼럼이나 테이블을 SQL에서 사용하기 위해 항상 역따옴표(\`)나 쌍따옴표로 감싸야 한다

<br>

### 매뉴얼의 SQL 문법 표기를 읽는 방법

<div align="center">
  <img width="50%" src="https://user-images.githubusercontent.com/37537227/229299610-09016140-afb7-4e85-abe9-4937ff00c5a4.png">
</div>

* 대문자
  * 키워드
* italic체
  * 사용자가 선택해서 작성하는 토큰을 의미
  * ex) 테이블명이나 칼럼명, 표현식
* 대괄호(\[])
  * 해당 키워드나 표현식 자체가 선택 사항임을 의미
* 파이프 (|)
  * 앞과 뒤의 키워드나 표현식 중에서 단 하나만 선택해서 사용할 수 있음을 의미
* 중괄호 ({})
  * 아이템 중 반드시 하나를 사용해야 한다를 의미
* ... 표기
  * 명시된 키워드나 표현식의 조합이 반복될 수 있음을 의미

<br>

### MySQL 연산자와 내장 함수
* 리터럴 표기법 문자열
  * 문자열
    * sql_mode : ANSI_QUOTES
  * 숫자
    * 문자열과 숫자 타입으로 다를 때는 자동으로 타입의 변환이 발생하여, 숫자 타입을 우선시한다
  * 날짜 (DATE)
    * MySQL에서는 정해진 형태의 날짜 포맷으로 표기하면 MySQL 서버가 자동으로 DATE나 DATETIME 값으로 변환
    ```mysql
    SELECT * FROM dept_emp WHERE from_date = '2011-04-29'
    SELECT * FROM dept_emp WHERE from_date = STR_TO_DATE('2011-04-29', '%Y-%m-%d');
    ```
  * 불리언 (BOOL, BOOLEAN)
    * TINYINT 타입의 동의여이며, C/C++처럼 0 : FALSE, 1 : TRUE인데, ENUM을 사용하는 것을 추천한다
* MySQL 연산자
  * 동등(Equal) 비교(=, <=>)
    * MySQL에서는 `<=>` Null-safe 비교 연산자를 제공 (1과 0으로 리턴)
* 부정(Not-Equal) 비교(<>, !=)
* NOT 연산자(!)
* AND(&&), OR(||) 연산자
  * sql_mode : PIPES_AS_CONCAT
* 나누기(/, DIV)와 나머지(%, MOD) 연산자
* REGEXP 연산자
  * RLIKE와 동의어
  * POSIX (Portable Operating System Interface)표준으로 구현
    * `^` : 문자열의 시작
    * `$` : 문자열의 끝 
    * `[]` : 문자 그룹
    * `()` : 문자열 그룹
    * `|` : 연결된 문자열 중 하나
    * `.` : 어떠한 문자든지 1개의 문자
    * `*` : 0 또는 1번 이상
    * `+` : 1번 이상
    * `?` : 0 또는 1번만
  * 인덱스 레인지 스캔을 사용할 수 없기에, WHERE 조건절에 REGEXP 연산자 사용은 성능상 좋지 않다
* LIKE 연산자
  * REGEXP는 인덱스를 전혀 타지 못하지만, LIKE는 탈 수도 있기에 더 많이 사용된다
    * 인덱스의 Left-most 특성으로 인해 인덱스 레인지 스캔을 사용하지 못하고 인덱스 풀 스캔을 하는 경우 : `%rist`
      * 인덱스 풀 스캔
    * 인덱스를 탈 수 있는 경우 : `Chris%`
      * 인덱스 레인지 스캔
  * `%` : 0 또는 1개 이상의 모든 문자
  * `_` : 정확히 1개의 문자
* BETWEEN 연산자
  ```mysql
  SELECT * FROM dept_emp
  WHERE  dept_no BETWEEN 'd003' AND 'd005' 
    AND  emp_no = 10001
  ;
  ```
  * BETWEEN 연산은 선형으로 인덱스를 검색한다
  ```mysql
  SELECT * FROM dept_emp
  WHERE  dept_no IN ('d003', 'd004', 'd005')
    AND  emp_no=10001
  ;
  ```
  * IN 연산은 여러 개의 동등 비교(=)를 여러 번 수행하는 것과 같은 효과가 있다

<div align="center">
  <img width="50%" src="https://user-images.githubusercontent.com/37537227/229297436-a5f5ac09-2520-4927-b344-c2c48287d940.png">
</div>

  * BETWEEN과 IN 연산 비교
    * 둘 다 인덱스 레인지 스캔 진행
    * 하지만, BETWEEN는 레코드들을 모두 읽는 반면, IN은 읽어야 하는 레코드만 뽑아서 읽음
      * BETWEEN은 'd003'인 레코드부터 'd005'인 레코드까지 전체 범위를 다 비교
      * IN은 (('d003', 10001), ('d004', 10001), ('d005', 10001)) 조합인 레코드만 비교
    * 즉, IN 연산이 (dept_no, emp_no) 인덱스를 더 최적화해서 사용할 수 있음
* IN 연산자
  * 형태
    * 상수 : IN (?, ?, ?)
    * 서브쿼리 : IN (SELECT ... FROM ...)
* MySQL 내장 함수
  * NULL 값 비교 및 대체 (IFNULL, ISNULL)
  * 현재 시작 조회(NOW, SYSDATE)
    * 모든 NOW()는 하나의 SQL내에서 같은 값을 가진다
    * SYSDATE()는 하나의 SQL내에서 다른 값을 가진다
      * 레플리카 서버에서 안정적으로 복제되지 못한다
      * SYSDATE() 함수와 비교되는 칼럼은 인덱스를 효율적으로 사용하지 못한다
      ```mysql
      EXPLAIN
         SELECT emp_no, salary, from_date, to_date
         FROM   salaries
         WHERE  emp_no=1001 AND from_date > NOW();
      ```
        * 인덱스 레인지 스캔 (range) + key_len(emp_no, from_date) 7
      ```mysql
      EXPLAIN
         SELECT emp_no, salary, from_date, to_date
         FROM   salaries
         WHERE  emp_no=1001 AND from_date > SYSDATE();
      ```
        * 인덱스 스캔 (ref) + key_len (emp_no) 4
  * 날짜와 시간의 포맷(DATE_FORMAT, STR_TO_DATE)
    * DATE_FORMAT() - DATETIME 타입 칼럼이나 값을 원하는 형태의 문자열로 변환
      * `%Y` : 4자리 연도
      * `%m` : 2자리 숫자 표시의 월 (01~12)
      * `%d` : 2자리 숫자 표시의 일자 (01~31)
      * `%H` : 2자리 숫자 표시의 시 (00~23)
      * `%i` : 2자리 숫자 표시의 분 (00~59)
      * `%s` : 2자리 숫자 표시의 초 (00~59)
    * STR_TO_DATE() - 문자열을 DATETIME 타입으로 변환
      ```mysql
      SELECT STR_TO_DATE('2024-04-24', '%Y-%m-%d') AS current_dt;
      SELECT STR_TO_DATE('2024-04-24 23:10:00', '%Y-%m-%d %H:%i:%s') AS current_dt;
      ```
  * 날짜와 시간의 연산(DATE_ADD, DATE_SUB)
    * DATE_ADD, DATE_SUB Interval N [...]
    ```mysql
    SELECT DATE_ADD(NOW(), INTERVAL 1 DAY) AS tomorrow;
    SELECT DATE_ADD(NOW(), INTERVAL -1 DAY) AS yesterday;
    ```
      * YEAR
      * MONTH
      * DAY
      * HOUR
      * MINUTE
      * SECOND
      * MICROSECOND
      * QUARTER
      * WEEK
  * 타임스탬프 연산(UNIX_TIMESTAMP, FROM_UNIXTIME)
  * 문자열 처리(RPAD, LPAD / RTRIM, LTRIM, TRIM)
    * RPAD, LPAD - 좌,우측 문자를 덧붙여서 지정된 길이의 문자열로 만드는 함수
    * RTRIM, LTRIM, TRIM - 좌,우측,양측에 연속된 공백 문자(Space, NewLine, Tab문자)를 제거하는 함수
  * 문자열 결합(CONCAT, CONCAT_WS)
    ```mysql
    SELECT CONCAT_WS('|', 'PoSung', 'Kim') as name; -- PoSung|Kim
    ```
  * GROUP BY 문자열 결합(GROUP_CONCAT)
    ```mysql
    SELECT GROUP_CONCAT(dept_no SEPARATOR '|') FROM departments;
    SELECT GROUP_CONCAT(DISTINCT dept_no ORDER BY emp_no DESC);
    ```
  * 값의 비교와 대체(CASE WHEN ... THEN ... END)
  * 타입의 변환(CAST, CONVERT)
  * 이진값과 16진수 문자열(Hex String) 변환(HEX, UNHEX)
  * 암호화 및 해시 함수(MD5, SHA, SHA2)
  * 처리 대기(SLEEP)
  * 벤치마크(BENCHMARK)
  * IP 주소 변환(INET_ATON, INET_NTOA)
  * JSON 포맷(JSON_PRETTY)
  * JSON 필드 크기(JSON_STORAGE_SIZE)
  * JSON 필드 추출(JSON_EXTRACT)
  * JSON 오브젝트 포함 여부 확인(JSON_CONTAINS)
  * JSON 오브젝트 생성(JSON_OBJECT)
  * JSON 칼럼으로 집계(JSON_OBJECTAGG & JSON_ARRAYAGG)
  * JSON 데이터를 테이블로 변환(JSON_TABLE)


<br>
<hr>
<br>


