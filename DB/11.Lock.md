# Lock
> 자원은 항상 유한하다
* CPU, Memory, DB 등 제한된 자원을 동시에 공유해서 사용할 때에 대한 제어가 반드시 필요

<hr>
<br>

## DB 수준 Lock
#### Optimistic Lock 및 Pessimistic Lock

<br>

### Optimistic Lock
* 낙관적으로 생각해서, 동시성에서 충돌이 없을 것이다 라는 생각에서 출발
* Application Level에서 제어
* 장점
  * 성능이 더 좋다
* 단점
  * 롤백을 직접 구현해야 함
```java
@Entity
public class Student {

    @Id
    private Long id;

    private String name;

    private String lastName;

    @Version
    private Integer version;

    // getters and setters

}
```
* Version 칼럼을 활용하는 것이 흔히 보는 Optimistic Lock 예제

<br>

### Pessimistic Lock
* 비관적으로 생각해서, 충돌은 백퍼 발생할 것이다 라는 생각에서 출발
* DB Level에서 제어
* 장점
  * DB 트랜젝션 사용 가능 
* 단점
  * 동시성이 떨어지고, 데드락 발생 가능
* Shared Lock
* Exclusive Lock

<br>
<hr>
<br>

## Memory 수준 Lock
#### [Multi-thread 프로그래밍에서의 동기화](https://github.com/PoSungKim/development_study/blob/main/Programming/Java/11.1%20JVM%20Layout,%20Thread,%20%EB%8F%99%EA%B8%B0%ED%99%94.md#multi-thread-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%97%90%EC%84%9C%EC%9D%98-%EB%8F%99%EA%B8%B0%ED%99%94)

<br>
<hr>
<br>
