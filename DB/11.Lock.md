# Lock
> 
* 

<hr>
<br>

## 
#### 

<br>

### Optimistic Lock
* 낙관적으로 생각해서, 동시성에서 충돌이 없을 것이다 라는 생각에서 출발
* Application Level에서 제어
* 장점
  * 성능이 더 좋다
* 단점
  * 롤백을 직접 구현해야 함
```java
@Entity
public class Student {

    @Id
    private Long id;

    private String name;

    private String lastName;

    @Version
    private Integer version;

    // getters and setters

}
```
* Version 칼럼을 활용하는 것이 흔히 보는 Optimistic Lock 예제

<br>

### Pessimistic Lock
* 비관적으로 생각해서, 충돌은 백퍼 발생할 것이다 라는 생각에서 출발
* DB Level에서 제어
* 장점
  * DB 트랜젝션 사용 가능 
* 단점
  * 동시성이 떨어지고, 데드락 발생 가능
* Shared Lock
* Exclusive Lock

<br>

### Spin Lock
* Lock이 잡혀서 Critical Section 진입이 안 되더라도, 조금만 기다리면 진입될텐데 굳이 컨텍스트 스위칭이 필요한가? 라는 생각에서 출발
* 다른 스레드가 Lock을 소유하고 있다면 그 Lock이 반환될 때까지 계속 확인 (무한 루프)하며 기다리는 것이다 (Busy Waiting)
* 장점
  * 컨텍스트 스위칭 오버헤드를 줄일 수 있다
* 단점
  * 특정 쓰레드가 Crtical Section을 점유하고 있고, Busy Waiting 하는 다른 쓰레드들이 많아지면, CPU 사용률 100% 가능
  * 오히려, 잠시 Sleep and Wakup 알고리즘이 나을 수 있음
  ```java
    while(checkCondtion()) {

    }
    doTask();
  ```
  ```java
    while(checkCondtion()) {
        sleep();
    }
    doTask();
  ```

<br>
<hr>
<br>
