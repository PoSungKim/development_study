# 아키텍처 
> MySQL 서버 = 사람의 머리 역할을 담당하는 MySQL 엔진과 손발 역할을 담당하는 스토리지 엔진
* 손과 발 역할을 담당하는 스토리지 엔진은 핸들러 API를 만족하면 누든지 스토리지 엔진을 구현해서 MySQL 서버에 추가해서 사용 가능

<hr>
<br>

## 
#### 

<br>

### MySQL 엔진 아키텍처

<div align="center" width="50%" >
    <img src="https://user-images.githubusercontent.com/37537227/211307302-ce4ce8c7-07ad-4eeb-bb66-f315eeb87e4d.png" />
</div>

<br>

### MySQL 엔진
* 커넥션 핸들러
* SQL 인터페이스
* SQL 파서
* SQL 옵티마이저
* 캐시 & 버퍼

<br>

### 스토리지 엔진
* MySQL 서버 : 1개의 MySQL 엔진 + N개의 스토리지 엔진으로 구성 가능
```mysql
CREATE TABLE test_table (fd1 INT, fd2 INT) ENGINE=INNODB;
```
* 각 스토리지 엔진은 성능 향상을 위해 키 캐시 (MyISAM 스토리지 엔진) 혹은 InnoDB 버퍼 풀 (InnoDB 스토리지 엔진)과 같은 기능을 내장하고 있다

<br>

### 핸들러 API
* MySQL 엔진의 쿼리 실행기에서 데이터를 쓰거나 읽어야 할 때 각 스토리지 엔진에 쓰기 또는 읽기를 요청하는데, 이러한 요청을 핸들러 (Handler) 요청이라 하고, 여기서 사용되는 API를 핸들러 API라고 한다.
```mysql
SHOW GLOBAL STATUS LIKE 'Handler%';
```

<br>

### MySQL 스레딩 구조
* MySQL은 프로세스 기반이 아니라 쓰레드 기반으로 작동
  * Foreground 쓰레드 + Background 쓰레드
```mysql
SELECT thread_id, name, type, processlist_user, processlist_host
FROM   performance_shema.threads ORDER BY type, thread_id;
```
* 대부분의 Thread는 Background
* 소수의 Thread는 Foreground
  * 실제 사용자의 요청을 처리하는 Foreground 쓰레드는 `thread/sql/one_connection`
* MySQL 커뮤니티 에디션 (전통적 모델)
  * 커넥션별로 포그라운드 쓰레드가 하나씩 생성 (1:1 관계) --> 이러한 형태이기 때문에 포그라운드 쓰레드라고도 하며 사용자 쓰레드라고도 한다
* MySQL 엔터프라이즈 에디션 (쓰레드 풀 모델)
  * 하나의 쓰레드에 다수의 커넥션 요청 처리 가능 (N:1 관계)

<br>

### 포그라운드 쓰레드 (클라이언트 쓰레드)
* 포그라운드 쓰레드 개수는 최소 MySQL 서버에 접속된 클라이언트의 개수만큼 존재
* 클라이언트 사용자가 작업을 마치고, 커넥션을 종료하면, 해당 컨넥션을 담당하던 쓰레드는 쓰레드 캐시 (Thread Cache)로 돌아간다
  * 다만, Thread Cache 속 쓰레드 개수가 일정 개수 이상을 넘으면 Thread Cache에 넣지 않고, 쓰레드를 종료시킨다
  * 쓰레드 캐시에 유지할 수 있는 최대 쓰레드 개수 --> `thread_cache_size`
* 포그라운드 쓰레드는 데이터를 MySQL의 데이터 버퍼나 캐시로부터 가져오며, 버퍼나 캐시에 없는 경우에는 직접 디스크의 데이터나 인덱스 파일로부터 데이터를 읽어와서 작업을 처리한다
  * InnoDB 테이블은 데이터 버퍼나 캐시까지만 포그라운드 쓰레드가 처리
  * 나머지 버퍼로부터 디스크까지 기록하는 작업은 백그라운드 쓰레드가 처리

<br>

### 백그라운드 쓰레드
* InnoDB 
  * 인서트 버퍼 (Insert Buffer)를 병합하는 쓰레드
  * 로그를 디스크로 기록하는 쓰레드 (Log Thread)
  * InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 쓰레드 (Write Thread)
  * 데이터를 버퍼로 읽어 오는 쓰레드 (Read Thread)
  * 잠금이나 데드락을 모니터링하는 쓰레드
* 설정 (쓰레드 개수 지정 가능)
  * innodb_write_io_threads
  * innodb_read_io_threads
* 대부분의 DBMS는 사용자의 읽기 요청은 지연(버퍼링)이 없고, 쓰기 요청은 지연(버퍼링)을 통해 일괄 처리하는 기능을 제공
  * InnoDB는 제공, MyISAM 비제공

<br>

### 메모리 할당 및 사용 구조
* MySQL에서 사용하는 메모리 공간은 크게 글로벌 메모리 영역과 로컬 메모리 영역으로 구분
  * 글로벌 메모리 영역의 모든 메모리 공간은 MySQL 서버가 시작되면서 운영체제로부터 할당된다
* 글로벌 메모리 영역
  * 특징 
    * 일반적으로 클라이언트 쓰레드의 수와 무관하게 하나의 메모리 공간만 할당되며, 모든 쓰레드에 의해 공유된다
  * 구성 예시)
    * 테이블 캐시
    * InnoDB 버퍼 풀
    * InnoDB 어댑티브 해시 인덱스
    * InnoDB 리두 로그 버퍼
* 세션 (커넥션) 메모리 영역
  * 특징
    * MySQL 서버상에 존재하는 클라이언트 쓰레드가 쿼리를 처리하는 데 사용하는 메모리 영역
    * 세션 메모리는 각 클라이언트 쓰레드별로 독립적으로 할당되며 절대 공유되어 사용되지 않는다 
    * 각 쿼리의 용도별로 필요할 때만 공간이 할당되고 필요하지 않은 경우에는 MySQL이 메모리 공간을 할당조차도 하지 않을 수도 있다
      * 커넥션이 열려 있는 동안 할당 상태로 남는 공간 : 커넥션 버퍼, 결과 버퍼
      * 쿼리 실행하는 순간에만 할당했다가 다시 해제하는 공간 : 소트 버퍼, 조인 버퍼
  * 구성 예시)
    * 커넥션 버퍼
    * 정렬(Sort) 버퍼
    * 조인(Join) 버퍼
    * 바이너리 로그 캐시
    * 네트워크 버퍼

<br>
<hr>
<br>
