## 널 가능성
> ㅇㅇ
* ㅇ

<hr>
<br>

## 널 도입과 널 가능성의 필요성
#### 타입 시스템에 Null 가능 여부를 표현하는 타입을 추가하여 컴파일 시점에 컴파일러가 NPE를 발생시킬만한 코드를 최대한 필터링하는 경우가 많아지고 있다

```kt
class NotFound: Exception("원소를 찾을 수 없습니다.")

fun <T> find(array: Array<T>, predicate: (T)-> Boolean) : T {
    for(element in array) {
        if (predicate(element)) return element
    }
    throw NotFound()
}
```
* 컴파일 성공 (Good, but not enough!)
  * 다만, Exception을 정의하는 프로세스는 오버해드가 될 수 있다

```kt
fun <T> find(array: Array<T>, predicate: (T)-> Boolean) : T {
    for(element in array) {
        if (predicate(element)) return element
    }
    return null // --> Kotlin: Null can not be a value of a non-null type T
}
```
* 컴파일 실패 (Bad!)
  * `T` : 제네릭 타입은 널이 될 수 있는 타입이나 널이 될 수 없는 타입 모두 들어갈 수 있다

<br>

### 제네릭 타입 파라미터에서의 널 가능성
```kt
fun <T> find2(array: Array<T>, predicate: (T)-> Boolean) : T? {

    for(element in array) {
        if (predicate(element)) return element
    }
    return null
}

fun main(args: Array<String>) {
    val array = arrayOf(1, 2, 3, 4, 5)
    println(find(array) { it > 5 }) // null
}
```
* 컴파일 성공 (Good!)
  * `T?` : `?`로 널이 될 수 있는 타입 지정 가능

```kt
fun main(args: Array<String>) {
    val array = arrayOf(null, 1, 2, 3, 4, 5)
    println(find(array) { it >= 100 }) // Kotlin: Operator call corresponds to a dot-qualified call 'it.compareTo(100)' which is not allowed on a nullable receiver 'it'.
}
```
* 컴파일 실패 (Bad!)
  * `it` : `value-parameter it: Int?`로 추론되는 것이 문제

<br>

### 타입 바운드와 널이 될 수 있는 타입

```kt
fun <T : Any> find2(array: Array<T>, predicate: (T)-> Boolean) : T? {

    for(element in array) {
        if (predicate(element)) return element
    }
    return null
}

fun main(args: Array<String>) {
    val array = arrayOf(null, 1, 2, 3, 4, 5)
    println(find2(array) { it > 100 }) // Kotlin: Type mismatch: inferred type is Int? but Any was expected
}
```
* 컴파일 실패 (Good!)
  * `T: Any` : 

<br>
<hr>
<br>

