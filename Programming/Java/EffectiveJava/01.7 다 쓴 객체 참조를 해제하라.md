# 객체 생성과 파괴
> 올바르게 생성하는 방법과 제때 파괴하는 방법
* 객체를 파괴하기 전에 수행해야 하는 정리 작업 또한 존재

<hr>
<br>

## 다 쓴 객체 참조를 해제하라 
#### GC 기반 언어는 GC가 알아서 자원 회수를 진행하지만 그럼에도 메모리 누수로부터 자유로운 것은 아니다
#### OutOfMemoryError, 디스크 페이징이 발생할 수 있다

<br>

### 안 좋은 예시) Stack

```java
public class Stack {
    private Object[] elements;
    private int size = 0;
    private static final int DEFAULT_INITIAL_CAPACITY = 16;

    public Stack() {
        elements = new Object[DEFAULT_INITIAL_CAPACITY];
    }

    public void push(Object e) {
        ensureCapacity();
        elements[size++] = e;
    }

    public Object pop() {
        if (size == 0) throw new EmptyStackException();

        return elements[--size];
    }

    public void ensureCapacity() {
        if (elements.length == size)
            elements = Arrays.copyOf(elements, 2 * size + 1);
    }
}
```
* 다 쓴 참조 (Obsolete Reference)
  * 객체 참조 하나를 살려두면 GC는 그 객체뿐만 아니라 그 객체가 참조하는 모든 객체, 그리고 또 그 객체들이 참조하는 모든 객체...등등을 회수하지 못한다
  * 즉, 단 몇 개의 객체가 굉장히 많은 객체를 회수하지 못하게 할 수 있다

<br>

### 
```java
public Object pop() {
    if (size == 0)
        throw new EmptyStackException();

    Object result = elements[--size];
    elements[size] = null;

    return result;
}
```
* `elements[size] = null` 부분을 통해, obsolete reference를 해재해준다


<br>
<hr>
<br>

